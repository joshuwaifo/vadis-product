Directory structure:
└── joshuwaifo-cannes-demo/
    ├── components.json
    ├── drizzle.config.ts
    ├── package.json
    ├── postcss.config.js
    ├── tailwind.config.ts
    ├── tsconfig.json
    ├── vite.config.ts
    ├── .replit
    ├── attached_assets/
    ├── client/
    │   ├── index.html
    │   ├── public/
    │   │   └── assets/
    │   └── src/
    │       ├── App.tsx
    │       ├── index.css
    │       ├── main.tsx
    │       ├── components/
    │       │   ├── actors/
    │       │   │   ├── ActorDetailsDialog.tsx
    │       │   │   └── EditActorModal.tsx
    │       │   ├── layout/
    │       │   │   ├── Footer.tsx
    │       │   │   └── Header.tsx
    │       │   ├── locations/
    │       │   │   ├── AddLocationModal.tsx
    │       │   │   ├── DeleteLocationDialog.tsx
    │       │   │   └── EditLocationModal.tsx
    │       │   ├── products/
    │       │   │   ├── AddProductModal.tsx
    │       │   │   ├── DeleteProductDialog.tsx
    │       │   │   ├── EditProductModal.tsx
    │       │   │   └── ProductCard.tsx
    │       │   ├── script/
    │       │   │   ├── ActorSuggestionCard.tsx
    │       │   │   ├── BrandableScenes.tsx
    │       │   │   ├── ChangeProductModal.tsx
    │       │   │   ├── CharacterCasting.tsx
    │       │   │   ├── FileUpload.tsx
    │       │   │   ├── FinancialAnalysisModal.tsx
    │       │   │   ├── ImageZoomModal.tsx
    │       │   │   ├── SceneBreakdown.tsx
    │       │   │   ├── ScriptDisplay.tsx
    │       │   │   ├── SuggestedLocations.tsx
    │       │   │   ├── VfxSceneDetails.tsx
    │       │   │   └── VideoPlayerModal.tsx
    │       │   └── ui/
    │       │       ├── accordion.tsx
    │       │       ├── alert-dialog.tsx
    │       │       ├── alert.tsx
    │       │       ├── aspect-ratio.tsx
    │       │       ├── avatar.tsx
    │       │       ├── badge.tsx
    │       │       ├── button.tsx
    │       │       ├── card.tsx
    │       │       ├── chart.tsx
    │       │       ├── checkbox.tsx
    │       │       ├── dialog.tsx
    │       │       ├── dropdown-menu.tsx
    │       │       ├── form.tsx
    │       │       ├── input.tsx
    │       │       ├── label.tsx
    │       │       ├── popover.tsx
    │       │       ├── progress.tsx
    │       │       ├── scroll-area.tsx
    │       │       ├── select.tsx
    │       │       ├── separator.tsx
    │       │       ├── sheet.tsx
    │       │       ├── sidebar.tsx
    │       │       ├── skeleton.tsx
    │       │       ├── slider.tsx
    │       │       ├── switch.tsx
    │       │       ├── table.tsx
    │       │       ├── tabs.tsx
    │       │       ├── textarea.tsx
    │       │       ├── toast.tsx
    │       │       ├── toaster.tsx
    │       │       ├── toggle-group.tsx
    │       │       ├── toggle.tsx
    │       │       └── tooltip.tsx
    │       ├── hooks/
    │       │   ├── use-mobile.tsx
    │       │   └── use-toast.ts
    │       ├── lib/
    │       │   ├── queryClient.ts
    │       │   ├── types.ts
    │       │   └── utils.ts
    │       └── pages/
    │           ├── ActorsDatabase.tsx
    │           ├── Contact.tsx
    │           ├── LocationsDatabase.tsx
    │           ├── not-found.tsx
    │           ├── PrivacyPolicy.tsx
    │           ├── ProductDatabase.tsx
    │           ├── ScriptEditor.tsx
    │           ├── ScriptWriter.tsx
    │           ├── TermsOfService.tsx
    │           └── Welcome.tsx
    ├── db/
    │   ├── index.ts
    │   └── seed.ts
    ├── server/
    │   ├── index.ts
    │   ├── routes.ts
    │   ├── storage.ts
    │   ├── types.ts
    │   ├── vite.ts
    │   ├── routes/
    │   │   └── character-casting-routes.ts
    │   ├── services/
    │   │   ├── ai-suggestion-service.tsx
    │   │   ├── character-suggestion-optimizer.ts
    │   │   ├── file-upload-service.ts
    │   │   ├── financial-analysis-service.ts
    │   │   ├── pdf-generation-service.ts
    │   │   ├── pdf-parse-wrapper.ts
    │   │   ├── pdf-service.ts
    │   │   ├── replicate-service.ts
    │   │   ├── script-generation-service.ts
    │   │   ├── vfx-analysis-service.ts
    │   │   └── ai-agents/
    │   │       ├── ai-client.ts
    │   │       ├── character-casting-pipeline.ts
    │   │       ├── db-filter-service.ts
    │   │       ├── description-agent.ts
    │   │       ├── extraction-agent.ts
    │   │       ├── genre-agent.ts
    │   │       ├── index.ts
    │   │       ├── selection-agent.ts
    │   │       ├── shared-types.ts
    │   │       └── summary-agent.ts
    │   └── types/
    │       ├── financials.d.ts
    │       └── pdf-parse.d.ts
    ├── shared/
    │   └── schema.ts
    └── test/
        └── data/

================================================
FILE: components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "client/src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}



================================================
FILE: drizzle.config.ts
================================================
import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./db/migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
  verbose: true,
});



================================================
FILE: package.json
================================================
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "db:push": "drizzle-kit push --force --config=./drizzle.config.ts",
    "dev": "tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:seed": "tsx db/seed.ts",
    "update-actor-dob": "tsx update-actor-dob.ts",
    "populate-actor-dob": "tsx populate-actor-dob.ts",
    "populate-remaining-actors": "tsx populate-remaining-actors.ts",
    "populate-remaining-actors-manual": "tsx populate-remaining-actors-manual.ts"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.37.0",
    "@google/genai": "^0.13.0",
    "@google/generative-ai": "^0.24.1",
    "@hookform/resolvers": "^3.9.1",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@pdf-lib/fontkit": "^1.1.1",
    "@radix-ui/react-accordion": "^1.2.1",
    "@radix-ui/react-alert-dialog": "^1.1.2",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-checkbox": "^1.1.2",
    "@radix-ui/react-collapsible": "^1.1.1",
    "@radix-ui/react-context-menu": "^2.2.2",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-hover-card": "^1.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.2",
    "@radix-ui/react-navigation-menu": "^1.2.1",
    "@radix-ui/react-popover": "^1.1.2",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.1",
    "@radix-ui/react-scroll-area": "^1.2.0",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.1",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "@radix-ui/react-tabs": "^1.1.1",
    "@radix-ui/react-toast": "^1.2.2",
    "@radix-ui/react-toggle": "^1.1.0",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.3",
    "@replit/vite-plugin-cartographer": "^0.0.11",
    "@replit/vite-plugin-shadcn-theme-json": "^0.0.4",
    "@tanstack/react-query": "^5.60.5",
    "@types/multer": "^1.4.12",
    "@types/uuid": "^10.0.0",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "connect-pg-simple": "^10.0.0",
    "date-fns": "^3.6.0",
    "dotenv": "^16.5.0",
    "drizzle-orm": "^0.38.4",
    "drizzle-seed": "^0.3.1",
    "drizzle-zod": "^0.6.0",
    "embla-carousel-react": "^8.3.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "framer-motion": "^11.13.1",
    "input-otp": "^1.2.4",
    "lucide-react": "^0.453.0",
    "mime": "^4.0.7",
    "multer": "^1.4.5-lts.2",
    "openai": "^4.97.0",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "pdf-lib": "^1.17.1",
    "pdf-parse": "^1.1.1",
    "pdfjs-dist": "^5.2.133",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.53.1",
    "react-icons": "^5.4.0",
    "react-resizable-panels": "^2.1.4",
    "recharts": "^2.13.0",
    "replicate": "^1.0.1",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^11.1.0",
    "vaul": "^1.1.0",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.23.8",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.0",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.27.1",
    "esbuild": "^0.24.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.14",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.9"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}



================================================
FILE: postcss.config.js
================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



================================================
FILE: tailwind.config.ts
================================================
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    screens: {
      'xs': '480px',
      ...require('tailwindcss/defaultTheme').screens,
    },
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          "1": "hsl(var(--chart-1))",
          "2": "hsl(var(--chart-2))",
          "3": "hsl(var(--chart-3))",
          "4": "hsl(var(--chart-4))",
          "5": "hsl(var(--chart-5))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))",
        },
        // Custom colors
        "vadis-purple": "hsl(var(--vadis-purple))",
        "vadis-blue-ai": "hsl(var(--vadis-blue-ai))",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
} satisfies Config;



================================================
FILE: tsconfig.json
================================================
{
  "include": ["client/src/**/*", "db/**/*", "server/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@db": ["./db/index.ts"],
      "@db/*": ["./db/*"],
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}



================================================
FILE: vite.config.ts
================================================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";

export default defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...(process.env.NODE_ENV !== "production" &&
    process.env.REPL_ID !== undefined
      ? [
          await import("@replit/vite-plugin-cartographer").then((m) =>
            m.cartographer(),
          ),
        ]
      : []),
  ],
  resolve: {
    alias: {
      "@db": path.resolve(import.meta.dirname, "db"),
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets"),
    },
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true,
  },
});



================================================
FILE: .replit
================================================
modules = ["nodejs-20", "bash", "web", "postgresql-16"]
run = "npm run dev"
hidden = [".config", ".git", "generated-icon.png", "node_modules", "dist"]

[nix]
channel = "stable-24_05"

[deployment]
deploymentTarget = "cloudrun"
run = ["npm", "run", "start"]
build = ["npm", "run", "build"]

[workflows]
runButton = "Project"

[[workflows.workflow]]
name = "Project"
mode = "parallel"
author = "agent"

[[workflows.workflow.tasks]]
task = "workflow.run"
args = "Start application"

[[workflows.workflow]]
name = "Start application"
author = "agent"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "npm run dev"
waitForPort = 5000

[[ports]]
localPort = 5000
externalPort = 80




================================================
FILE: client/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
    <title>VadisMedia - AI-Powered Script Analysis</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <!-- This is a replit script which adds a banner on the top of the page when opened in development mode outside the replit environment -->
    <script type="text/javascript" src="https://replit.com/public/js/replit-dev-banner.js"></script>
  </body>
</html>



================================================
FILE: client/src/App.tsx
================================================
// client/src/App.tsx
import { useState } from "react";
import { Switch, Route, useLocation } from "wouter"; // Import useLocation
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import Welcome from "@/pages/Welcome";
import ScriptEditor from "@/pages/ScriptEditor";
import ProductDatabase from "@/pages/ProductDatabase";
import ActorsDatabase from "@/pages/ActorsDatabase";
import LocationsDatabase from "@/pages/LocationsDatabase";
import PrivacyPolicy from "@/pages/PrivacyPolicy";
import TermsOfService from "@/pages/TermsOfService";
import Contact from "@/pages/Contact";
import ScriptWriter from "@/pages/ScriptWriter"; // Added ScriptWriter
import NotFound from "@/pages/not-found";
import Header from "@/components/layout/Header";
import Footer from "@/components/layout/Footer";
import { TabType } from "@/lib/types";

function App() {
  const [activeTab, setActiveTab] = useState<TabType>("welcome");
  const [location, setLocation] = useLocation(); // Wouter hook for navigation

  const handleTabChange = (tab: TabType) => {
    setActiveTab(tab);
    // If the current path is not the root path (where main components are rendered),
    // navigate to the root path to trigger the rendering of the new active tab.
    if (location !== "/") {
      setLocation("/");
    }
  };

  // Function to render the active component based on the selected tab
  const renderActiveComponent = () => {
    switch (activeTab) {
      case "welcome":
        return <Welcome onTabChange={handleTabChange} />;
      case "script":
        return <ScriptEditor />;
      case "script-writer": // Added script-writer case
        return <ScriptWriter />;
      case "products":
        return <ProductDatabase />;
      case "actors":
        return <ActorsDatabase />;
      case "locations":
        return <LocationsDatabase />;
      default:
        // Fallback to welcome, or handle as an error/redirect if preferred
        return <Welcome onTabChange={handleTabChange} />;
    }
  };

  return (
    <QueryClientProvider client={queryClient}>
      <div className="min-h-screen flex flex-col">
        <Header activeTab={activeTab} onTabChange={handleTabChange} />

        <main className="flex-grow container mx-auto px-4 py-6">
          {/* The Switch component will render the first Route that matches */}
          <Switch>
            {/* Static pages first, so they take precedence if their path is matched */}
            <Route path="/privacy-policy" component={PrivacyPolicy} />
            <Route path="/terms-of-service" component={TermsOfService} />
            <Route path="/contact" component={Contact} />
            <Route path="/script-writer" component={ScriptWriter} />
            {/* The root path now uses renderActiveComponent, which depends on activeTab */}
            <Route path="/" component={() => renderActiveComponent()} />
            {/* Catch-all for 404 */}
            <Route component={NotFound} />
          </Switch>
        </main>

        <Footer />
        <Toaster />
      </div>
    </QueryClientProvider>
  );
}

export default App;


================================================
FILE: client/src/index.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    /* Light theme adjustments to match target screenshot */
    --background: 220 20% 97%;
    /* Very light gray for overall page background */
    --foreground: 222 47% 11%;
    /* Dark text */

    --card: 0 0% 100%;
    /* White for cards/panels */
    --card-foreground: 222 47% 11%;

    --popover: 0 0% 100%;
    --popover-foreground: 222 47% 11%;

    /* Primary accent color from the target screenshot (blue/purple) */
    --primary: 248 89% 60%;
    --primary-foreground: 210 40% 98%;
    /* White text for primary buttons */

    /* Secondary for app header background - for the main header */
    --secondary: 0 0% 100%;
    /* White for header background */
    --secondary-foreground: 222 47% 11%;
    /* Dark text for header */

    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;

    --accent: 210 40% 90%;
    --accent-foreground: 222.2 47.4% 11.2%;

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    /* Standard border color */
    --input: 214.3 31.8% 91.4%;
    --ring: 248 89% 60%;
    /* Match new primary */

    --radius: 0.5rem;

    /* Custom colors from target design */
    --vadis-purple: 258 68% 53%;
    /* For footer */
    --vadis-blue-ai: 220 85% 55%;
    /* For "AI" text in logo & potentially other specific blue accents */
    --vadis-dark-text: 222 47% 11%;
    /* General dark text */
    --vadis-light-gray-bg: 220 20% 97%;
    /* Page background */

    --chart-1: 248 89% 60%;
    --chart-2: 222 47% 23%;
    /* Kept this for contrast if needed elsewhere */
    --chart-3: 210 40% 96.1%;
    --chart-4: 215.4 16.3% 46.9%;
    --chart-5: 220 14.3% 95.9%;

    /* Sidebar colors (from target design) */
    --sidebar-background: 220 10% 20%;
    /* Darker gray for sidebar itself */
    --sidebar-foreground: 0 0% 100%;
    /* White text for sidebar items */
    --sidebar-primary: 248 89% 60%;
    /* Blue for active sidebar item */
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 220 10% 25%;
    /* Hover for sidebar items */
    --sidebar-accent-foreground: 0 0% 100%;
    --sidebar-border: 220 10% 30%;
    --sidebar-ring: 248 89% 60%;
  }

  .dark {
    /* Dark theme can remain similar, or be adjusted if needed */
    --background: 222 47% 11%;
    --foreground: 210 40% 98%;

    --card: 222 47% 15%;
    --card-foreground: 210 40% 98%;

    --popover: 222 47% 15%;
    --popover-foreground: 210 40% 98%;

    --primary: 248 89% 60%;
    --primary-foreground: 210 40% 98%;

    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;

    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;

    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;

    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 248 89% 60%;

    --vadis-purple: 258 68% 53%;
    --vadis-blue-ai: 220 85% 55%;
    --vadis-dark-text: 210 40% 98%;
    /* Lighter text for dark mode */
    --vadis-light-gray-bg: 222 47% 11%;
    /* Dark bg for dark mode */

    --sidebar-background: 222 47% 11%;
    --sidebar-foreground: 210 40% 98%;
    --sidebar-primary: 248 89% 60%;
    --sidebar-primary-foreground: 210 40% 98%;
    --sidebar-accent: 217.2 32.6% 17.5%;
    --sidebar-accent-foreground: 210 40% 98%;
    --sidebar-border: 217.2 32.6% 17.5%;
    --sidebar-ring: 248 89% 60%;
  }

  * {
    @apply border-border;
  }

  body {
    @apply font-sans antialiased bg-background text-foreground;
    /* bg-background is now light gray */
  }

  /* Custom Scrollbar */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  ::-webkit-scrollbar-track {
    @apply bg-muted rounded;
  }

  ::-webkit-scrollbar-thumb {
    @apply bg-gray-400 dark:bg-gray-600 rounded hover:bg-gray-500 dark:hover:bg-gray-500 transition-all;
    /* Adjusted scrollbar thumb */
  }

  /* Header customizations */
  header {
    @apply relative z-10;
  }
  
  header .logo-section {
    @apply flex-shrink-0 mr-4 sm:mr-6;
  }
  
  header .demo-text {
    @apply text-primary font-medium text-base relative top-px;
  }
  
  header nav {
    @apply flex-1 flex justify-end;
  }
  
  header nav ul {
    @apply flex items-center;
  }
  
  /* Mobile header adjustments */
  @media (max-width: 640px) {
    header .container {
      @apply px-1 py-1.5;
    }
    
    header nav {
      @apply -mx-1 px-1;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
      scrollbar-width: none; /* Firefox */
    }
    
    header nav::-webkit-scrollbar {
      display: none; /* Chrome, Safari, Edge */
    }
    
    header nav ul {
      @apply w-full justify-start py-1 px-1 flex-nowrap;
    }
  }
  
  /* Extra small device header fixes */
  @media (max-width: 360px) {
    header .container {
      @apply px-0.5 py-1;
    }
    
    header nav {
      @apply mt-0.5 pb-0.5;
    }
    
    header nav ul {
      @apply gap-0.5;
    }
  }

  /* Script editor customizations */
  .script-editor {
    font-family: 'Courier New', monospace;
  }

  .scene-item {
    @apply transition-all duration-200;
  }

  .scene-item.active {
    @apply border-l-4 border-primary bg-primary/10;
  }

  .scene-item:not(.active) {
    @apply border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-50;
  }

  .brandable-indicator {
    @apply text-primary;
  }
}


================================================
FILE: client/src/main.tsx
================================================
import { createRoot } from "react-dom/client";
import App from "./App";
import "./index.css";

createRoot(document.getElementById("root")!).render(<App />);



================================================
FILE: client/src/components/actors/ActorDetailsDialog.tsx
================================================
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from "@/components/ui/dialog";
import { Actor } from "@/lib/types";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";

interface ActorDetailsDialogProps {
  isOpen: boolean;
  actor: Actor | null;
  onClose: () => void;
}

export default function ActorDetailsDialog({ isOpen, actor, onClose }: ActorDetailsDialogProps) {
  if (!actor) return null;
  
  // Format arrays for display
  const formatArray = (value: string[] | string | null): string => {
    if (!value) return "-";
    return Array.isArray(value) ? value.join(", ") : value;
  };
  
  // Calculate age if birthdate is available
  const calculateAge = (dateOfBirth: string): number => {
    const birthDate = new Date(dateOfBirth);
    const today = new Date();
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      age--;
    }
    
    return age;
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <DialogContent className="sm:max-w-3xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="text-xl font-bold">{actor.name}</DialogTitle>
        </DialogHeader>
        
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mt-4">
          {/* Left column - Image and basic info */}
          <div className="space-y-4">
            <div className="rounded-md overflow-hidden border bg-card h-64 w-full">
              {actor.imageUrl ? (
                <img 
                  src={actor.imageUrl} 
                  alt={actor.name} 
                  className="w-full h-full object-cover"
                  onError={(e) => {
                    const target = e.target as HTMLImageElement;
                    target.src = "https://placehold.co/300x400/gray/white?text=No+Image";
                  }}
                />
              ) : (
                <div className="flex items-center justify-center w-full h-full bg-muted">
                  <span className="text-2xl font-semibold">
                    {actor.name.substring(0, 2).toUpperCase()}
                  </span>
                </div>
              )}
            </div>
            
            <div className="space-y-2">
              <div className="flex items-center">
                <span className="font-semibold w-24">Gender:</span>
                <span>{actor.gender || "-"}</span>
              </div>
              <div className="flex items-center">
                <span className="font-semibold w-24">Nationality:</span>
                <span>{actor.nationality || "-"}</span>
              </div>
              <div className="flex items-center">
                <span className="font-semibold w-24">Birthdate:</span>
                <span>{actor.dateOfBirth || "-"}</span>
              </div>
              {actor.dateOfBirth && (
                <div className="flex items-center">
                  <span className="font-semibold w-24">Age:</span>
                  <span>{calculateAge(actor.dateOfBirth)} years</span>
                </div>
              )}
              <div className="flex items-center">
                <span className="font-semibold w-24">Popularity:</span>
                <span>{actor.recentPopularity || "-"}</span>
              </div>
            </div>
          </div>
          
          {/* Right column - Details */}
          <div className="md:col-span-2 space-y-4">
            <div>
              <h3 className="text-md font-semibold border-b pb-1">Career Details</h3>
              <div className="grid grid-cols-1 gap-3 mt-2">
                <div>
                  <span className="text-sm font-medium text-muted-foreground">Notable Roles</span>
                  <p className="mt-1">{formatArray(actor.notableRoles)}</p>
                </div>
                <div>
                  <span className="text-sm font-medium text-muted-foreground">Typical Roles</span>
                  <p className="mt-1">{formatArray(actor.typicalRoles)}</p>
                </div>
                <div>
                  <span className="text-sm font-medium text-muted-foreground">Genres</span>
                  <p className="mt-1">{formatArray(actor.genres)}</p>
                </div>
              </div>
            </div>
            
            <div>
              <h3 className="text-md font-semibold border-b pb-1">Production Information</h3>
              <div className="grid grid-cols-1 gap-3 mt-2">
                <div>
                  <span className="text-sm font-medium text-muted-foreground">Estimated Salary Range</span>
                  <p className="mt-1">{actor.estSalaryRange || "-"}</p>
                </div>
                <div>
                  <span className="text-sm font-medium text-muted-foreground">Social Media Following</span>
                  <p className="mt-1">{actor.socialMediaFollowing || "-"}</p>
                </div>
                <div>
                  <span className="text-sm font-medium text-muted-foreground">Availability</span>
                  <p className="mt-1">{actor.availability || "-"}</p>
                </div>
                <div>
                  <span className="text-sm font-medium text-muted-foreground">Best Suited Strategic Roles</span>
                  <p className="mt-1">{actor.bestSuitedRolesStrategic || "-"}</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}


================================================
FILE: client/src/components/actors/EditActorModal.tsx
================================================
import { useState, useEffect } from "react";
import { EditActorModalProps, actorFormSchema } from "@/lib/types";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Loader2 } from "lucide-react";

type FormValues = z.infer<typeof actorFormSchema>;

export default function EditActorModal({ 
  isOpen, 
  actor, 
  onClose, 
  onEdit,
  isSubmitting 
}: EditActorModalProps) {
  const [previewUrl, setPreviewUrl] = useState<string>("");
  
  const form = useForm<FormValues>({
    resolver: zodResolver(actorFormSchema),
    defaultValues: {
      name: "",
      gender: "",
      nationality: "",
      notableRoles: "",
      genres: "",
      recentPopularity: "",
      typicalRoles: "",
      estSalaryRange: "",
      socialMediaFollowing: "",
      availability: "",
      bestSuitedRolesStrategic: "",
      dateOfBirth: "",
      imageUrl: ""
    }
  });

  useEffect(() => {
    if (actor) {
      form.reset({
        name: actor.name,
        gender: actor.gender,
        nationality: actor.nationality,
        notableRoles: Array.isArray(actor.notableRoles) ? actor.notableRoles.join(", ") : actor.notableRoles as unknown as string,
        genres: Array.isArray(actor.genres) ? actor.genres.join(", ") : actor.genres as unknown as string,
        recentPopularity: actor.recentPopularity,
        typicalRoles: Array.isArray(actor.typicalRoles) ? actor.typicalRoles.join(", ") : actor.typicalRoles as unknown as string,
        estSalaryRange: actor.estSalaryRange,
        socialMediaFollowing: actor.socialMediaFollowing,
        availability: actor.availability,
        bestSuitedRolesStrategic: actor.bestSuitedRolesStrategic,
        dateOfBirth: actor.dateOfBirth || "",
        imageUrl: actor.imageUrl || ""
      });
      setPreviewUrl(actor.imageUrl || "");
    }
  }, [actor, form]);

  const handleImagePreview = (url: string) => {
    if (url) setPreviewUrl(url);
  };

  const onSubmit = async (values: FormValues) => {
    if (actor && actor.id) {
      // Convert comma-separated strings back to arrays
      const formattedValues = {
        ...values,
        notableRoles: values.notableRoles.split(",").map(role => role.trim()),
        genres: values.genres.split(",").map(genre => genre.trim()),
        typicalRoles: values.typicalRoles.split(",").map(role => role.trim()),
      };
      
      await onEdit(actor.id, formattedValues as any);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => {
      if (!open) {
        onClose();
        // Don't reset during active submission
        if (!isSubmitting) {
          setPreviewUrl("");
        }
      }
    }}>
      <DialogContent className="sm:max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Edit Actor</DialogTitle>
        </DialogHeader>
        
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="name"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Name</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter actor name" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="gender"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Gender</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter gender" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="dateOfBirth"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Date of Birth</FormLabel>
                    <FormControl>
                      <Input placeholder="YYYY-MM-DD" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="nationality"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Nationality</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter nationality" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="recentPopularity"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Recent Popularity</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter recent popularity status" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="estSalaryRange"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Estimated Salary Range</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter estimated salary range" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="socialMediaFollowing"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Social Media Following</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter social media following" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="availability"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Availability</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter availability" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            <FormField
              control={form.control}
              name="notableRoles"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Notable Roles (comma-separated)</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter notable roles, separated by commas" 
                      {...field} 
                      className="min-h-[80px]"
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="genres"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Genres (comma-separated)</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter genres, separated by commas" 
                      {...field} 
                      className="min-h-[80px]"
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="typicalRoles"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Typical Roles (comma-separated)</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter typical roles, separated by commas" 
                      {...field} 
                      className="min-h-[80px]"
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="bestSuitedRolesStrategic"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Best Suited Roles (Strategic)</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter best suited roles" 
                      {...field} 
                      className="min-h-[80px]"
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="imageUrl"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Image URL</FormLabel>
                  <FormControl>
                    <Input 
                      placeholder="Enter image URL" 
                      {...field} 
                      onChange={(e) => {
                        field.onChange(e);
                        handleImagePreview(e.target.value);
                      }}
                    />
                  </FormControl>
                  <FormMessage />
                  {previewUrl && (
                    <div className="mt-2 w-48 h-64 overflow-hidden border rounded">
                      <img 
                        src={previewUrl} 
                        alt="Preview" 
                        className="w-full h-full object-cover"
                        onError={() => setPreviewUrl("https://placehold.co/400x600/gray/white?text=Invalid+Image+URL")}
                      />
                    </div>
                  )}
                </FormItem>
              )}
            />
            
            <DialogFooter className="pt-4">
              <Button 
                type="button" 
                variant="outline" 
                onClick={onClose}
                disabled={isSubmitting}
              >
                Cancel
              </Button>
              <Button 
                type="submit"
                disabled={isSubmitting}
              >
                {isSubmitting ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Saving...
                  </>
                ) : (
                  'Save Changes'
                )}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}


================================================
FILE: client/src/components/layout/Footer.tsx
================================================
// client/src/components/layout/Footer.tsx
import { Link } from "wouter";

export default function Footer() {
  return (
    // Use the custom --vadis-purple for the background, defined in index.css and tailwind.config.ts
    // Keep text-white as the screenshot footer has white text on purple.
    <footer className="bg-vadis-purple text-white py-6">
      <div className="container mx-auto px-4">
        <div className="flex flex-col md:flex-row justify-between items-center">
          <div className="mb-4 md:mb-0">
            {/* Text color is inherited from 'text-white' on the footer element */}
            <p className="text-sm">
              © {new Date().getFullYear()} Vadis Media AG. All rights reserved.
            </p>
          </div>
          <div className="flex space-x-4">
            {/* Link text color needs to be visible on purple. Default 'text-white' is good.
                Hover state can remain white or be a slightly lighter shade if needed, but text-white is clear.
                The original text-gray-300 was for a dark (secondary) background, not the vadis-purple.
            */}
            <Link
              href="/privacy-policy"
              className="text-sm text-gray-200 hover:text-white transition-colors"
            >
              Privacy Policy
            </Link>
            <Link
              href="/terms-of-service"
              className="text-sm text-gray-200 hover:text-white transition-colors"
            >
              Terms of Service
            </Link>
            <Link
              href="/contact"
              className="text-sm text-gray-200 hover:text-white transition-colors"
            >
              Contact
            </Link>
          </div>
        </div>
      </div>
    </footer>
  );
}



================================================
FILE: client/src/components/layout/Header.tsx
================================================
// client/src/components/layout/Header.tsx
import { Link } from "wouter";
import { Home, FileText, ShoppingBag, Users, MapPin, PenTool } from "lucide-react"; // Added PenTool for Script Writer
import { HeaderProps } from "@/lib/types";
import { cn } from "@/lib/utils";

export default function Header({ activeTab, onTabChange }: HeaderProps) {
  return (
    <header className="bg-secondary text-secondary-foreground shadow-sm border-b border-border sticky top-0 z-50">
      {/* bg-secondary is now white, text-secondary-foreground is dark */}
      <div className="container mx-auto px-2 sm:px-4 py-2 sm:py-3 flex flex-wrap justify-between items-center">
        <div className="flex items-center h-8">
          <Link href="/" className="flex items-center">
            <img
              src="/assets/vadis-media-logo-dark.png"
              alt="Vadis Media Logo"
              className="h-6 sm:h-7 w-auto object-contain" // Responsive logo size
            />
          </Link>
          <span className="text-primary ml-2 text-[11px] sm:text-sm font-medium flex items-center h-full">Demo</span>
        </div>
        <nav className="overflow-x-auto py-1 w-full sm:w-auto mt-1 sm:mt-0">
          <ul className="flex gap-1 sm:gap-2 md:gap-3 min-w-max pr-2">
            {/* Improved spacing for mobile */}
            <li>
              <button
                onClick={() => onTabChange("welcome")}
                className={cn(
                  "hover:text-primary transition-colors duration-200 font-medium flex items-center text-[11px] sm:text-xs md:text-sm px-1.5 sm:px-2 py-1 rounded-md whitespace-nowrap", // Better mobile sizing
                  activeTab === "welcome"
                    ? "text-primary bg-primary/10"
                    : "text-vadis-dark-text hover:bg-muted", // Adjusted active and hover states
                )}
              >
                <Home className="mr-1 h-3 w-3 sm:h-3.5 sm:w-3.5 flex-shrink-0" />
                <span className="inline-block leading-tight">Welcome</span>
              </button>
            </li>
            {/* Swapped Order: Script Writer now comes before Script Analysis */}
            <li>
              <button
                onClick={() => onTabChange("script-writer")}
                className={cn(
                  "hover:text-primary transition-colors duration-200 font-medium flex items-center text-[11px] sm:text-xs md:text-sm px-1.5 sm:px-2 py-1 rounded-md whitespace-nowrap",
                  activeTab === "script-writer"
                    ? "text-primary bg-primary/10"
                    : "text-vadis-dark-text hover:bg-muted",
                )}
              >
                <PenTool className="mr-1 h-3 w-3 sm:h-3.5 sm:w-3.5 flex-shrink-0" /> {/* Icon for Script Writer */}
                <span className="inline-block leading-tight">Script Writer</span>
              </button>
            </li>
            <li>
              <button
                onClick={() => onTabChange("script")}
                className={cn(
                  "hover:text-primary transition-colors duration-200 font-medium flex items-center text-[11px] sm:text-xs md:text-sm px-1.5 sm:px-2 py-1 rounded-md whitespace-nowrap",
                  activeTab === "script"
                    ? "text-primary bg-primary/10"
                    : "text-vadis-dark-text hover:bg-muted",
                )}
              >
                <FileText className="mr-1 h-3 w-3 sm:h-3.5 sm:w-3.5 flex-shrink-0" />
                <span className="inline-block leading-tight">Script Analysis</span>
              </button>
            </li>
            <li>
              <button
                onClick={() => onTabChange("products")}
                className={cn(
                  "hover:text-primary transition-colors duration-200 font-medium flex items-center text-[11px] sm:text-xs md:text-sm px-1.5 sm:px-2 py-1 rounded-md whitespace-nowrap",
                  activeTab === "products"
                    ? "text-primary bg-primary/10"
                    : "text-vadis-dark-text hover:bg-muted",
                )}
              >
                <ShoppingBag className="mr-1 h-3 w-3 sm:h-3.5 sm:w-3.5 flex-shrink-0" />
                <span className="inline-block leading-tight">Brands</span>
              </button>
            </li>
            <li>
              <button
                onClick={() => onTabChange("actors")}
                className={cn(
                  "hover:text-primary transition-colors duration-200 font-medium flex items-center text-[11px] sm:text-xs md:text-sm px-1.5 sm:px-2 py-1 rounded-md whitespace-nowrap",
                  activeTab === "actors"
                    ? "text-primary bg-primary/10"
                    : "text-vadis-dark-text hover:bg-muted",
                )}
              >
                <Users className="mr-1 h-3 w-3 sm:h-3.5 sm:w-3.5 flex-shrink-0" />
                <span className="inline-block leading-tight">Actors</span>
              </button>
            </li>
            <li>
              <button
                onClick={() => onTabChange("locations")}
                className={cn(
                  "hover:text-primary transition-colors duration-200 font-medium flex items-center text-[11px] sm:text-xs md:text-sm px-1.5 sm:px-2 py-1 rounded-md whitespace-nowrap",
                  activeTab === "locations"
                    ? "text-primary bg-primary/10"
                    : "text-vadis-dark-text hover:bg-muted",
                )}
              >
                <MapPin className="mr-1 h-3 w-3 sm:h-3.5 sm:w-3.5 flex-shrink-0" />
                <span className="inline-block leading-tight">Locations</span>
              </button>
            </li>
          </ul>
        </nav>
      </div>
    </header>
  );
}


================================================
FILE: client/src/components/locations/AddLocationModal.tsx
================================================
import { useState } from "react";
import { AddLocationModalProps, locationFormSchema } from "@/lib/types";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Loader2 } from "lucide-react";

type FormValues = z.infer<typeof locationFormSchema>;

export default function AddLocationModal({ isOpen, onClose, onAdd, isSubmitting }: AddLocationModalProps) {
  const [previewUrl, setPreviewUrl] = useState<string>("");
  
  const form = useForm<FormValues>({
    resolver: zodResolver(locationFormSchema),
    defaultValues: {
      country: "",
      region: "",
      incentiveProgram: "",
      incentiveDetails: "",
      minimumSpend: "",
      eligibleProductionTypes: "",
      limitsCaps: "",
      qualifyingExpenses: "",
      applicationProcess: "",
      applicationDeadlines: "",
      imageUrl: ""
    }
  });

  const handleImagePreview = (url: string) => {
    if (url) setPreviewUrl(url);
  };

  const onSubmit = async (values: FormValues) => {
    await onAdd(values);
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => {
      if (!open) {
        onClose();
        // Don't reset during active submission
        if (!isSubmitting) {
          form.reset();
          setPreviewUrl("");
        }
      }
    }}>
      <DialogContent className="sm:max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Add New Location</DialogTitle>
        </DialogHeader>
        
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="country"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Country</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter country name" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="region"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Region</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter region or state" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="incentiveProgram"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Incentive Program</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter incentive program name" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="minimumSpend"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Minimum Spend</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter minimum spend requirement" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="eligibleProductionTypes"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Eligible Production Types</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter eligible production types" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="applicationDeadlines"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Application Deadlines</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter application deadlines" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            <FormField
              control={form.control}
              name="incentiveDetails"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Incentive Details</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter incentive details" 
                      {...field} 
                      className="min-h-[80px]"
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="limitsCaps"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Limits & Caps</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter limits and caps information" 
                      {...field} 
                      className="min-h-[80px]"
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="qualifyingExpenses"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Qualifying Expenses</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter qualifying expenses information" 
                      {...field} 
                      className="min-h-[80px]"
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="applicationProcess"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Application Process</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter application process details" 
                      {...field} 
                      className="min-h-[80px]"
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="imageUrl"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Image URL</FormLabel>
                  <FormControl>
                    <Input 
                      placeholder="Enter image URL" 
                      {...field} 
                      onChange={(e) => {
                        field.onChange(e);
                        handleImagePreview(e.target.value);
                      }}
                    />
                  </FormControl>
                  <FormMessage />
                  {previewUrl && (
                    <div className="mt-2 w-48 h-32 overflow-hidden border rounded">
                      <img 
                        src={previewUrl} 
                        alt="Preview" 
                        className="w-full h-full object-cover"
                        onError={() => setPreviewUrl("https://placehold.co/400x300/gray/white?text=Invalid+Image+URL")}
                      />
                    </div>
                  )}
                </FormItem>
              )}
            />
            
            <DialogFooter className="pt-4">
              <Button 
                type="button" 
                variant="outline" 
                onClick={onClose}
                disabled={isSubmitting}
              >
                Cancel
              </Button>
              <Button 
                type="submit"
                disabled={isSubmitting}
              >
                {isSubmitting ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Adding...
                  </>
                ) : (
                  'Add Location'
                )}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}


================================================
FILE: client/src/components/locations/DeleteLocationDialog.tsx
================================================
import { DeleteLocationDialogProps } from "@/lib/types";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Loader2 } from "lucide-react";

export default function DeleteLocationDialog({
  isOpen,
  location,
  onClose,
  onDelete,
  isDeleting,
}: DeleteLocationDialogProps) {
  const handleDelete = async () => {
    if (location && location.id) {
      await onDelete(location.id);
    }
  };

  return (
    <AlertDialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
          <AlertDialogDescription>
            This action cannot be undone. This will permanently delete the
            location "{location?.country}: {location?.region}" and remove it from our
            database.
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={(e) => {
              e.preventDefault();
              handleDelete();
            }}
            className="bg-red-600 hover:bg-red-700"
            disabled={isDeleting}
          >
            {isDeleting ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Deleting...
              </>
            ) : (
              "Delete"
            )}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}


================================================
FILE: client/src/components/locations/EditLocationModal.tsx
================================================
import { useState, useEffect } from "react";
import { EditLocationModalProps, locationFormSchema } from "@/lib/types";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Loader2 } from "lucide-react";

type FormValues = z.infer<typeof locationFormSchema>;

export default function EditLocationModal({ 
  isOpen, 
  location, 
  onClose, 
  onEdit,
  isSubmitting 
}: EditLocationModalProps) {
  const [previewUrl, setPreviewUrl] = useState<string>("");
  
  const form = useForm<FormValues>({
    resolver: zodResolver(locationFormSchema),
    defaultValues: {
      country: "",
      region: "",
      incentiveProgram: "",
      incentiveDetails: "",
      minimumSpend: "",
      eligibleProductionTypes: "",
      limitsCaps: "",
      qualifyingExpenses: "",
      applicationProcess: "",
      applicationDeadlines: "",
      imageUrl: ""
    }
  });

  useEffect(() => {
    if (location) {
      form.reset({
        country: location.country,
        region: location.region,
        incentiveProgram: location.incentiveProgram,
        incentiveDetails: location.incentiveDetails,
        minimumSpend: location.minimumSpend,
        eligibleProductionTypes: location.eligibleProductionTypes,
        limitsCaps: location.limitsCaps || "",
        qualifyingExpenses: location.qualifyingExpenses || "",
        applicationProcess: location.applicationProcess || "",
        applicationDeadlines: location.applicationDeadlines || "",
        imageUrl: location.imageUrl || ""
      });
      setPreviewUrl(location.imageUrl || "");
    }
  }, [location, form]);

  const handleImagePreview = (url: string) => {
    if (url) setPreviewUrl(url);
  };

  const onSubmit = async (values: FormValues) => {
    if (location && location.id) {
      await onEdit(location.id, values);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => {
      if (!open) {
        onClose();
        // Don't reset during active submission
        if (!isSubmitting) {
          setPreviewUrl("");
        }
      }
    }}>
      <DialogContent className="sm:max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Edit Location</DialogTitle>
        </DialogHeader>
        
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="country"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Country</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter country name" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="region"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Region</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter region or state" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="incentiveProgram"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Incentive Program</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter incentive program name" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="minimumSpend"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Minimum Spend</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter minimum spend requirement" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="eligibleProductionTypes"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Eligible Production Types</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter eligible production types" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="applicationDeadlines"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Application Deadlines</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter application deadlines" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            <FormField
              control={form.control}
              name="incentiveDetails"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Incentive Details</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter incentive details" 
                      {...field} 
                      className="min-h-[80px]"
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="limitsCaps"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Limits & Caps</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter limits and caps information" 
                      {...field} 
                      className="min-h-[80px]"
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="qualifyingExpenses"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Qualifying Expenses</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter qualifying expenses information" 
                      {...field} 
                      className="min-h-[80px]"
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="applicationProcess"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Application Process</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter application process details" 
                      {...field} 
                      className="min-h-[80px]"
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="imageUrl"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Image URL</FormLabel>
                  <FormControl>
                    <Input 
                      placeholder="Enter image URL" 
                      {...field} 
                      onChange={(e) => {
                        field.onChange(e);
                        handleImagePreview(e.target.value);
                      }}
                    />
                  </FormControl>
                  <FormMessage />
                  {previewUrl && (
                    <div className="mt-2 w-48 h-32 overflow-hidden border rounded">
                      <img 
                        src={previewUrl} 
                        alt="Preview" 
                        className="w-full h-full object-cover"
                        onError={() => setPreviewUrl("https://placehold.co/400x300/gray/white?text=Invalid+Image+URL")}
                      />
                    </div>
                  )}
                </FormItem>
              )}
            />
            
            <DialogFooter className="pt-4">
              <Button 
                type="button" 
                variant="outline" 
                onClick={onClose}
                disabled={isSubmitting}
              >
                Cancel
              </Button>
              <Button 
                type="submit"
                disabled={isSubmitting}
              >
                {isSubmitting ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Saving...
                  </>
                ) : (
                  'Save Changes'
                )}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}


================================================
FILE: client/src/components/products/AddProductModal.tsx
================================================
import { useState } from "react";
import { AddProductModalProps, productFormSchema } from "@/lib/types";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Upload, Loader2 } from "lucide-react";
import { Label } from "@/components/ui/label";
import { Checkbox } from "@/components/ui/checkbox";
import {
  FilmRatingEnum,
  DemographicGenderEnum,
  DemographicAgeEnum,
  GenreEnum,
  FilmRatingType,
  DemographicGenderType,
  DemographicAgeType,
  GenreType,
  ProductCategory,
} from "@shared/schema";
import { Textarea } from "@/components/ui/textarea";

type FormValues = z.infer<typeof productFormSchema>;

export default function AddProductModal({
  isOpen,
  onClose,
  onAdd,
  isSubmitting,
}: AddProductModalProps) {
  const [previewUrl, setPreviewUrl] = useState<string>("");

  const form = useForm<FormValues>({
    resolver: zodResolver(productFormSchema),
    defaultValues: {
      companyName: "",
      name: "",
      category: "BEVERAGE" as ProductCategory, // Ensure type assertion
      imageUrl: "",
      filmRating: null,
      demographicGender: null,
      demographicAge: [],
      genre: null,
      placementLimitations: "",
    },
  });

  const handleImagePreview = (url: string) => {
    if (url) setPreviewUrl(url);
  };

  const onSubmit = async (values: FormValues) => {
    await onAdd(values);
    form.reset();
    setPreviewUrl("");
  };

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => {
        if (!open) {
          onClose();
          if (!isSubmitting) {
            form.reset();
            setPreviewUrl("");
          }
        }
      }}
    >
      <DialogContent className="sm:max-w-md max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Add New Product</DialogTitle>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="companyName"
              render={({ field }) => (
                <FormItem>
                  {/* CHANGED LABEL HERE */}
                  <FormLabel>Brand Name</FormLabel>
                  <FormControl>
                    <Input placeholder="Enter brand name" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Product Name</FormLabel>
                  <FormControl>
                    <Input placeholder="Enter product name" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="category"
              render={({ field }) => (
                <FormItem>
                  {/* CHANGED LABEL HERE */}
                  <FormLabel>Product Category</FormLabel>
                  <Select
                    onValueChange={field.onChange}
                    defaultValue={field.value}
                  >
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select a category" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="BEVERAGE">Beverage</SelectItem>
                      <SelectItem value="ELECTRONICS">Electronics</SelectItem>
                      <SelectItem value="FOOD">Food</SelectItem>
                      <SelectItem value="AUTOMOTIVE">Automotive</SelectItem>
                      <SelectItem value="FASHION">Fashion</SelectItem>
                      <SelectItem value="WATCH">Watch</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="filmRating"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Film Rating</FormLabel>
                  <Select
                    onValueChange={field.onChange}
                    defaultValue={field.value || undefined}
                  >
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select film rating" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      {Object.entries(FilmRatingEnum).map(([key, value]) => (
                        <SelectItem key={key} value={key}>
                          {value}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="demographicGender"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Gender</FormLabel>
                  <Select
                    onValueChange={field.onChange}
                    defaultValue={field.value || undefined}
                  >
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select target gender" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      {Object.entries(DemographicGenderEnum).map(
                        ([key, value]) => (
                          <SelectItem key={key} value={key}>
                            {value}
                          </SelectItem>
                        ),
                      )}
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="demographicAge"
              render={() => (
                <FormItem>
                  <div className="mb-2">
                    <FormLabel>Age</FormLabel>
                  </div>
                  <div className="grid grid-cols-2 gap-2">
                    {Object.entries(DemographicAgeEnum).map(([key, value]) => (
                      <FormField
                        key={key}
                        control={form.control}
                        name="demographicAge"
                        render={({ field }) => (
                          <FormItem className="flex flex-row items-start space-x-3 space-y-0">
                            <FormControl>
                              <Checkbox
                                checked={field.value?.includes(
                                  key as DemographicAgeType,
                                )}
                                onCheckedChange={(checked) => {
                                  return checked
                                    ? field.onChange([
                                        ...(field.value || []),
                                        key as DemographicAgeType,
                                      ])
                                    : field.onChange(
                                        (field.value || []).filter(
                                          (v: DemographicAgeType) => v !== key,
                                        ),
                                      );
                                }}
                              />
                            </FormControl>
                            <FormLabel className="text-sm font-normal">
                              {key === "AllAges" ? "All Ages" : value}
                            </FormLabel>
                          </FormItem>
                        )}
                      />
                    ))}
                  </div>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="genre"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Genre</FormLabel>
                  <Select
                    onValueChange={field.onChange}
                    defaultValue={field.value || undefined}
                  >
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select genre" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      {Object.entries(GenreEnum).map(([key, value]) => (
                        <SelectItem key={key} value={key}>
                          {value}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="imageUrl"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Product Image URL</FormLabel>
                  <FormControl>
                    <div className="flex space-x-2">
                      <Input
                        placeholder="Enter image URL"
                        {...field}
                        onChange={(e) => {
                          field.onChange(e);
                          handleImagePreview(e.target.value);
                        }}
                      />
                    </div>
                  </FormControl>
                  <FormMessage />

                  {previewUrl && (
                    <div className="mt-2 border rounded-md overflow-hidden h-32 bg-gray-50 flex items-center justify-center">
                      <img
                        src={previewUrl}
                        alt="Preview"
                        className="max-h-full max-w-full object-contain"
                        onError={() => setPreviewUrl("")}
                      />
                    </div>
                  )}

                  {!previewUrl && (
                    <div className="mt-2 border-2 border-dashed border-gray-300 rounded-md h-32 flex flex-col items-center justify-center bg-gray-50">
                      <Upload className="h-8 w-8 text-gray-400 mb-1" />
                      <p className="text-xs text-gray-500">
                        Enter URL to preview
                      </p>
                    </div>
                  )}
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="placementLimitations"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Placement Limitations / Criteria</FormLabel>
                  <FormControl>
                    <Textarea
                      placeholder="e.g., Product must not appear in violent scenes. Only show with characters aged 25+."
                      {...field}
                      rows={3}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <DialogFooter className="sm:justify-end">
              <Button
                type="button"
                variant="outline"
                onClick={onClose}
                disabled={isSubmitting}
              >
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Adding...
                  </>
                ) : (
                  "Add Product"
                )}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}



================================================
FILE: client/src/components/products/DeleteProductDialog.tsx
================================================
import { DeleteProductDialogProps } from "@/lib/types";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Loader2 } from "lucide-react";

export default function DeleteProductDialog({ 
  isOpen, 
  product, 
  onClose, 
  onDelete,
  isDeleting 
}: DeleteProductDialogProps) {
  const handleDelete = async () => {
    if (product) {
      await onDelete(product.id);
    }
  };

  return (
    <AlertDialog open={isOpen} onOpenChange={(open) => {
      if (!open && !isDeleting) onClose();
    }}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Are you sure?</AlertDialogTitle>
          <AlertDialogDescription>
            This will permanently delete the product{" "}
            <span className="font-medium text-foreground">
              {product?.name}
            </span>
            . This action cannot be undone.
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
          <AlertDialogAction
            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            onClick={(e) => {
              e.preventDefault();
              handleDelete();
            }}
            disabled={isDeleting}
          >
            {isDeleting ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Deleting...
              </>
            ) : (
              'Delete'
            )}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}



================================================
FILE: client/src/components/products/EditProductModal.tsx
================================================
import { useState, useEffect } from "react";
import { EditProductModalProps, productFormSchema } from "@/lib/types";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Upload, Loader2 } from "lucide-react";
import { Label } from "@/components/ui/label";
import { Checkbox } from "@/components/ui/checkbox";
import {
  FilmRatingEnum,
  DemographicGenderEnum,
  DemographicAgeEnum,
  GenreEnum,
  FilmRatingType,
  DemographicGenderType,
  DemographicAgeType,
  GenreType,
  ProductCategory,
} from "@shared/schema";
import { Textarea } from "@/components/ui/textarea";

type FormValues = z.infer<typeof productFormSchema>;

export default function EditProductModal({
  isOpen,
  product,
  onClose,
  onEdit,
  isSubmitting,
}: EditProductModalProps) {
  const [previewUrl, setPreviewUrl] = useState<string>("");

  const form = useForm<FormValues>({
    resolver: zodResolver(productFormSchema),
    defaultValues: {
      companyName: "",
      name: "",
      category: "BEVERAGE" as ProductCategory, // Ensure type assertion
      imageUrl: "",
      filmRating: null,
      demographicGender: null,
      demographicAge: [], // Initialize as empty array
      genre: null,
      placementLimitations: "",
    },
  });

  useEffect(() => {
    if (product) {
      form.reset({
        companyName: product.companyName || "",
        name: product.name,
        category: product.category,
        filmRating: product.filmRating || null,
        demographicGender: product.demographicGender || null,
        demographicAge: product.demographicAge || [], // Ensure it's an array, default to [] if null
        genre: product.genre || null,
        imageUrl: product.imageUrl || "",
        placementLimitations: product.placementLimitations || "",
      });
      setPreviewUrl(product.imageUrl || "");
    }
  }, [product, form]);

  const handleImagePreview = (url: string) => {
    if (url) setPreviewUrl(url);
  };

  const onSubmit = async (values: FormValues) => {
    if (product) {
      await onEdit(product.id, values);
    }
  };

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => {
        if (!open) {
          onClose();
          if (!isSubmitting) {
            setPreviewUrl("");
            // form.reset(); // Consider if full reset is needed here or handled by useEffect
          }
        }
      }}
    >
      <DialogContent className="sm:max-w-md max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Edit Product</DialogTitle>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="companyName"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Brand Name</FormLabel>
                  <FormControl>
                    <Input placeholder="Enter brand name" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Product Name</FormLabel>
                  <FormControl>
                    <Input placeholder="Enter product name" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="category"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Product Category</FormLabel>
                  <Select onValueChange={field.onChange} value={field.value}>
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select a category" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="BEVERAGE">Beverage</SelectItem>
                      <SelectItem value="ELECTRONICS">Electronics</SelectItem>
                      <SelectItem value="FOOD">Food</SelectItem>
                      <SelectItem value="AUTOMOTIVE">Automotive</SelectItem>
                      <SelectItem value="FASHION">Fashion</SelectItem>
                      <SelectItem value="WATCH">Watch</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="filmRating"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Audience Targeting: Film Rating</FormLabel>
                  <Select
                    onValueChange={field.onChange}
                    value={field.value || undefined}
                  >
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select film rating" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      {Object.entries(FilmRatingEnum).map(([key, value]) => (
                        <SelectItem key={key} value={key}>
                          {value}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="demographicGender"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Demographic Gender</FormLabel>
                  <Select
                    onValueChange={field.onChange}
                    value={field.value || undefined}
                  >
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select target gender" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      {Object.entries(DemographicGenderEnum).map(
                        ([key, value]) => (
                          <SelectItem key={key} value={key}>
                            {value}
                          </SelectItem>
                        ),
                      )}
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="demographicAge"
              render={() => (
                <FormItem>
                  <div className="mb-2">
                    <FormLabel>Demographic Age Ranges</FormLabel>
                  </div>
                  <div className="grid grid-cols-2 gap-2">
                    {Object.entries(DemographicAgeEnum).map(([key, value]) => (
                      <FormField
                        key={key}
                        control={form.control}
                        name="demographicAge"
                        render={({ field }) => {
                          // Ensure field.value is an array
                          const fieldValueArray = Array.isArray(field.value)
                            ? field.value
                            : [];
                          return (
                            <FormItem className="flex flex-row items-start space-x-3 space-y-0">
                              <FormControl>
                                <Checkbox
                                  checked={fieldValueArray.includes(
                                    key as DemographicAgeType,
                                  )}
                                  onCheckedChange={(checked) => {
                                    const currentAges = Array.isArray(
                                      field.value,
                                    )
                                      ? field.value
                                      : [];
                                    return checked
                                      ? field.onChange([
                                          ...currentAges,
                                          key as DemographicAgeType,
                                        ])
                                      : field.onChange(
                                          currentAges.filter(
                                            (v: DemographicAgeType) =>
                                              v !== key,
                                          ),
                                        );
                                  }}
                                />
                              </FormControl>
                              <FormLabel className="text-sm font-normal">
                                {key === "AllAges" ? "All Ages" : value}
                              </FormLabel>
                            </FormItem>
                          );
                        }}
                      />
                    ))}
                  </div>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="genre"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Genre</FormLabel>
                  <Select
                    onValueChange={field.onChange}
                    value={field.value || undefined}
                  >
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select genre" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      {Object.entries(GenreEnum).map(([key, value]) => (
                        <SelectItem key={key} value={key}>
                          {value}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="imageUrl"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Product Image URL</FormLabel>
                  <FormControl>
                    <div className="flex space-x-2">
                      <Input
                        placeholder="Enter image URL"
                        {...field}
                        onChange={(e) => {
                          field.onChange(e);
                          handleImagePreview(e.target.value);
                        }}
                      />
                    </div>
                  </FormControl>
                  <FormMessage />

                  {previewUrl && (
                    <div className="mt-2 border rounded-md overflow-hidden h-32 bg-gray-50 flex items-center justify-center">
                      <img
                        src={previewUrl}
                        alt="Preview"
                        className="max-h-full max-w-full object-contain"
                        onError={() => setPreviewUrl("")}
                      />
                    </div>
                  )}

                  {!previewUrl && (
                    <div className="mt-2 border-2 border-dashed border-gray-300 rounded-md h-32 flex flex-col items-center justify-center bg-gray-50">
                      <Upload className="h-8 w-8 text-gray-400 mb-1" />
                      <p className="text-xs text-gray-500">
                        Enter URL to preview
                      </p>
                    </div>
                  )}
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="placementLimitations"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Placement Limitations / Criteria</FormLabel>
                  <FormControl>
                    <Textarea
                      placeholder="e.g., Product must not appear in violent scenes. Only show with characters aged 25+."
                      {...field}
                      rows={3}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <DialogFooter className="sm:justify-end">
              <Button
                type="button"
                variant="outline"
                onClick={onClose}
                disabled={isSubmitting}
              >
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Saving...
                  </>
                ) : (
                  "Save Changes"
                )}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}



================================================
FILE: client/src/components/products/ProductCard.tsx
================================================
import { ProductCardProps } from "@/lib/types";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardFooter } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Edit, Trash2 } from "lucide-react";

export default function ProductCard({ product, onEdit, onDelete }: ProductCardProps) {
  return (
    <Card className="border border-gray-200 rounded-lg overflow-hidden bg-white shadow-sm hover:shadow-md transition-shadow duration-200">
      <div className="h-40 overflow-hidden bg-gray-100">
        <img 
          src={product.imageUrl} 
          alt={`${product.name} product`} 
          className="w-full h-full object-cover" 
          onError={(e) => {
            (e.target as HTMLImageElement).src = "https://placehold.co/300x160?text=No+Image";
          }}
        />
      </div>
      <CardContent className="p-4">
        <div className="flex justify-between items-start">
          <div>
            <p className="text-xs text-gray-500 mb-1">{product.companyName || "Unknown Company"}</p>
            <h3 className="font-medium line-clamp-1">{product.name}</h3>
          </div>
          <Badge variant="secondary" className="ml-2 shrink-0">
            {product.category}
          </Badge>
        </div>
      </CardContent>
      <CardFooter className="p-4 pt-0 flex justify-end space-x-2">
        <Button 
          variant="outline" 
          size="sm"
          onClick={() => onEdit(product)}
        >
          <Edit className="h-3.5 w-3.5 mr-1" />
          Edit
        </Button>
        <Button 
          variant="destructive" 
          size="sm"
          onClick={() => onDelete(product)}
        >
          <Trash2 className="h-3.5 w-3.5 mr-1" />
          Delete
        </Button>
      </CardFooter>
    </Card>
  );
}



================================================
FILE: client/src/components/script/ActorSuggestionCard.tsx
================================================
// client/src/components/script/ActorSuggestionCard.tsx
import { useState } from "react";
import { ActorSuggestionCardProps, ActorSuggestion } from "@/lib/types";
import { Card } from "@/components/ui/card"; // Only Card is needed, CardContent was not used directly
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { CheckCircle, AlertCircle, ShieldAlert, AlertOctagon, User, Info } from "lucide-react"; // Added more icons
import ActorDetailsDialog from "../actors/ActorDetailsDialog";

// Helper to get color and icon based on controversy level
const getControversyIndicator = (level?: ActorSuggestion['controversyLevel']) => {
    switch (level) {
        case 'none':
            return { color: "bg-green-500", icon: <CheckCircle className="h-3 w-3 text-white" />, label: "No notable controversy" };
        case 'low':
            return { color: "bg-yellow-400", icon: <AlertCircle className="h-3 w-3 text-black" />, label: "Low controversy risk" };
        case 'medium':
            return { color: "bg-orange-500", icon: <ShieldAlert className="h-3 w-3 text-white" />, label: "Medium controversy risk" };
        case 'high':
            return { color: "bg-red-600", icon: <AlertOctagon className="h-3 w-3 text-white" />, label: "High controversy risk" };
        default: // Undefined or unknown
            return { color: "bg-gray-400", icon: <User className="h-3 w-3 text-white" />, label: "Controversy level unknown" };
    }
};

export default function ActorSuggestionCard({ 
  actor, 
  onSelect,
  isSelected = false,
  characterName
}: ActorSuggestionCardProps) {
  const [showDetails, setShowDetails] = useState(false);
  const controversyInfo = getControversyIndicator(actor.controversyLevel);

  const handleSelectClick = () => {
    if (onSelect && characterName) {
      onSelect({
        name: characterName,
        estimatedAgeRange: undefined, // We don't have this info from the actor
        actorId: actor.id, // Pass the actor ID for tracking selections
        actorName: actor.name // Include the actor name for display
      });
    }
  };

  const handleViewDetails = (e: React.MouseEvent) => {
    e.stopPropagation(); // Prevent triggering card click
    setShowDetails(true);
  };

  return (
    <>
      <Card 
        className={`flex items-center p-3 space-x-3 shadow-sm hover:shadow-md transition-shadow w-full ${isSelected ? 'border-green-500 bg-green-50' : ''}`}
        onClick={onSelect && characterName ? handleSelectClick : undefined}
        style={{ cursor: onSelect && characterName ? 'pointer' : 'default' }}
      >
        <Avatar className="h-16 w-16 rounded-md">
          <AvatarImage
              src={actor.imageUrl || undefined}
              alt={actor.name}
              className="object-cover w-full h-full"
          />
          <AvatarFallback className="rounded-md">
            {actor.name.substring(0, 2).toUpperCase()}
          </AvatarFallback>
        </Avatar>
        <div className="flex-1 min-w-0">
          <div className="flex justify-between items-start space-x-2">
              <h4 className="font-semibold text-sm truncate" title={actor.name}>{actor.name}</h4>
              <div className="flex items-center space-x-1.5">
                {isSelected && (
                  <Badge variant="outline" className="bg-green-100 text-green-800 border-green-300">
                    <CheckCircle className="h-5 w-5 mr-1" /> Selected
                  </Badge>
                )}
                <TooltipProvider delayDuration={100}>
                    <Tooltip>
                        <TooltipTrigger asChild>
                            <div
                                className={`flex items-center justify-center h-5 w-5 rounded-full ${controversyInfo.color} flex-shrink-0`}
                                aria-label={controversyInfo.label}
                            >
                                {controversyInfo.icon}
                            </div>
                        </TooltipTrigger>
                        <TooltipContent side="top" className="text-xs">
                            <p>{controversyInfo.label}</p>
                        </TooltipContent>
                    </Tooltip>
                </TooltipProvider>
              </div>
          </div>
          <p className="text-xs text-muted-foreground truncate">
            {actor.gender}, {actor.nationality}
          </p>
          {actor.matchReason && (
            <p className="text-xs mt-1 italic text-primary/80 line-clamp-2" title={actor.matchReason}>
              Match: {actor.matchReason}
            </p>
          )}
          <div className="mt-2">
            <Button 
              variant="ghost" 
              size="sm" 
              className="h-7 px-2 text-xs" 
              onClick={handleViewDetails}
            >
              <Info className="h-3.5 w-3.5 mr-1" />
              View Details
            </Button>
          </div>
        </div>
      </Card>

      {/* Actor Details Dialog */}
      <ActorDetailsDialog 
        isOpen={showDetails}
        actor={actor}
        onClose={() => setShowDetails(false)}
      />
    </>
  );
}


================================================
FILE: client/src/components/script/BrandableScenes.tsx
================================================
// client/src/components/script/BrandableScenes.tsx
import { BrandableScenesProps, SceneVariation } from "@/lib/types";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardFooter } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { Badge } from "@/components/ui/badge";
import { getSafeImageUrl } from "@/lib/utils";
import {
  ImageOff,
  Info,
  Loader2,
  Video,
  PlayCircle,
  AlertTriangle,
  RefreshCcw,
  Replace,
  ZoomIn,
  Check,
  Sparkles,
  ShoppingBag,
} from "lucide-react";
import { Progress } from "@/components/ui/progress";
import { Scene } from "@shared/schema";
import { Textarea } from "@/components/ui/textarea";
import { useState, useEffect } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import ChangeProductModal from "./ChangeProductModal";

const FALLBACK_IMAGE_URL =
  "https://placehold.co/600x400/gray/white?text=Image+Unavailable";

export default function BrandableScenes({
  activeSceneDetails,
  projectTitle,
  scenes,
  productVariations,
  isLoading,
  selectedSceneId,
  onGenerateVideoRequest, // This prop is called directly now
  videoGenerationStates,
  onViewVideo,
  onImageZoom,
  selectedProducts = [],
  onProductSelect,
}: BrandableScenesProps) {
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const [editedPrompts, setEditedPrompts] = useState<{
    [variationId: number]: string;
  }>({});
  const [isChangeProductModalOpen, setIsChangeProductModalOpen] =
    useState(false);
  const [changingProductForVariationId, setChangingProductForVariationId] =
    useState<number | null>(null);
  const [currentMode, setCurrentMode] = useState<'brand' | 'vfx'>('brand');

  useEffect(() => {
    const initialPrompts: { [variationId: number]: string } = {};
    if (productVariations && selectedSceneId) {
      productVariations
        .filter((v) => v.sceneId === selectedSceneId)
        .forEach((v) => {
          initialPrompts[v.id] = v.geminiPrompt || "";
        });
    }
    setEditedPrompts(initialPrompts);
  }, [productVariations, selectedSceneId]);

  const currentSceneToDisplay = activeSceneDetails;
  
  // Function to check if a product is selected
  const isProductSelected = (variation: SceneVariation) => {
    return selectedProducts.some(selected => selected.id === variation.id);
  };
  
  // Handle product selection
  const handleProductSelect = (variation: SceneVariation) => {
    if (onProductSelect) {
      onProductSelect(variation);
    }
  };

  const currentSceneVariations = productVariations
    .filter((variation) => variation.sceneId === selectedSceneId)
    .map((variation) => ({
      ...variation,
      imageUrl: getSafeImageUrl(
        variation.imageUrl,
        "https://placehold.co/864x480/333/white?text=Processing...",
      ),
      productImageUrl: getSafeImageUrl(variation.productImageUrl || ""),
    }));

  const handlePromptChange = (variationId: number, newPrompt: string) => {
    setEditedPrompts((prev) => ({ ...prev, [variationId]: newPrompt }));
  };

  const updateAssetsMutation = useMutation({
    mutationFn: async ({
      variationId,
      newPrompt,
    }: {
      variationId: number;
      newPrompt: string;
    }) => {
      return apiRequest(
        "PUT",
        `/api/variations/${variationId}/update-prompt-and-image`,
        { newPrompt },
      );
    },
    onSuccess: (updatedVariationData: any, variables) => {
      toast({
        title: "Image Updated",
        description: `Image for variation ${variables.variationId} has been updated. Starting video generation...`,
      });
      queryClient.invalidateQueries({
        queryKey: ["/api/scripts/scene-variations", selectedSceneId],
      });
      onGenerateVideoRequest(variables.variationId); // Call the prop from ScriptEditor
    },
    onError: (error: Error, variables) => {
      toast({
        variant: "destructive",
        title: "Asset Update Failed",
        description: `Could not update image for variation ${variables.variationId}: ${error.message}`,
      });
    },
  });

  const handleChangeProductMutation = useMutation({
    mutationFn: async ({
      variationId,
      newProductId,
    }: {
      variationId: number;
      newProductId: number;
    }) => {
      return apiRequest(
        "PUT",
        `/api/variations/${variationId}/change-product`,
        { newProductId },
      );
    },
    onSuccess: (data, variables) => {
      toast({
        title: "Product Changed",
        description: `Product for variation ${variables.variationId} has been updated. Image & video will regenerate.`,
      });
      setIsChangeProductModalOpen(false);
      setChangingProductForVariationId(null);
      queryClient.invalidateQueries({
        queryKey: ["/api/scripts/scene-variations", selectedSceneId],
      });
      onGenerateVideoRequest(variables.variationId); // Call the prop from ScriptEditor
    },
    onError: (error: Error, variables) => {
      toast({
        variant: "destructive",
        title: "Product Change Failed",
        description: `Could not change product for variation ${variables.variationId}: ${error.message}`,
      });
      setIsChangeProductModalOpen(false);
      setChangingProductForVariationId(null);
    },
  });

  const handleUpdateAssets = (variationId: number) => {
    const newPrompt = editedPrompts[variationId];
    if (newPrompt) {
      updateAssetsMutation.mutate({ variationId, newPrompt });
    } else {
      toast({
        variant: "destructive",
        title: "No Prompt",
        description: "Please ensure the prompt is not empty.",
      });
    }
  };

  const openChangeProductModal = (variationId: number) => {
    setChangingProductForVariationId(variationId);
    setIsChangeProductModalOpen(true);
  };

  const handleProductSelectedFromModal = (newProductId: number) => {
    if (changingProductForVariationId !== null) {
      handleChangeProductMutation.mutate({
        variationId: changingProductForVariationId,
        newProductId,
      });
    }
  };

  if (!selectedSceneId) {
    return (
      <div>
        <h3 className="text-md font-semibold text-secondary mb-3">
          Select a Scene
        </h3>
        <div className="bg-muted p-6 rounded-lg text-center border border-dashed">
          <Info className="h-10 w-10 text-gray-400 mx-auto mb-3" />
          <p className="text-muted-foreground">
            Select a scene from the "Scene Breakdown" list to view or generate
            product placement options. Scenes initially identified by Vadis AI
            are marked with a{" "}
            <Info className="inline h-4 w-4 text-primary align-middle" /> icon.
          </p>
        </div>
      </div>
    );
  }

  if (isLoading && currentSceneVariations.length === 0) {
    return (
      <div>
        <h3 className="text-md font-semibold text-foreground mb-3">
          Scene {currentSceneToDisplay?.sceneNumber || selectedSceneId}: Product
          Placement Options
        </h3>
        <div className="text-center py-8">
          <Loader2 className="h-8 w-8 text-primary animate-spin mx-auto mb-3" />
          <p className="text-muted-foreground">Loading placement options...</p>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mt-4">
          {Array.from({ length: 3 }).map((_, i) => (
            <Card key={i} className="overflow-hidden animate-pulse">
              <Skeleton className="h-48 w-full bg-gray-200" />
              <CardContent className="p-2 sm:p-3">
                <Skeleton className="h-6 w-6 sm:h-8 sm:w-8 rounded-full bg-gray-200 inline-block mr-2" />
                <Skeleton className="h-4 w-20 sm:w-24 bg-gray-200 inline-block" />
                <Skeleton className="h-10 w-full bg-gray-200 mt-2" />
              </CardContent>
              <CardFooter className="p-2 sm:p-3 pt-0 flex justify-end">
                <Skeleton className="h-8 sm:h-9 w-24 sm:w-32 bg-gray-200" />
              </CardFooter>
            </Card>
          ))}
        </div>
      </div>
    );
  }
  if (
    currentSceneVariations.length === 0 &&
    currentSceneToDisplay &&
    !isLoading
  ) {
    return (
      <div>
        <h3 className="text-md font-semibold text-foreground mb-3">
          Scene {currentSceneToDisplay?.sceneNumber}: Product Placement Options
        </h3>
        <div className="bg-muted p-6 rounded-lg text-center border border-dashed">
          <ImageOff className="h-10 w-10 text-gray-400 mx-auto mb-3" />
          <p className="text-muted-foreground mb-3">
            No placement options generated yet for Scene{" "}
            {currentSceneToDisplay?.sceneNumber}.
          </p>
          <p className="text-sm text-gray-500">
            Variations are generated automatically when a scene is selected. If
            none appear, the scene might not have suggested categories or
            products.
          </p>
        </div>
      </div>
    );
  }
  if (!currentSceneToDisplay && !isLoading) {
    return (
      <div>
        <h3 className="text-md font-semibold text-secondary mb-3">
          Scene Details Unavailable
        </h3>
        <div className="bg-muted p-6 rounded-lg text-center border border-dashed">
          <Info className="h-10 w-10 text-gray-400 mx-auto mb-3" />
          <p className="text-muted-foreground">
            Details for the selected scene could not be loaded. Try selecting
            another scene.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div>
      {/* Mode Toggle */}
      <div className="flex items-center justify-between mb-3">
        <h3 className="text-sm sm:text-md font-semibold text-foreground line-clamp-2">
          {currentMode === 'brand' 
            ? `${projectTitle ? `Placement Options for "${projectTitle}" - ` : ""}Scene ${currentSceneToDisplay?.sceneNumber || selectedSceneId}`
            : `VFX Options for Scene ${currentSceneToDisplay?.sceneNumber || selectedSceneId}`
          }
        </h3>
        
        <div className="flex rounded-lg border p-1 bg-gray-50">
          <Button
            variant={currentMode === 'brand' ? 'default' : 'ghost'}
            size="sm"
            onClick={() => setCurrentMode('brand')}
            className={`px-2 py-1 text-xs ${
              currentMode === 'brand' 
                ? 'bg-green-600 text-white hover:bg-green-700' 
                : 'text-green-600 hover:text-green-700 hover:bg-green-50'
            }`}
          >
            <ShoppingBag className="w-3 h-3 mr-1" />
            Brand
          </Button>
          <Button
            variant={currentMode === 'vfx' ? 'default' : 'ghost'}
            size="sm"
            onClick={() => setCurrentMode('vfx')}
            className={`px-2 py-1 text-xs ${
              currentMode === 'vfx' 
                ? 'bg-purple-600 text-white hover:bg-purple-700' 
                : 'text-purple-600 hover:text-purple-700 hover:bg-purple-50'
            }`}
          >
            <Sparkles className="w-3 h-3 mr-1" />
            VFX
          </Button>
        </div>
      </div>
      {currentSceneToDisplay && (
        <>
          {currentMode === 'brand' ? (
            <>
              <p className="text-xs sm:text-sm text-muted-foreground mb-1 line-clamp-2">
                <span className="font-medium">Reason:</span>{" "}
                {currentSceneToDisplay.brandableReason ||
                  (currentSceneToDisplay.isBrandable
                    ? "Suitable for placement."
                    : "Not initially identified as brandable by Vadis AI; categories generated on demand.")}
              </p>
              <p className="text-xs sm:text-sm text-muted-foreground mb-3 sm:mb-4 line-clamp-2">
                <span className="font-medium">Categories:</span>{" "}
                {currentSceneToDisplay.suggestedCategories?.join(", ") ||
                  (isLoading ? "Loading categories..." : "None suggested yet")}
              </p>
            </>
          ) : (
            <>
              <p className="text-xs sm:text-sm text-muted-foreground mb-1 line-clamp-2">
                <span className="font-medium">VFX Requirements:</span>{" "}
                {currentSceneToDisplay.vfxDescription ||
                  (isLoading ? "Loading VFX requirements..." : "None specified yet")}
              </p>
              <p className="text-xs sm:text-sm text-muted-foreground mb-3 sm:mb-4 line-clamp-2">
                <span className="font-medium">VFX Elements:</span>{" "}
                {currentSceneToDisplay.vfxKeywords?.join(", ") ||
                  (isLoading ? "Loading VFX elements..." : "None specified yet")}
              </p>
            </>
          )}
        </>
      )}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4">
        {currentSceneVariations.map((variation) => {
          const videoState = videoGenerationStates[variation.id] || {
            status: "idle",
            progress: 0,
            stageMessage: "Generate Video",
          };
          const isUpdatingThisAsset =
            updateAssetsMutation.isPending &&
            updateAssetsMutation.variables?.variationId === variation.id;
          const isChangingThisProduct =
            handleChangeProductMutation.isPending &&
            handleChangeProductMutation.variables?.variationId === variation.id;

          const isThisVideoProcessing =
            videoState.status === "pending" ||
            videoState.status === "generating";
          const showImageOverlay =
            isUpdatingThisAsset ||
            isChangingThisProduct ||
            isThisVideoProcessing;
          const cardDisabledClass = showImageOverlay
            ? "opacity-70 cursor-not-allowed"
            : "";

          const currentPromptText =
            editedPrompts[variation.id] ?? variation.geminiPrompt ?? "";
          const isPromptUnchangedOrEmpty =
            !currentPromptText ||
            currentPromptText === (variation.geminiPrompt || "");

          return (
            <Card
              key={variation.id}
              className={`border-2 rounded-lg overflow-hidden shadow-sm hover:shadow-lg transition-all duration-200 
                ${isProductSelected(variation) ? "border-green-500 ring-1 ring-green-500" : 
                  variation.isSelected ? "border-blue-400 ring-1 ring-blue-400" : "border-gray-200"} 
                ${cardDisabledClass} w-full group relative cursor-pointer`}
              onClick={() => !showImageOverlay && handleProductSelect(variation)}
            >
              {isProductSelected(variation) && (
                <div className="absolute top-2 right-2 z-10 bg-green-500 rounded-full p-1">
                  <Check className="h-3 w-3 text-white" />
                </div>
              )}
              <div className="relative aspect-video bg-gray-100 overflow-hidden">
                <img
                  src={variation.imageUrl}
                  alt={`Option ${variation.variationNumber}: ${variation.productName} in ${currentSceneToDisplay?.heading}`}
                  className="w-full h-full object-cover transform scale-100 hover:scale-105 transition-transform duration-300 cursor-pointer"
                  loading="lazy"
                  onClick={() =>
                    !showImageOverlay &&
                    onImageZoom(
                      variation.imageUrl,
                      `Scene ${currentSceneToDisplay?.sceneNumber} - Option ${variation.variationNumber}: ${variation.productName}`,
                    )
                  }
                  onError={(e) => {
                    (e.target as HTMLImageElement).src =
                      "https://placehold.co/864x480/grey/white?text=Image+Error";
                    (e.target as HTMLImageElement).alt = "Error loading image";
                  }}
                />
                {!showImageOverlay &&
                  variation.imageUrl &&
                  variation.imageUrl !== FALLBACK_IMAGE_URL && (
                    <Button
                      variant="ghost"
                      size="icon"
                      className="absolute top-2 left-2 bg-black/50 text-white hover:bg-black/70 opacity-0 group-hover:opacity-100 transition-opacity"
                      onClick={() =>
                        onImageZoom(
                          variation.imageUrl,
                          `Scene ${currentSceneToDisplay?.sceneNumber} - Option ${variation.variationNumber}: ${variation.productName}`,
                        )
                      }
                      title="Zoom Image"
                    >
                      <ZoomIn className="h-5 w-5" />
                    </Button>
                  )}
                {showImageOverlay && (
                  <div className="absolute inset-0 bg-black/60 flex flex-col items-center justify-center text-white p-2 sm:p-4 text-center">
                    <Loader2 className="h-6 w-6 sm:h-8 sm:w-8 animate-spin mb-1 sm:mb-2" />
                    <p className="text-xs sm:text-sm font-medium">
                      {isUpdatingThisAsset
                        ? "Updating Image..."
                        : isChangingThisProduct
                          ? "Changing Product..."
                          : videoState.stageMessage || "Processing Video..."}
                    </p>
                    {isThisVideoProcessing && (
                      <p className="text-xs mt-1 bg-black/30 rounded-md p-1">
                        Processing...
                      </p>
                    )}
                    {(isThisVideoProcessing ||
                      (videoState.status === "succeeded" &&
                        !videoState.videoUrl)) &&
                      videoState.progress !== undefined &&
                      videoState.progress >= 0 &&
                      videoState.progress <= 100 && (
                        <Progress
                          value={videoState.progress}
                          className="w-3/4 h-1.5 mt-2 bg-gray-600 [&>div]:bg-primary"
                        />
                      )}
                  </div>
                )}
                {/* Video icon removed as requested */}
                {videoState.status === "failed" && !showImageOverlay && (
                  <div
                    className="absolute top-2 right-2 bg-red-500 text-white p-1 rounded-full shadow-lg"
                    title={`Video Failed: ${videoState.error || ""}`}
                  >
                    <AlertTriangle className="h-4 w-4" />
                  </div>
                )}
                <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-2">
                  <span className="text-white text-xs font-semibold">
                    Option {variation.variationNumber}: {variation.productName}
                  </span>
                </div>
              </div>

              <CardContent className="p-2 sm:p-3">
                <div className="flex items-center space-x-1 sm:space-x-2 mb-1.5">
                  <div className="w-6 h-6 sm:w-8 sm:h-8 rounded-md bg-gray-100 flex items-center justify-center overflow-hidden border">
                    <img
                      src={variation.productImageUrl}
                      alt={variation.productName}
                      className="w-full h-full object-contain"
                      onError={(e) => {
                        (e.target as HTMLImageElement).style.display = "none";
                        const parent = e.currentTarget.parentElement;
                        if (
                          parent &&
                          !parent.querySelector(".placeholder-icon")
                        ) {
                          parent.innerHTML +=
                            '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400 placeholder-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>';
                        }
                      }}
                    />
                  </div>
                  <div>
                    <p className="text-xs sm:text-sm font-medium leading-tight truncate">
                      {variation.productName}
                    </p>
                    <Badge
                      variant="outline"
                      className="text-xs py-0 sm:py-0.5 px-1 sm:px-1.5 mt-0.5 inline-block"
                    >
                      <span className="truncate max-w-[80px] inline-block">
                        {variation.productCategory}
                      </span>
                    </Badge>
                  </div>
                </div>
                <Textarea
                  value={currentPromptText}
                  onChange={(e) =>
                    handlePromptChange(variation.id, e.target.value)
                  }
                  placeholder="Edit prompt for asset generation..."
                  className="text-xs sm:text-sm mt-2 min-h-[60px] max-h-[120px] resize-y p-2"
                  disabled={showImageOverlay}
                />
                {videoState.status === "failed" && !isThisVideoProcessing ? (
                  <p
                    className="text-xs text-red-600 line-clamp-2 mt-1"
                    title={videoState.error || "Unknown video generation error"}
                  >
                    Video Failed: {videoState.error || "Unknown error"}
                  </p>
                ) : (
                  <p
                    className="text-[10px] sm:text-xs text-gray-600 line-clamp-2 mt-1 break-words"
                    title={variation.description}
                  >
                    {variation.description}
                  </p>
                )}
              </CardContent>

              <CardFooter className="p-2 sm:p-3 pt-1 sm:pt-2 grid grid-cols-2 gap-1 sm:gap-2">
                {currentMode === 'brand' ? (
                  <>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => openChangeProductModal(variation.id)}
                      disabled={
                        showImageOverlay || handleChangeProductMutation.isPending
                      }
                      className="text-xs sm:text-sm h-auto py-1 px-2 sm:px-3"
                    >
                      <Replace className="mr-1 h-3.5 w-3.5 flex-shrink-0" />{" "}
                      <span className="whitespace-nowrap">Change Product</span>
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => handleUpdateAssets(variation.id)}
                      disabled={
                        showImageOverlay ||
                        isPromptUnchangedOrEmpty ||
                        updateAssetsMutation.isPending
                      }
                      className="text-xs sm:text-sm h-auto py-1 px-2 sm:px-3"
                    >
                      {isUpdatingThisAsset ? (
                        <>
                          <Loader2 className="mr-1 h-4 w-4 animate-spin flex-shrink-0" />{" "}
                          <span className="whitespace-nowrap">Updating...</span>
                        </>
                      ) : (
                        <>
                          <RefreshCcw className="mr-1 h-4 w-4 flex-shrink-0" />{" "}
                          <span className="whitespace-nowrap">Update Assets</span>
                        </>
                      )}
                    </Button>
                  </>
                ) : (
                  <>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => toast({ title: "VFX Tier Selection", description: "VFX tier selection functionality coming soon!" })}
                      disabled={showImageOverlay}
                      className="text-xs sm:text-sm h-auto py-1 px-2 sm:px-3"
                    >
                      <Sparkles className="mr-1 h-3.5 w-3.5 flex-shrink-0" />{" "}
                      <span className="whitespace-nowrap">Select VFX Tier</span>
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => toast({ title: "VFX Update", description: "VFX asset update functionality coming soon!" })}
                      disabled={showImageOverlay}
                      className="text-xs sm:text-sm h-auto py-1 px-2 sm:px-3"
                    >
                      <RefreshCcw className="mr-1 h-4 w-4 flex-shrink-0" />{" "}
                      <span className="whitespace-nowrap">Update VFX</span>
                    </Button>
                  </>
                )}

                {videoState.status === "succeeded" && videoState.videoUrl ? (
                  <Button
                    variant="default"
                    size="sm"
                    onClick={() =>
                      onViewVideo(
                        videoState.videoUrl!,
                        `Scene ${currentSceneToDisplay?.sceneNumber} - ${variation.productName}`,
                      )
                    }
                    disabled={showImageOverlay || isLoading}
                    className="col-span-2 w-full justify-center text-sm sm:text-base py-1 h-auto"
                  >
                    <PlayCircle className="mr-1 h-4 w-4 flex-shrink-0" />{" "}
                    <span className="whitespace-nowrap">View Video</span>
                  </Button>
                ) : isThisVideoProcessing ? (
                  <Button
                    variant="outline"
                    size="sm"
                    disabled={true}
                    className="col-span-2 w-full justify-center text-sm sm:text-base py-1 h-auto"
                  >
                    <Loader2 className="mr-1 h-4 w-4 animate-spin flex-shrink-0" />
                    <span className="whitespace-nowrap flex items-center">
                      {videoState.status === "pending" ? (
                        <>
                          <span className="text-blue-400 animate-pulse mr-1">⚡</span>
                          <span>{videoState.stageMessage || "Queueing video..."}</span>
                        </>
                      ) : (
                        <>
                          <span className="text-green-400 animate-pulse mr-1">🎬</span>
                          <span>{videoState.stageMessage || "Processing video..."}</span>
                        </>
                      )}
                    </span>
                  </Button>
                ) : (
                  <>
                    {/* Brand Mode - Generate Video Button */}
                    {currentMode === 'brand' && (
                      <Button
                        variant={
                          videoState.status === "failed" ? "destructive" : "outline"
                        }
                        size="sm"
                        onClick={() => onGenerateVideoRequest(variation.id)}
                        disabled={showImageOverlay || isLoading}
                        className="col-span-2 w-full justify-center text-sm sm:text-base py-1 h-auto"
                      >
                        {videoState.status === "failed" ? (
                          <AlertTriangle className="mr-1 h-4 w-4 flex-shrink-0" />
                        ) : (
                          <Video className="mr-1 h-4 w-4 flex-shrink-0" />
                        )}
                        <span className="whitespace-nowrap">
                          {videoState.status === "failed"
                            ? "Retry Video"
                            : "Generate Video"}
                        </span>
                      </Button>
                    )}
                    
                    {/* VFX Mode - Generate VFX Button */}
                    {currentMode === 'vfx' && (
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => toast({ title: "VFX Generation", description: "VFX video generation functionality coming soon!" })}
                        disabled={showImageOverlay || isLoading}
                        className="col-span-2 w-full justify-center text-sm sm:text-base py-1 h-auto"
                      >
                        <Sparkles className="mr-1 h-4 w-4 flex-shrink-0" />
                        <span className="whitespace-nowrap">Generate VFX</span>
                      </Button>
                    )}
                  </>
                )}
              </CardFooter>
            </Card>
          );
        })}
      </div>

      {isChangeProductModalOpen && changingProductForVariationId !== null && (
        <ChangeProductModal
          isOpen={isChangeProductModalOpen}
          onClose={() => {
            setIsChangeProductModalOpen(false);
            setChangingProductForVariationId(null);
          }}
          currentProductId={
            productVariations.find(
              (v) => v.id === changingProductForVariationId,
            )?.productId || 0
          }
          onProductSelect={handleProductSelectedFromModal}
          isSubmitting={handleChangeProductMutation.isPending}
        />
      )}
    </div>
  );
}



================================================
FILE: client/src/components/script/ChangeProductModal.tsx
================================================
// Create this new file: client/src/components/script/ChangeProductModal.tsx
import { useState, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { Product } from "@shared/schema";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogClose,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Loader2, Search, X } from "lucide-react";
import { ProductCategory } from "@shared/schema";
import { Skeleton } from "@/components/ui/skeleton";

interface ChangeProductModalProps {
  isOpen: boolean;
  onClose: () => void;
  onProductSelect: (productId: number) => void;
  currentProductId: number; // To disable the currently assigned product
  isSubmitting: boolean; // To disable interactions while parent is submitting
}

const ProductItemCard = ({
  product,
  onSelect,
  isSelected,
  isDisabled,
}: {
  product: Product;
  onSelect: (productId: number) => void;
  isSelected: boolean;
  isDisabled: boolean;
}) => (
  <div
    className={`border rounded-lg p-3 flex flex-col items-center space-y-2 cursor-pointer hover:shadow-md transition-shadow
                ${isSelected ? "border-primary ring-2 ring-primary" : "border-gray-200"}
                ${isDisabled ? "opacity-50 cursor-not-allowed bg-gray-50" : "bg-white"}`}
    onClick={() => !isDisabled && onSelect(product.id)}
  >
    <img
      src={product.imageUrl}
      alt={product.name}
      className="w-24 h-24 object-contain rounded"
      onError={(e) => {
        (e.target as HTMLImageElement).src =
          "https://placehold.co/100x100?text=No+Img";
      }}
    />
    <div className="text-center">
      <p className="text-xs text-gray-500 truncate w-28">
        {product.companyName}
      </p>
      <p className="text-sm font-medium truncate w-28">{product.name}</p>
      <p className="text-xs bg-gray-100 px-1.5 py-0.5 rounded-full inline-block">
        {product.category}
      </p>
    </div>
    <Button
      size="sm"
      variant={isSelected ? "default" : "outline"}
      onClick={() => !isDisabled && onSelect(product.id)}
      disabled={isDisabled || isSelected}
      className="w-full mt-auto"
    >
      {isSelected ? "Selected" : "Select"}
    </Button>
  </div>
);

export default function ChangeProductModal({
  isOpen,
  onClose,
  onProductSelect,
  currentProductId,
  isSubmitting,
}: ChangeProductModalProps) {
  const [searchQuery, setSearchQuery] = useState("");
  const [categoryFilter, setCategoryFilter] = useState<ProductCategory | "ALL">(
    "ALL",
  );
  const [selectedStagedProductId, setSelectedStagedProductId] = useState<
    number | null
  >(null);
  const [page, setPage] = useState(1);
  const pageSize = 8; // Number of products per page in modal

  const {
    data: productsResponse,
    isLoading: isLoadingProducts,
    isFetching: isFetchingProducts,
  } = useQuery<{
    products: Product[];
    totalPages: number;
    currentPage: number;
  }>({
    queryKey: [
      "/api/products",
      { search: searchQuery, category: categoryFilter, page, pageSize },
    ],
    refetchOnWindowFocus: false,
    staleTime: 30000, // Data remains fresh for 30 seconds
  });

  const products = productsResponse?.products || [];
  const totalPages = productsResponse?.totalPages || 1;

  const handleConfirmSelection = () => {
    if (selectedStagedProductId !== null) {
      onProductSelect(selectedStagedProductId);
    }
  };

  // Reset staged selection when modal is closed or current product changes
  useEffect(() => {
    if (!isOpen) {
      setSelectedStagedProductId(null);
      setSearchQuery("");
      setCategoryFilter("ALL");
      setPage(1);
    }
  }, [isOpen, currentProductId]);

  const handlePageChange = (newPage: number) => {
    if (newPage >= 1 && newPage <= totalPages) {
      setPage(newPage);
    }
  };

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => {
        if (!open && !isSubmitting) onClose();
      }}
    >
      <DialogContent className="sm:max-w-3xl max-h-[90vh] overflow-y-auto flex flex-col">
        <DialogHeader>
          <DialogTitle>Change Product for Variation</DialogTitle>
        </DialogHeader>

        <div className="flex gap-2 p-1 border-b pb-3 mb-2">
          <div className="relative flex-grow">
            <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              type="search"
              placeholder="Search brands..."
              value={searchQuery}
              onChange={(e) => {
                setSearchQuery(e.target.value);
                setPage(1);
              }}
              className="pl-8 w-full"
              disabled={isSubmitting}
            />
          </div>
          <Select
            value={categoryFilter}
            onValueChange={(value) => {
              setCategoryFilter(value as ProductCategory | "ALL");
              setPage(1);
            }}
            disabled={isSubmitting}
          >
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="Category" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="ALL">All Categories</SelectItem>
              {Object.values(ProductCategory).map((cat) => (
                <SelectItem key={cat} value={cat}>
                  {cat.charAt(0) + cat.slice(1).toLowerCase()}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>

        <div className="flex-grow overflow-y-auto min-h-[40vh] max-h-[50vh] pr-4">
          {isLoadingProducts && products.length === 0 ? (
            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3 p-1">
              {Array.from({ length: pageSize }).map((_, i) => (
                <div
                  key={i}
                  className="border rounded-lg p-3 flex flex-col items-center space-y-2"
                >
                  <Skeleton className="w-24 h-24 rounded" />
                  <Skeleton className="h-4 w-20" />
                  <Skeleton className="h-4 w-16" />
                  <Skeleton className="h-8 w-full mt-2" />
                </div>
              ))}
            </div>
          ) : products.length === 0 ? (
            <div className="text-center py-10 text-muted-foreground">
              No products found matching your criteria.
            </div>
          ) : (
            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3 p-1">
              {products.map((product: Product) => (
                <ProductItemCard
                  key={product.id}
                  product={product}
                  onSelect={setSelectedStagedProductId}
                  isSelected={selectedStagedProductId === product.id}
                  isDisabled={product.id === currentProductId || isSubmitting}
                />
              ))}
            </div>
          )}
          {isFetchingProducts && (
            <Loader2 className="mx-auto my-4 h-6 w-6 animate-spin text-primary" />
          )}
        </div>

        {/* Pagination for Modal */}
        {totalPages > 1 && (
          <div className="flex justify-center items-center space-x-2 pt-3 border-t mt-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => handlePageChange(page - 1)}
              disabled={page === 1 || isFetchingProducts || isSubmitting}
            >
              Previous
            </Button>
            <span className="text-sm text-muted-foreground">
              Page {page} of {totalPages}
            </span>
            <Button
              variant="outline"
              size="sm"
              onClick={() => handlePageChange(page + 1)}
              disabled={
                page === totalPages || isFetchingProducts || isSubmitting
              }
            >
              Next
            </Button>
          </div>
        )}

        <DialogFooter className="pt-4">
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            Cancel
          </Button>
          <Button
            onClick={handleConfirmSelection}
            disabled={
              selectedStagedProductId === null ||
              isSubmitting ||
              selectedStagedProductId === currentProductId
            }
          >
            {isSubmitting ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Changing...
              </>
            ) : (
              "Confirm Change"
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


================================================
FILE: client/src/components/script/CharacterCasting.tsx
================================================
// client/src/components/script/CharacterCasting.tsx
import { CharacterCastingProps, ScriptCharacter, ActorSuggestion } from "@/lib/types";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { Users, UserSearch, Info, AlertTriangle, Edit3, UserCircle2, CheckCircle } from "lucide-react";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useQuery } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useState, useEffect } from "react";
import ActorSuggestionCard from "./ActorSuggestionCard";

export default function CharacterCasting({
  scriptId,
  isLoading: isLoadingInitial,
  filmGenre,
  projectBudgetTier,
  selectedCharacters = [],
  onCharacterSelect
}: CharacterCastingProps) {
  const [selectedCharacterName, setSelectedCharacterName] = useState<string | null>(null);
  const [customGenre, setCustomGenre] = useState(filmGenre || "");
  const [customRoleType, setCustomRoleType] = useState("lead");
  const [customBudgetTier, setCustomBudgetTier] = useState(projectBudgetTier || "medium");
  const [customGender, setCustomGender] = useState<string>("any");
  
  // Track if prefetch has been initiated
  const [prefetchInitiated, setPrefetchInitiated] = useState<boolean>(false);

  // Get all characters from the script
  const { data: characters = [], isLoading: isLoadingCharacters } = useQuery<ScriptCharacter[]>({
    queryKey: ['/api/scripts/characters', scriptId],
    queryFn: async ({ queryKey }) => {
      const [, sId] = queryKey as [string, number | null];
      if (!sId) return [];
      const res = await apiRequest("GET", `/api/scripts/${sId}/characters`);
      return res.json();
    },
    enabled: !!scriptId,
    onSuccess: (data) => {
      // Check if selected character still exists in the new data
      if (selectedCharacterName && !data.find(c => c.name === selectedCharacterName)) {
        setSelectedCharacterName(null);
      }
      
      // Trigger prefetch of character suggestions when characters are first loaded
      // This happens in the background and makes subsequent character selections faster
      if (data.length > 0 && !prefetchInitiated && scriptId) {
        setPrefetchInitiated(true);
        triggerPrefetch(scriptId);
      }
    }
  });

  // Function to trigger background prefetch of all character suggestions
  const triggerPrefetch = async (sId: number) => {
    try {
      console.log("[CharacterCasting] Starting prefetch for all characters...");
      const res = await apiRequest("POST", `/api/scripts/${sId}/prefetch-character-suggestions`);
      console.log("[CharacterCasting] Prefetch initiated successfully");
    } catch (error) {
      console.error("[CharacterCasting] Error initiating prefetch:", error);
      // Non-critical error, no need to show to user
    }
  };

  const selectedCharacterObject = characters.find(c => c.name === selectedCharacterName);

  // Use React Query to get actor suggestions for the selected character
  const { 
    data: actorSuggestions = [], 
    isLoading: isLoadingActorSuggestions, 
    refetch: refetchActorSuggestions, 
    isFetching: isFetchingActorSuggestions, 
    isError, 
    error 
  } = useQuery<ActorSuggestion[]>({
    queryKey: [
      '/api/characters/suggest-actors',
      selectedCharacterName,
      scriptId,
      customGenre,
      customRoleType,
      customBudgetTier,
      customGender,
      selectedCharacterObject?.estimatedAgeRange
    ],
    queryFn: async ({ queryKey }) => {
      const [, charName, currentScriptId, genre, roleType, budget, gender, charAge] = queryKey;
      if (!charName || !currentScriptId) return [];

      // Use the optimized endpoint with caching
      const params = new URLSearchParams({
        scriptId: String(currentScriptId),
        genre: genre as string,
        roleType: roleType as string,
        budgetTier: budget as string,
        gender: gender as string,
      });

      const res = await apiRequest("GET", `/api/characters/${charName}/suggest-actors?${params.toString()}`);
      return res.json();
    },
    enabled: !!selectedCharacterName && !!scriptId,
    // Add shorter staleTime to take advantage of server-side caching
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
  });

  // Keep custom criteria in sync with props
  useEffect(() => {
    if (filmGenre) setCustomGenre(filmGenre);
  }, [filmGenre]);

  useEffect(() => {
    if (projectBudgetTier) setCustomBudgetTier(projectBudgetTier);
  }, [projectBudgetTier]);

  // Handler for manual search
  const handleSearchActors = () => {
    if (selectedCharacterName && scriptId) {
      refetchActorSuggestions();
    }
  };

  if (isLoadingInitial || isLoadingCharacters) {
    return (
      <div className="space-y-3">
        <Skeleton className="h-8 w-1/2 mb-2" />
        <Skeleton className="h-10 w-full mb-4" />
        {[...Array(2)].map((_, i) => (
          <Card key={i} className="animate-pulse">
            <CardHeader><Skeleton className="h-5 w-3/5" /></CardHeader>
            <CardContent><Skeleton className="h-4 w-full" /></CardContent>
          </Card>
        ))}
      </div>
    );
  }

  if (!scriptId) {
    return (
      <div className="text-center text-sm text-muted-foreground py-4">
        <Info className="mx-auto h-6 w-6 mb-1" />
        Script not loaded or ID missing.
      </div>
    );
  }

  if (characters.length === 0 && !isLoadingCharacters) {
      return (
          <div className="text-center text-sm text-muted-foreground py-4">
              <Users className="mx-auto h-6 w-6 mb-1" />
              No characters found in the script, or script content is too short to extract characters.
          </div>
      )
  }


  return (
    <div className="space-y-4">
      <div>
        <Label htmlFor="character-select">Select Character to Cast</Label>
        <Select
          value={selectedCharacterName || ""}
          onValueChange={(value) => setSelectedCharacterName(value || null)}
        >
          <SelectTrigger id="character-select">
            <SelectValue placeholder="Select a character..." />
          </SelectTrigger>
          <SelectContent>
            {characters.map((char) => (
              <SelectItem key={char.name} value={char.name}>
                {char.name} {char.estimatedAgeRange && `(${char.estimatedAgeRange})`}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {selectedCharacterObject && (
        <Card className="bg-muted/50 p-3 border-dashed">
            <div className="flex justify-between items-center">
                <CardDescription className="text-xs mb-2">Refine search criteria for "{selectedCharacterObject.name}"</CardDescription>
                {selectedCharacterObject.estimatedAgeRange && (
                    <div className="text-xs text-muted-foreground mb-2 flex items-center">
                        <UserCircle2 className="h-3.5 w-3.5 mr-1" />
                        AI Est. Age: {selectedCharacterObject.estimatedAgeRange}
                    </div>
                )}
            </div>
            <div className="grid grid-cols-2 gap-2 mb-2">
                <div>
                    <Label htmlFor="cast-genre" className="text-xs">Genre</Label>
                    <Input id="cast-genre" value={customGenre} onChange={e => setCustomGenre(e.target.value)} placeholder="e.g., Action, Drama"/>
                </div>
                <div>
                    <Label htmlFor="cast-role" className="text-xs">Role Type</Label>
                     <Select value={customRoleType} onValueChange={setCustomRoleType}>
                        <SelectTrigger id="cast-role"><SelectValue/></SelectTrigger>
                        <SelectContent>
                            <SelectItem value="lead">Lead</SelectItem>
                            <SelectItem value="supporting">Supporting</SelectItem>
                            <SelectItem value="cameo">Cameo</SelectItem>
                        </SelectContent>
                    </Select>
                </div>
                <div>
                    <Label htmlFor="cast-gender" className="text-xs">Gender</Label>
                     <Select value={customGender} onValueChange={setCustomGender}>
                        <SelectTrigger id="cast-gender"><SelectValue placeholder="Any gender" /></SelectTrigger>
                        <SelectContent>
                            <SelectItem value="male">Male</SelectItem>
                            <SelectItem value="female">Female</SelectItem>
                            <SelectItem value="non-binary">Non-binary</SelectItem>
                            <SelectItem value="any">Any</SelectItem>
                        </SelectContent>
                    </Select>
                </div>
                <div>
                     <Label htmlFor="cast-budget" className="text-xs">Budget Tier</Label>
                     <Select value={customBudgetTier} onValueChange={setCustomBudgetTier}>
                        <SelectTrigger id="cast-budget"><SelectValue/></SelectTrigger>
                        <SelectContent>
                            <SelectItem value="low">Low (e.g., &lt;$1M)</SelectItem>
                            <SelectItem value="medium">Medium (e.g., $1M - $20M)</SelectItem>
                            <SelectItem value="high">High (e.g., $20M+)</SelectItem>
                            <SelectItem value="any">Any</SelectItem>
                        </SelectContent>
                    </Select>
                </div>
            </div>
            <Button onClick={handleSearchActors} size="sm" disabled={isFetchingActorSuggestions || !selectedCharacterName || !scriptId}>
                <UserSearch className="h-4 w-4 mr-1"/>
                {isFetchingActorSuggestions ? "Searching..." : "Find Actors"}
            </Button>
        </Card>
      )}

      {selectedCharacterName && (isLoadingActorSuggestions || isFetchingActorSuggestions) && (
        <div className="mt-4 space-y-3">
          <p className="text-sm text-muted-foreground text-center">Finding actor suggestions for {selectedCharacterName}...</p>
          {[...Array(3)].map((_, i) => <Skeleton key={i} className="h-20 w-full" />)}
        </div>
      )}

      {selectedCharacterName && !isLoadingActorSuggestions && !isFetchingActorSuggestions && isError && (
          <div className="text-center text-sm text-red-600 py-4 mt-4">
              <AlertTriangle className="mx-auto h-6 w-6 mb-1" />
              Error loading actor suggestions: {(error as Error)?.message || "Unknown error"}
          </div>
      )}

      {selectedCharacterName && !isLoadingActorSuggestions && !isFetchingActorSuggestions && !isError && actorSuggestions.length === 0 && (
        <div className="mt-4 text-center text-sm text-muted-foreground py-4">
          <Info className="mx-auto h-6 w-6 mb-1" />
          No actor suggestions found for "{selectedCharacterName}" with the current criteria. Try adjusting the filters.
        </div>
      )}

      {selectedCharacterName && !isLoadingActorSuggestions && !isFetchingActorSuggestions && !isError && actorSuggestions.length > 0 && (
        <div className="mt-4 space-y-3 max-h-[300px] overflow-y-auto pr-2">
          <h4 className="text-sm font-medium">
            Suggestions for {selectedCharacterName}:
            {selectedCharacters?.some(c => c.name === selectedCharacterName) && (
              <span className="ml-2 text-green-600 text-xs">(Selected)</span>
            )}
          </h4>
          {actorSuggestions.map((actor) => (
            <ActorSuggestionCard
              key={actor.id}
              actor={actor}
              characterName={selectedCharacterName}
              onSelect={onCharacterSelect}
              isSelected={selectedCharacters?.some(selected =>
                selected.name === selectedCharacterName && selected.actorId === actor.id
              )}
            />
          ))}
        </div>
      )}
    </div>
  );
}


================================================
FILE: client/src/components/script/FileUpload.tsx
================================================
// client/src/components/script/FileUpload.tsx
import { validatePdfFile } from "@/lib/utils"; // formatFileSize might also be useful for display
import { useToast } from "@/hooks/use-toast";
import { UploadCloud, AlertCircle } from "lucide-react"; // Changed icon to UploadCloud for distinction
import { useState } from "react";

// Updated Props: onFileUpload changed to onFileSelected
export interface FileUploadProps {
  onFileSelected: (file: File | null) => void;
  isLoading: boolean; // To disable the component while parent is processing
}

export default function FileUpload({ onFileSelected, isLoading }: FileUploadProps) {
  const [dragActive, setDragActive] = useState(false);
  const { toast } = useToast();

  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (isLoading) return;
    if (e.type === "dragenter" || e.type === "dragover") {
      setDragActive(true);
    } else if (e.type === "dragleave") {
      setDragActive(false);
    }
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (isLoading) return;
    setDragActive(false);

    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      handleFile(e.dataTransfer.files[0]);
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    e.preventDefault();
    if (isLoading) return;
    if (e.target.files && e.target.files[0]) {
      handleFile(e.target.files[0]);
      // Reset file input to allow selecting the same file again if needed after an error
      e.target.value = ""; 
    }
  };

  const handleFile = (file: File) => {
    if (!validatePdfFile(file)) {
      toast({
        variant: "destructive",
        title: "Invalid file",
        description: "Please upload a PDF or image file (jpg/png) under 10MB.",
      });
      onFileSelected(null); // Report null for invalid file
      return;
    }
    onFileSelected(file); // Pass the valid file up to the parent
  };

  return (
    <div className="flex items-center justify-center w-full">
      <label 
        htmlFor="script-file-selector" // Unique ID for the input
        className={`flex flex-col items-center justify-center w-full h-48 sm:h-56 border-2 ${
          isLoading ? "border-gray-200 bg-gray-50 cursor-not-allowed" :
          dragActive ? "border-primary bg-primary/10" : "border-gray-300 hover:border-gray-400"
        } border-dashed rounded-lg cursor-pointer bg-white hover:bg-gray-50 transition-colors`}
        onDragEnter={handleDrag}
        onDragLeave={handleDrag}
        onDragOver={handleDrag}
        onDrop={handleDrop}
      >
        <div className="flex flex-col items-center justify-center pt-5 pb-6">
          {isLoading ? (
            <>
              <Loader2 className="animate-spin rounded-full h-8 w-8 text-primary mb-3" />
              <p className="mb-2 text-sm text-gray-500">Processing...</p>
            </>
          ) : (
            <>
              <UploadCloud className="w-8 h-8 sm:w-10 sm:h-10 mb-3 text-gray-400" />
              <p className="mb-2 text-sm text-gray-500">
                <span className="font-semibold">Click to upload</span> or drag and drop
              </p>
              <p className="text-xs text-gray-500">PDF or image file (MAX. 10MB)</p>
            </>
          )}
        </div>
        <input 
          id="script-file-selector" 
          type="file" 
          className="hidden" 
          accept=".pdf,.jpg,.jpeg,.png" 
          onChange={handleChange}
          disabled={isLoading}
        />
      </label>
    </div>
  );
}


================================================
FILE: client/src/components/script/FinancialAnalysisModal.tsx
================================================
// client/src/components/script/FinancialAnalysisModal.tsx
import {
    Dialog,
    DialogContent,
    DialogHeader,
    DialogTitle,
    DialogDescription,
    DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { useQuery } from "@tanstack/react-query";
import { FinancialAnalysisModalProps, FinancialBreakdown, FinancialLineItem } from "@/lib/types";
import { Loader2, AlertTriangle, TrendingUp, TrendingDown, DollarSign, FileText } from "lucide-react";
import { apiRequest } from "@/lib/queryClient"; // Ensure this is correctly imported if needed for direct calls, otherwise props are fine.

const formatCurrency = (value: number | null | undefined): string => {
    if (value === null || value === undefined) return "$ -";
    return value.toLocaleString('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 0, maximumFractionDigits: 0 });
};

interface SectionProps {
    title: string;
    items: FinancialLineItem[];
    sectionTotal: number | null;
    isSubSection?: boolean;
}

const FinancialSection: React.FC<SectionProps> = ({ title, items, sectionTotal, isSubSection = false }) => (
    <div className={isSubSection ? "pl-4" : ""}>
        <h3 className={`font-semibold mb-2 ${isSubSection ? "text-md" : "text-lg"}`}>{title}</h3>
        <Table className="mb-4">
            <TableHeader>
                <TableRow>
                    <TableHead className="w-[100px] text-xs">Account</TableHead>
                    <TableHead className="text-xs">Description</TableHead>
                    <TableHead className="text-right text-xs">Total</TableHead>
                </TableRow>
            </TableHeader>
            <TableBody>
                {items.map((item) => (
                    <TableRow key={item.account || item.description}>
                        <TableCell className="font-mono text-xs">{item.account}</TableCell>
                        <TableCell className="text-xs">{item.description}</TableCell>
                        <TableCell className="text-right font-mono text-xs">{formatCurrency(item.total)}</TableCell>
                    </TableRow>
                ))}
                <TableRow className="font-bold bg-muted/50">
                    <TableCell colSpan={2} className="text-xs">Total {title}</TableCell>
                    <TableCell className="text-right font-mono text-xs">{formatCurrency(sectionTotal)}</TableCell>
                </TableRow>
            </TableBody>
        </Table>
    </div>
);


export default function FinancialAnalysisModal({ isOpen, onClose, scriptId, scriptTitle }: FinancialAnalysisModalProps) {
    const { data: financialData, isLoading, isError, error } = useQuery<FinancialBreakdown>({
        queryKey: [`/api/scripts/${scriptId}/financial-analysis`, scriptId],
        queryFn: async () => {
            if (!scriptId) throw new Error("Script ID is required for financial analysis.");
            const response = await apiRequest("GET", `/api/scripts/${scriptId}/financial-analysis`);
            return response.json();
        },
        enabled: isOpen && !!scriptId, // Only fetch when modal is open and scriptId is available
        refetchOnWindowFocus: false,
    });

    const renderContent = () => {
        if (isLoading) {
            return (
                <div className="flex flex-col items-center justify-center py-10">
                    <Loader2 className="h-12 w-12 animate-spin text-primary mb-4" />
                    <p className="text-muted-foreground">Loading financial analysis...</p>
                </div>
            );
        }

        if (isError) {
            return (
                <div className="flex flex-col items-center justify-center py-10 text-destructive">
                    <AlertTriangle className="h-12 w-12 mb-4" />
                    <p className="font-semibold">Error loading data</p>
                    <p className="text-sm">{(error as Error)?.message || "An unknown error occurred."}</p>
                </div>
            );
        }

        if (!financialData) {
            return (
                <div className="flex flex-col items-center justify-center py-10 text-muted-foreground">
                    <FileText className="h-12 w-12 mb-4" />
                    <p>No financial data available for this script yet.</p>
                    <p className="text-sm">Ensure project budget has been set on the Welcome page.</p>
                </div>
            );
        }

        const {
            projectName, expectedReleaseDate, location, prepWeeks, shootDays, unions,
            aboveTheLine, belowTheLineProduction, postProduction, otherBelowTheLine,
            bondFee, contingency,
            summaryTotalAboveTheLine, summaryTotalBelowTheLine, summaryTotalAboveAndBelowTheLine, summaryGrandTotal,
            totalBudgetInput, estimatedBrandSponsorshipValue, estimatedLocationIncentiveValue, netExternalCapitalRequired
        } = financialData;

        return (
            <ScrollArea className="max-h-[70vh] pr-3">
                <div className="space-y-6">
                    <div className="grid grid-cols-2 md:grid-cols-3 gap-4 text-xs border-b pb-4 mb-4">
                        <div><strong>Location:</strong> {location || '-'}</div>
                        <div><strong>Prep:</strong> {prepWeeks || '-'} WKS</div>
                        <div><strong>Shoot:</strong> {shootDays || '-'}</div>
                        <div><strong>Unions:</strong> {unions || '-'}</div>
                        {expectedReleaseDate && <div><strong>Release:</strong> {new Date(expectedReleaseDate).toLocaleDateString()}</div>}
                    </div>

                    {/* Major Categories */}
                    <FinancialSection title="Above-The-Line" items={[aboveTheLine.storyRights, aboveTheLine.producer, aboveTheLine.director, aboveTheLine.castAndStunts, aboveTheLine.fringes]} sectionTotal={aboveTheLine.total} />
                    <FinancialSection title="Below-The-Line Production" items={Object.values(belowTheLineProduction).filter(item => typeof item === 'object' && item !== null && 'account' in item) as FinancialLineItem[]} sectionTotal={belowTheLineProduction.total} />
                    <FinancialSection title="Post Production" items={Object.values(postProduction).filter(item => typeof item === 'object' && item !== null && 'account' in item) as FinancialLineItem[]} sectionTotal={postProduction.total} />
                    <FinancialSection title="Other Below-The-Line" items={Object.values(otherBelowTheLine).filter(item => typeof item === 'object' && item !== null && 'account' in item) as FinancialLineItem[]} sectionTotal={otherBelowTheLine.total} />

                    {/* Single Items like Bond and Contingency */}
                    <FinancialSection title="" items={[bondFee, contingency]} sectionTotal={null} />

                    {/* Summary Totals */}
                    <div className="mt-6 pt-4 border-t">
                        <h3 className="text-lg font-semibold mb-3">Budget Summary</h3>
                        <div className="space-y-1 text-sm">
                            <div className="flex justify-between"><span>Total Above-The-Line:</span> <span className="font-mono font-semibold">{formatCurrency(summaryTotalAboveTheLine)}</span></div>
                            <div className="flex justify-between"><span>Total Below-The-Line:</span> <span className="font-mono font-semibold">{formatCurrency(summaryTotalBelowTheLine)}</span></div>
                            <div className="flex justify-between font-bold border-t pt-1 mt-1"><span>TOTAL FILM COST (PRE-CONTINGENCY/BOND):</span> <span className="font-mono">{formatCurrency(summaryTotalAboveAndBelowTheLine)}</span></div>
                            <div className="flex justify-between font-bold text-lg border-t-2 border-b-2 py-2 my-2"><span>GRAND TOTAL:</span> <span className="font-mono">{formatCurrency(summaryGrandTotal)}</span></div>
                        </div>
                    </div>

                    {/* Vadis Analysis Section - this part will be enhanced later */}
                    <div className="mt-6 pt-4 border-t">
                        <h3 className="text-lg font-semibold mb-3">Vadis AI Financial Insights</h3>
                        <div className="space-y-2 text-sm p-4 bg-blue-50 rounded-md border border-blue-200">
                            <div className="flex justify-between items-center">
                                <span className="flex items-center"><DollarSign className="h-4 w-4 mr-1 text-gray-600"/>Total Project Budget (Input):</span> 
                                <span className="font-mono font-semibold">{formatCurrency(totalBudgetInput)}</span>
                            </div>
                            <div className="flex justify-between items-center text-green-600">
                                <span className="flex items-center"><TrendingDown className="h-4 w-4 mr-1"/>Est. Brand Sponsorship Value:</span> 
                                <span className="font-mono font-semibold">{formatCurrency(estimatedBrandSponsorshipValue)}</span>
                            </div>
                             <div className="flex justify-between items-center text-green-600">
                                <span className="flex items-center"><TrendingDown className="h-4 w-4 mr-1"/>Est. Location Incentive Value:</span> 
                                <span className="font-mono font-semibold">{formatCurrency(estimatedLocationIncentiveValue)}</span>
                            </div>
                            <div className="flex justify-between items-center font-bold text-blue-700 border-t pt-2 mt-2">
                                <span className="flex items-center"><TrendingUp className="h-4 w-4 mr-1"/>Net External Capital Required:</span> 
                                <span className="font-mono">{formatCurrency(netExternalCapitalRequired)}</span>
                            </div>
                        </div>
                    </div>
                </div>
            </ScrollArea>
        );
    };

    return (
        <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
            <DialogContent className="max-w-3xl md:max-w-4xl lg:max-w-5xl w-[95vw] h-[90vh] flex flex-col">
                <DialogHeader className="pr-10"> {/* Add padding for close button */}
                    <DialogTitle>Project Financial Analysis: {scriptTitle || financialData?.projectName || "Loading..."}</DialogTitle>
                    <DialogDescription>
                        Preliminary financial overview based on current project data and selections.
                        (This is a template view with mostly placeholder values for line items.)
                    </DialogDescription>
                </DialogHeader>

                <div className="flex-grow overflow-hidden">
                    {renderContent()}
                </div>

                <DialogFooter className="mt-auto pt-4 border-t">
                    <Button variant="outline" onClick={onClose}>Close</Button>
                    {/* Add Export to Excel button here in a later task */}
                </DialogFooter>
            </DialogContent>
        </Dialog>
    );
}


================================================
FILE: client/src/components/script/ImageZoomModal.tsx
================================================
// client/src/components/script/ImageZoomModal.tsx
import { ImageZoomModalProps } from "@/lib/types";
import {
    Dialog,
    DialogContent,
    DialogHeader,
    DialogTitle,
    DialogFooter,
    DialogClose, // This was causing the issue if used explicitly below
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { X, Loader2, AlertTriangle, Download } from "lucide-react"; // X is still needed for the default shadcn DialogClose
import { useState, useEffect } from "react";

export default function ImageZoomModal({
    isOpen,
    onClose,
    imageUrl,
    title,
}: ImageZoomModalProps) {
    const [isLoading, setIsLoading] = useState(true);
    const [hasError, setHasError] = useState(false);

    useEffect(() => {
        if (isOpen && imageUrl) {
            setIsLoading(true);
            setHasError(false);
        }
    }, [isOpen, imageUrl]);

    const handleImageLoad = () => {
        setIsLoading(false);
        setHasError(false);
    };

    const handleImageError = () => {
        setIsLoading(false);
        setHasError(true);
    };

    const handleDownload = () => {
        if (imageUrl) {
            const link = document.createElement("a");
            link.href = imageUrl;
            link.download = title
                ? `${title.replace(/[^a-z0-9]/gi, "_")}.png`
                : "zoomed_image.png"; // Basic filename
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    };

    return (
        <Dialog
            open={isOpen}
            onOpenChange={(open) => {
                if (!open) onClose();
            }}
        >
            <DialogContent className="sm:max-w-4xl max-h-[90vh] flex flex-col p-0">
                <DialogHeader className="p-4 border-b">
                    <DialogTitle>{title || "Image Preview"}</DialogTitle>
                    {/* The explicit DialogClose that was here has been removed.
                        The DialogContent component provides its own close button by default. */}
                </DialogHeader>

                <div className="flex-grow flex items-center justify-center bg-black/90 overflow-auto p-4">
                    {isLoading && !hasError && imageUrl && (
                        <div className="absolute inset-0 flex flex-col items-center justify-center text-white">
                            <Loader2 className="h-12 w-12 animate-spin mb-3" />
                            <p>Loading image...</p>
                        </div>
                    )}
                    {hasError && imageUrl && (
                        <div className="flex flex-col items-center justify-center text-red-400 p-4 text-center">
                            <AlertTriangle className="h-12 w-12 mb-3" />
                            <p>Error loading image.</p>
                        </div>
                    )}
                    {imageUrl && (
                        <img
                            src={imageUrl}
                            alt={title || "Zoomed Image"}
                            className={`max-w-full max-h-[calc(80vh-80px)] object-contain transition-opacity duration-300 ${isLoading || hasError ? "opacity-0" : "opacity-100"}`}
                            onLoad={handleImageLoad}
                            onError={handleImageError}
                        />
                    )}
                    {!imageUrl && (
                        <div className="flex flex-col items-center justify-center text-gray-400 p-4 text-center">
                            <AlertTriangle className="h-12 w-12 mb-3" />
                            <p>No image URL provided.</p>
                        </div>
                    )}
                </div>
                <DialogFooter className="p-4 border-t sm:justify-end">
                    <Button
                        variant="outline"
                        onClick={handleDownload}
                        disabled={!imageUrl || isLoading || hasError}
                        className="flex items-center"
                    >
                        <Download className="mr-1 h-4 w-4" />
                        Download Image
                    </Button>
                    <Button type="button" variant="secondary" onClick={onClose}>
                        Close
                    </Button>
                </DialogFooter>
            </DialogContent>
        </Dialog>
    );
}



================================================
FILE: client/src/components/script/SceneBreakdown.tsx
================================================
// client/src/components/script/SceneBreakdown.tsx
import { SceneBreakdownProps } from "@/lib/types";
import { cn } from "@/lib/utils";
import { Star, Sparkles } from "lucide-react"; // Added Sparkles for VFX scenes
import { ScrollArea } from "@/components/ui/scroll-area";
import { Skeleton } from "@/components/ui/skeleton";

export default function SceneBreakdown({
  scenes,
  activeSceneId,
  projectTitle,
  brandableSceneIds,
  isLoading,
  onSceneSelect,
}: SceneBreakdownProps) {
  if (isLoading) {
    return (
      <div className="lg:col-span-1 bg-white p-4 rounded-lg shadow animate-pulse">
        <h2 className="text-lg font-semibold mb-4 text-foreground">
          <Skeleton className="h-6 w-3/4" />
        </h2>
        <div className="space-y-2">
          {Array.from({ length: 6 }).map((_, i) => (
            <div key={i} className="flex items-center">
              <Skeleton className="h-6 w-full" />
            </div>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="lg:col-span-1 bg-white p-4 rounded-lg shadow">
      <h2 className="text-lg font-semibold mb-4 text-foreground">
        {projectTitle
          ? `Scene Breakdown for "${projectTitle}"`
          : "Scene Breakdown"}
      </h2>

      <div className="h-[400px] overflow-hidden">
        <ScrollArea className="h-full pr-2">
          <ul className="space-y-2">
            {scenes.map((scene) => (
              <li
                key={scene.id}
                className={cn(
                  "px-3 py-2 rounded-r cursor-pointer scene-item",
                  activeSceneId === scene.id ? "active" : "",
                )}
                onClick={() => onSceneSelect(scene.id)}
              >
                <div className="flex justify-between items-center">
                  <div>
                    <span className="font-semibold">
                      Scene {scene.sceneNumber}
                    </span>
                    <p className="text-xs text-gray-600">{scene.heading}</p>
                  </div>
                  <div className="flex items-center gap-2">
                    {scene.isVfxScene && (
                      <Sparkles className="h-4 w-4 text-purple-500" title="VFX Scene" />
                    )}
                    {brandableSceneIds.includes(scene.id) && (
                      <Star className="h-5 w-5 text-green-500 brandable-indicator" title="Brandable Scene" />
                    )}
                  </div>
                </div>
              </li>
            ))}
          </ul>
        </ScrollArea>
      </div>

      {brandableSceneIds.length > 0 && (
        <div className="mt-6 pt-4 border-t border-gray-200">
          <div className="bg-green-50 border border-green-200 rounded-md p-3">
            <p className="text-sm text-green-800 mb-2 font-medium">
              {`VADIS AI SUGGESTED BRANDABLE SCENES`}
            </p>
            <p className="text-xs text-green-600 mb-2">
              {`There are ${scenes.filter(scene => brandableSceneIds.includes(scene.id)).length} scenes with product placement potential. Vadis AI has suggested the following scenes for their branding potential:`}
            </p>
            <div className="max-h-24 overflow-y-auto">
              <ul className="text-xs text-green-700 space-y-1 pr-2">
                {scenes
                  .filter((scene) => brandableSceneIds.includes(scene.id))
                  .map((scene) => {
                    const category = scene.suggestedCategories?.length
                      ? scene.suggestedCategories[0]
                      : "Product";

                    return (
                      <li key={scene.id} className="flex items-center">
                        <Star className="h-4 w-4 mr-1 text-green-600 flex-shrink-0" />
                        Scene {scene.sceneNumber}: {scene.heading.length > 30 ? scene.heading.substring(0, 30) + "..." : scene.heading} ({category})
                      </li>
                    );
                  })}
              </ul>
            </div>
          </div>
        </div>
      )}

      {/* VFX Scenes Summary */}
      {scenes.length > 0 && scenes.some(scene => scene.isVfxScene) && (
        <div className="mt-4">
          <div className="bg-purple-50 border border-purple-200 rounded-md p-3">
            <p className="text-sm text-purple-800 mb-2 font-medium">
              {`VADIS AI SUGGESTED VFX SCENES`}
            </p>
            <p className="text-xs text-purple-600 mb-2">
              {`There are ${scenes.filter(scene => scene.isVfxScene).length} scenes with VFX potential. Vadis AI has suggested the following scenes for their VFX potential:`}
            </p>
            <div className="max-h-24 overflow-y-auto">
              <ul className="text-xs text-purple-700 space-y-1 pr-2">
                {scenes
                  .filter((scene) => scene.isVfxScene)
                  .map((scene) => {
                    return (
                      <li key={scene.id} className="flex items-center">
                        <Sparkles className="h-4 w-4 mr-1 text-purple-600 flex-shrink-0" />
                        Scene {scene.sceneNumber}: {scene.heading.length > 30 ? scene.heading.substring(0, 30) + "..." : scene.heading}
                      </li>
                    );
                  })}
              </ul>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}



================================================
FILE: client/src/components/script/ScriptDisplay.tsx
================================================
import { ScriptDisplayProps } from "@/lib/types";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { useToast } from "@/hooks/use-toast";
import React, { useState, useEffect } from "react"; // Ensure React is imported
import { Skeleton } from "@/components/ui/skeleton";
import { Scene } from "@shared/schema"; // Import Scene if it's used for activeScene type
import { Sparkles, Loader2 } from "lucide-react";

export default function ScriptDisplay({
  script,
  isLoading,
  onSave,
  onReanalyze,
  onAnalyzeVfx,
  onGeneratePlacements,
  activeScene,
  isSaving,
  isReanalyzing,
  isAnalyzingVfx,
  isGenerating,
  isExporting,
}: ScriptDisplayProps) {
  const [editorContent, setEditorContent] = useState<string>("");
  const { toast } = useToast();

  useEffect(() => {
    if (activeScene) {
      setEditorContent(activeScene.content || ""); // Add nullish coalescing for safety
    } else if (script) {
      setEditorContent(script.content || ""); // Add nullish coalescing
    } else {
      setEditorContent(""); // Default to empty if neither is present
    }
  }, [script, activeScene]);

  const handleSave = async () => {
    try {
      setIsSaving(true);
      await onSave();
      toast({
        title: "Script saved",
        description: "Your script has been successfully saved.",
      });
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Save failed",
        description: "There was an error saving your script.",
      });
    } finally {
      setIsSaving(false);
    }
  };

  const handleReanalyze = async () => {
    try {
      setIsReanalyzing(true);
      await onReanalyze();
      toast({
        title: "Analysis complete",
        description: "Your script has been re-analyzed for brandable scenes.",
      });
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Analysis failed",
        description: "There was an error analyzing your script.",
      });
    } finally {
      setIsReanalyzing(false);
    }
  };

  const handleGeneratePlacements = async () => {
    if (!onGeneratePlacements) return;

    try {
      setIsGenerating(true);
      await onGeneratePlacements();
      toast({
        title: "Generation complete",
        description: "We've generated product placements for brandable scenes.",
      });
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Generation failed",
        description: "There was an error generating product placements.",
      });
    } finally {
      setIsGenerating(false);
    }
  };

  if (isLoading) {
    return (
      <div className="space-y-4">
        <div className="flex justify-between items-center mb-4">
          {/* Changed text-secondary to text-foreground to match other headings */}
          <h2 className="text-lg font-semibold text-foreground">
            Script Editor
          </h2>
          <div className="flex space-x-2">
            <Skeleton className="h-10 w-20" />
            <Skeleton className="h-10 w-32" />
          </div>
        </div>
        <Skeleton className="h-64 w-full" />
      </div>
    );
  }

  return (
    <div>
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-lg font-semibold text-foreground">
          {activeScene
            ? `Scene ${activeScene.sceneNumber}: ${activeScene.heading}`
            : script?.title || "Script Editor" } {/* Display script title if no active scene */}
        </h2>

      </div>

      <Textarea
        value={editorContent}
        onChange={(e) => setEditorContent(e.target.value)}
        className="h-64 font-mono text-sm bg-gray-50 resize-none script-editor"
        placeholder={script ? "Select a scene or view full script..." : "Script content will appear here once uploaded..."}
        readOnly={!script} // Make readOnly if no script
      />
    </div>
  );
}


================================================
FILE: client/src/components/script/SuggestedLocations.tsx
================================================
// client/src/components/script/SuggestedLocations.tsx
import { SuggestedLocationsProps, ClientSuggestedLocation } from "@/lib/types";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { MapPin, Info, AlertTriangle, FileText, Check } from "lucide-react";
import { useQuery } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { cn } from "@/lib/utils";
// Scene type no longer needed here for props

export default function SuggestedLocations({ 
  scriptId, 
  projectBudget, 
  isLoading: initialLoading,
  selectedLocations = [],
  onLocationSelect
}: SuggestedLocationsProps) {

  const { data: suggestedLocations = [], isLoading, isError, error } = useQuery<ClientSuggestedLocation[]>({
    // Updated queryKey to use scriptId and new endpoint structure
    queryKey: ['/api/scripts/suggest-locations', scriptId, { budget: projectBudget, count: 5 }],
    queryFn: async ({ queryKey }) => {
        const [, sId, params] = queryKey as [string, number, { budget?: number, count?: number }]; // Type assertion for params
        if (!sId) return [];

        const queryParams = new URLSearchParams();
        if (params.budget !== undefined) queryParams.append('budget', String(params.budget));
        if (params.count !== undefined) queryParams.append('count', String(params.count));

        const res = await apiRequest("GET", `/api/scripts/${sId}/suggest-locations?${queryParams.toString()}`);
        return res.json();
    },
    enabled: !!scriptId, // Only fetch if there's a scriptId
    staleTime: 5 * 60 * 1000,
  });

  if (!scriptId && !initialLoading) { // Show message if no script is loaded yet, but not during initial page load
    return (
      <div className="text-center text-sm text-muted-foreground py-4">
        <Info className="mx-auto h-6 w-6 mb-1" />
        Load a script to see AI-powered location suggestions.
      </div>
    );
  }

  if (isLoading || initialLoading) {
    return (
      <div className="space-y-3">
        {[...Array(3)].map((_, i) => (
          <Card key={i} className="animate-pulse">
            <CardHeader><Skeleton className="h-5 w-3/4" /><Skeleton className="h-4 w-1/2" /></CardHeader>
            <CardContent><Skeleton className="h-4 w-full mb-1" /><Skeleton className="h-4 w-5/6" /></CardContent>
          </Card>
        ))}
      </div>
    );
  }

  if (isError) {
      return (
          <div className="text-center text-sm text-red-600 py-4">
              <AlertTriangle className="mx-auto h-6 w-6 mb-1" />
              Error loading location suggestions: {(error as Error)?.message || "Unknown error"}
          </div>
      );
  }

  if (suggestedLocations.length === 0) {
    return (
      <div className="text-center text-sm text-muted-foreground py-4">
        <MapPin className="mx-auto h-6 w-6 mb-1" />
        No specific AI location suggestions available for this script and budget.
        <br />
        Try adjusting the project budget.
      </div>
    );
  }

  const isLocationSelected = (location: ClientSuggestedLocation) => {
    return selectedLocations.some(selected => selected.id === location.id);
  };

  const handleLocationClick = (location: ClientSuggestedLocation) => {
    if (onLocationSelect) {
      onLocationSelect(location);
    }
  };

  return (
    <div className="space-y-3 max-h-[400px] overflow-y-auto pr-2">
      {suggestedLocations.map((loc) => {
        const isSelected = isLocationSelected(loc);
        
        return (
          <Card 
            key={loc.id} 
            className={cn(
              "shadow-sm hover:shadow-md transition-shadow cursor-pointer relative",
              isSelected ? "border-2 border-green-500" : ""
            )}
            onClick={() => handleLocationClick(loc)}
          >
            {isSelected && (
              <div className="absolute top-2 right-2 bg-green-500 rounded-full p-1">
                <Check className="h-3 w-3 text-white" />
              </div>
            )}
            <CardHeader className="pb-2">
              <CardTitle className="text-base flex items-center">
                <MapPin className="h-4 w-4 mr-2 text-primary" />
                {loc.country}{loc.region && `, ${loc.region}`}
              </CardTitle>
              <CardDescription className="text-xs">{loc.incentiveProgram}</CardDescription>
            </CardHeader>
            <CardContent className="text-xs space-y-1.5">
              {loc.matchReason && ( <p className="italic"><strong>AI Match Reason:</strong> {loc.matchReason}</p> )}
              {loc.estimatedIncentiveValue && (
                <div className="mt-1 p-2 bg-blue-50 border border-blue-200 rounded-md">
                  <p className="font-medium text-blue-700 flex items-center"> <FileText className="h-3.5 w-3.5 mr-1.5 shrink-0" /> Incentive Notes: </p>
                  <p className="text-blue-600">{loc.estimatedIncentiveValue}</p>
                </div>
              )}
              {loc.confidenceScore && ( <p className="text-xs text-muted-foreground"> Match Confidence: {(loc.confidenceScore * 100).toFixed(0)}% </p> )}
            </CardContent>
          </Card>
        );
      })}
    </div>
  );
}


================================================
FILE: client/src/components/script/VfxSceneDetails.tsx
================================================
import { useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Sparkles, Info, DollarSign } from "lucide-react";
import type { Scene, VfxQualityTierType, VfxSceneDetail } from "@shared/schema";
import ImageZoomModal from "@/components/script/ImageZoomModal";

export interface VfxSceneDetailsProps {
  scriptId: number;
  activeScene: Scene | null;
  initialSelectedVfxTier: VfxQualityTierType | null;
  onVfxTierSelect: (sceneId: number, tier: VfxQualityTierType, cost: number) => void;
}

interface SceneWithVfxDetails extends Scene {
  vfxDetails?: VfxSceneDetail[];
}

const VFX_TIER_CONFIG = {
  LOW: {
    name: "Low Quality VFX",
    description: "Basic visual effects for simple scenes",
    color: "bg-blue-50 border-blue-200 dark:bg-blue-950 dark:border-blue-800"
  },
  MEDIUM: {
    name: "Medium Quality VFX", 
    description: "Professional grade effects for standard production",
    color: "bg-purple-50 border-purple-200 dark:bg-purple-950 dark:border-purple-800"
  },
  HIGH: {
    name: "High Quality VFX",
    description: "Premium cinematic quality effects",
    color: "bg-amber-50 border-amber-200 dark:bg-amber-950 dark:border-amber-800"
  }
} as const;

export function VfxSceneDetails({ 
  scriptId, 
  activeScene, 
  initialSelectedVfxTier, 
  onVfxTierSelect 
}: VfxSceneDetailsProps) {
  const [selectedImageUrl, setSelectedImageUrl] = useState<string | null>(null);
  
  // Only display if scene is provided and is a VFX scene
  if (!activeScene || !activeScene.isVfxScene) {
    return null;
  }

  const sceneWithDetails = activeScene as SceneWithVfxDetails;
  const vfxDetails = sceneWithDetails.vfxDetails || [];
  const isLoading = vfxDetails.length === 0;

  // Get the conceptual image URL (prefer MEDIUM tier, fallback to first available)
  const getConceptualImageUrl = (): string | null => {
    const mediumTier = vfxDetails.find(detail => detail.qualityTier === 'MEDIUM');
    if (mediumTier?.conceptualImageUrl) return mediumTier.conceptualImageUrl;
    
    const firstWithImage = vfxDetails.find(detail => detail.conceptualImageUrl);
    return firstWithImage?.conceptualImageUrl || null;
  };

  const conceptualImageUrl = getConceptualImageUrl();

  // Format cost as currency
  const formatCost = (cost: number): string => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(cost);
  };

  // Parse VFX keywords
  const vfxKeywords = Array.isArray(activeScene.vfxKeywords) 
    ? activeScene.vfxKeywords 
    : (typeof activeScene.vfxKeywords === 'string' 
        ? activeScene.vfxKeywords.split(',').map(k => k.trim()).filter(Boolean)
        : []);

  return (
    <div className="space-y-6">
      {/* Scene VFX Overview */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Sparkles className="w-5 h-5 text-purple-600" />
            VFX Scene Details
          </CardTitle>
          <CardDescription>
            Scene {activeScene.sceneNumber}: {activeScene.heading}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* VFX Description */}
          {activeScene.vfxDescription && (
            <div>
              <h4 className="font-medium text-sm text-muted-foreground mb-2">VFX Requirements</h4>
              <p className="text-sm">{activeScene.vfxDescription}</p>
            </div>
          )}

          {/* VFX Keywords */}
          {vfxKeywords.length > 0 && (
            <div>
              <h4 className="font-medium text-sm text-muted-foreground mb-2">VFX Elements</h4>
              <div className="flex flex-wrap gap-2">
                {vfxKeywords.map((keyword, index) => (
                  <Badge key={index} variant="secondary" className="text-xs">
                    {keyword}
                  </Badge>
                ))}
              </div>
            </div>
          )}

          {/* Conceptual Image */}
          {conceptualImageUrl && (
            <div>
              <h4 className="font-medium text-sm text-muted-foreground mb-2">Conceptual Visualization</h4>
              <div 
                className="relative cursor-pointer rounded-lg overflow-hidden border hover:opacity-90 transition-opacity"
                onClick={() => setSelectedImageUrl(conceptualImageUrl)}
              >
                <img 
                  src={conceptualImageUrl} 
                  alt="VFX Concept"
                  className="w-full h-48 object-cover"
                />
                <div className="absolute inset-0 bg-black/0 hover:bg-black/10 transition-colors" />
              </div>
              <p className="text-xs text-muted-foreground mt-1">Click to view full size</p>
            </div>
          )}
        </CardContent>
      </Card>

      {/* VFX Quality Tiers */}
      <div>
        <h3 className="text-lg font-semibold mb-4">VFX Quality Tiers</h3>
        
        {isLoading ? (
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {Array.from({ length: 3 }).map((_, index) => (
              <Card key={index}>
                <CardHeader>
                  <Skeleton className="h-5 w-24" />
                  <Skeleton className="h-4 w-32" />
                </CardHeader>
                <CardContent>
                  <Skeleton className="h-16 w-full mb-4" />
                  <Skeleton className="h-6 w-20 mb-2" />
                  <Skeleton className="h-9 w-full" />
                </CardContent>
              </Card>
            ))}
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {(['LOW', 'MEDIUM', 'HIGH'] as VfxQualityTierType[]).map((tier) => {
              const tierDetail = vfxDetails.find(detail => detail.qualityTier === tier);
              const tierConfig = VFX_TIER_CONFIG[tier];
              const isSelected = initialSelectedVfxTier === tier;
              
              return (
                <Card 
                  key={tier} 
                  className={`${tierConfig.color} ${isSelected ? 'ring-2 ring-primary' : ''}`}
                >
                  <CardHeader>
                    <CardTitle className="flex items-center justify-between text-base">
                      {tierConfig.name}
                      {tierDetail?.estimatedVfxCost && (
                        <div className="flex items-center gap-1 text-sm font-medium">
                          <DollarSign className="w-4 h-4" />
                          {formatCost(tierDetail.estimatedVfxCost)}
                        </div>
                      )}
                    </CardTitle>
                    <CardDescription>{tierConfig.description}</CardDescription>
                  </CardHeader>
                  <CardContent className="space-y-4">
                    {tierDetail ? (
                      <>
                        {/* VFX Elements Summary */}
                        {tierDetail.vfxElementsSummaryForTier && (
                          <div>
                            <p className="text-sm">{tierDetail.vfxElementsSummaryForTier}</p>
                          </div>
                        )}

                        {/* Cost Notes with Tooltip */}
                        {tierDetail.costEstimationNotes && (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <div className="flex items-center gap-1 text-xs text-muted-foreground cursor-help">
                                  <Info className="w-3 h-3" />
                                  Cost breakdown details
                                </div>
                              </TooltipTrigger>
                              <TooltipContent className="max-w-xs">
                                <p className="text-sm">{tierDetail.costEstimationNotes}</p>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}

                        {/* Select Tier Button */}
                        <Button
                          onClick={() => tierDetail.estimatedVfxCost && onVfxTierSelect(
                            activeScene.id, 
                            tier, 
                            tierDetail.estimatedVfxCost
                          )}
                          variant={isSelected ? "default" : "outline"}
                          className="w-full"
                          disabled={!tierDetail.estimatedVfxCost}
                        >
                          {isSelected ? "Selected" : "Select Tier"}
                        </Button>
                      </>
                    ) : (
                      <div className="text-center py-4">
                        <Skeleton className="h-4 w-full mb-2" />
                        <Skeleton className="h-4 w-3/4 mb-4" />
                        <Skeleton className="h-9 w-full" />
                      </div>
                    )}
                  </CardContent>
                </Card>
              );
            })}
          </div>
        )}
      </div>

      {/* Image Zoom Modal */}
      {selectedImageUrl && (
        <ImageZoomModal
          imageUrl={selectedImageUrl}
          alt="VFX Concept Visualization"
          isOpen={!!selectedImageUrl}
          onClose={() => setSelectedImageUrl(null)}
        />
      )}
    </div>
  );
}


================================================
FILE: client/src/components/script/VideoPlayerModal.tsx
================================================
// client/src/components/script/VideoPlayerModal.tsx
import { VideoPlayerModalProps } from "@/lib/types";
import {
    Dialog,
    DialogContent,
    DialogHeader,
    DialogTitle,
    DialogFooter,
    DialogClose,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Download, X, Loader2, AlertTriangle, ExternalLink } from "lucide-react";
import { useState, useEffect, useRef } from "react";

export default function VideoPlayerModal({
    isOpen,
    onClose,
    videoUrl,
    title,
}: VideoPlayerModalProps) {
    const [isLoading, setIsLoading] = useState(true);
    const [hasError, setHasError] = useState(false);
    const [loadingTimeout, setLoadingTimeout] = useState<NodeJS.Timeout | null>(null);
    const videoRef = useRef<HTMLVideoElement>(null);
    
    // This ensures we don't get stuck in a loading state
    useEffect(() => {
        if (isOpen && videoUrl && isLoading) {
            // Set a fallback timeout to stop showing the loading spinner after 10 seconds
            // This helps if the onCanPlay event doesn't fire on some mobile devices
            const timeout = setTimeout(() => {
                setIsLoading(false);
            }, 10000);
            
            setLoadingTimeout(timeout);
            
            return () => {
                if (timeout) clearTimeout(timeout);
            };
        }
    }, [isOpen, videoUrl, isLoading]);
    
    // Cleanup timeout when component unmounts
    useEffect(() => {
        return () => {
            if (loadingTimeout) clearTimeout(loadingTimeout);
        };
    }, [loadingTimeout]);

    const handleCanPlay = () => {
        if (loadingTimeout) clearTimeout(loadingTimeout);
        setIsLoading(false);
        setHasError(false);
    };

    const handleError = () => {
        if (loadingTimeout) clearTimeout(loadingTimeout);
        setIsLoading(false);
        setHasError(true);
        console.error("Video error occurred for URL:", videoUrl);
    };
    
    // Handle click on video container to attempt play (helps on iOS)
    const handleContainerClick = () => {
        if (videoRef.current && isLoading) {
            try {
                videoRef.current.play().catch(err => {
                    console.log("Auto-play failed, user interaction required:", err);
                });
            } catch (err) {
                console.log("Error attempting to play video:", err);
            }
        }
    };

    const handleDownload = async () => {
        if (videoUrl) {
            try {
                // For mobile, open in a new tab instead of trying to download directly
                if (/Android|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent)) {
                    window.open(videoUrl, "_blank");
                    return;
                }
                
                // Desktop download logic
                const response = await fetch(videoUrl);
                const blob = await response.blob();
                
                // Create a blob URL and trigger download
                const blobUrl = URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.href = blobUrl;
                
                // Create filename from the scene title or use default
                const filename = `${title.replace(/[^a-z0-9]/gi, "_")}_video.mp4`;
                link.download = filename;
                
                // Append to body, click, then clean up
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Release the blob URL
                setTimeout(() => URL.revokeObjectURL(blobUrl), 100);
            } catch (error) {
                console.error("Error downloading video:", error);
                // Fallback to direct link if fetch fails
                window.open(videoUrl, "_blank");
            }
        }
    };
    
    // Open in a new tab for better mobile compatibility
    const handleOpenInNewTab = () => {
        if (videoUrl) {
            window.open(videoUrl, "_blank");
        }
    };

    // Reset loading/error state when modal opens with a new URL
    useEffect(() => {
        if (isOpen) {
            setIsLoading(true);
            setHasError(false);
        }
    }, [isOpen, videoUrl]); // Depend on videoUrl as well to reset if it changes while open

    return (
        <Dialog
            open={isOpen}
            onOpenChange={(open) => {
                if (!open) onClose();
            }}
        >
            <DialogContent className="sm:max-w-3xl max-h-[90vh] flex flex-col w-[95vw] p-3 sm:p-6">
                <DialogHeader>
                    <DialogTitle className="text-base sm:text-lg">
                        {title || "Generated Video"}
                    </DialogTitle>
                </DialogHeader>

                <div 
                    className="flex-grow flex items-center justify-center bg-black rounded-md overflow-hidden relative min-h-[200px] sm:min-h-[300px] my-2"
                    onClick={handleContainerClick}
                >
                    {isLoading && !hasError && videoUrl && (
                        <div className="absolute inset-0 flex flex-col items-center justify-center text-white">
                            <Loader2 className="h-6 w-6 sm:h-8 sm:w-8 animate-spin mb-2" />
                            <p className="text-sm sm:text-base">
                                Loading video...
                            </p>
                            <Button
                                variant="link"
                                className="text-blue-400 mt-2 text-xs sm:text-sm"
                                onClick={(e) => {
                                    e.stopPropagation();
                                    handleOpenInNewTab();
                                }}
                            >
                                Open directly in browser <ExternalLink className="h-3 w-3 ml-1" />
                            </Button>
                        </div>
                    )}
                    {hasError && videoUrl && (
                        <div className="absolute inset-0 flex flex-col items-center justify-center text-red-400 p-4 text-center">
                            <AlertTriangle className="h-6 w-6 sm:h-8 sm:w-8 mb-2" />
                            <p className="text-sm sm:text-base">
                                Error loading video.
                            </p>
                            <p className="text-xs sm:text-sm mb-2">
                                Please try opening the video directly in your browser.
                            </p>
                            <Button
                                variant="outline" 
                                size="sm"
                                onClick={(e) => {
                                    e.stopPropagation();
                                    handleOpenInNewTab();
                                }}
                                className="bg-zinc-800 text-white border-zinc-700 hover:bg-zinc-700"
                            >
                                <ExternalLink className="h-3 w-3 mr-1" /> Open in new tab
                            </Button>
                        </div>
                    )}
                    {videoUrl && (
                        <video
                            ref={videoRef}
                            key={videoUrl} // Force re-render if URL changes
                            controls
                            playsInline
                            webkit-playsinline="true" // For older iOS
                            controlsList="nodownload"
                            className={`w-full h-auto max-h-[60vh] object-contain ${isLoading || hasError ? "hidden" : "block"}`}
                            onCanPlay={handleCanPlay}
                            onLoadedData={handleCanPlay} // Additional event to catch more load states
                            onError={handleError}
                            preload="auto" // Changed from metadata to auto for better mobile loading
                            autoPlay
                            muted // Muted to help with autoplay policies on mobile
                        >
                            <source src={videoUrl} type="video/mp4" />
                            Your browser does not support the video tag.
                        </video>
                    )}
                    {!videoUrl && (
                        <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400">
                            <p className="text-sm sm:text-base">
                                No video URL provided.
                            </p>
                        </div>
                    )}
                </div>

                <DialogFooter className="pt-2 sm:pt-4 flex flex-col sm:flex-row gap-2 sm:gap-0 sm:justify-end">
                    <Button
                        variant="default"
                        onClick={handleDownload}
                        disabled={!videoUrl || isLoading || hasError}
                        className="flex items-center justify-center w-full sm:w-auto"
                    >
                        <Download className="mr-1 h-4 w-4" />
                        Download Video
                    </Button>
                    <Button
                        variant="secondary"
                        onClick={handleOpenInNewTab}
                        disabled={!videoUrl}
                        className="flex items-center justify-center w-full sm:w-auto sm:ml-2"
                    >
                        <ExternalLink className="mr-1 h-4 w-4" />
                        Open in Browser
                    </Button>
                    <DialogClose asChild>
                        <Button
                            type="button"
                            variant="outline"
                            className="w-full sm:w-auto sm:ml-2"
                        >
                            Close
                        </Button>
                    </DialogClose>
                </DialogFooter>
            </DialogContent>
        </Dialog>
    );
}



================================================
FILE: client/src/components/ui/accordion.tsx
================================================
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }



================================================
FILE: client/src/components/ui/alert-dialog.tsx
================================================
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}



================================================
FILE: client/src/components/ui/alert.tsx
================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }



================================================
FILE: client/src/components/ui/aspect-ratio.tsx
================================================
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }



================================================
FILE: client/src/components/ui/avatar.tsx
================================================
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }



================================================
FILE: client/src/components/ui/badge.tsx
================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }



================================================
FILE: client/src/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }



================================================
FILE: client/src/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }



================================================
FILE: client/src/components/ui/chart.tsx
================================================
import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item.dataKey || item.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}



================================================
FILE: client/src/components/ui/checkbox.tsx
================================================
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }



================================================
FILE: client/src/components/ui/dialog.tsx
================================================
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}



================================================
FILE: client/src/components/ui/dropdown-menu.tsx
================================================
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}



================================================
FILE: client/src/components/ui/form.tsx
================================================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}



================================================
FILE: client/src/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }



================================================
FILE: client/src/components/ui/label.tsx
================================================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }



================================================
FILE: client/src/components/ui/popover.tsx
================================================
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }



================================================
FILE: client/src/components/ui/progress.tsx
================================================
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }



================================================
FILE: client/src/components/ui/scroll-area.tsx
================================================
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }



================================================
FILE: client/src/components/ui/select.tsx
================================================
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}



================================================
FILE: client/src/components/ui/separator.tsx
================================================
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }



================================================
FILE: client/src/components/ui/sheet.tsx
================================================
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}



================================================
FILE: client/src/components/ui/sidebar.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { Sheet, SheetContent } from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar:state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContext | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        if (setOpenProp) {
          return setOpenProp?.(
            typeof value === "function" ? value(open) : value
          )
        }

        _setOpen(value)

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${open}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full text-sidebar-foreground has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("rounded-md h-8 flex gap-2 px-2 items-center", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 flex-1 max-w-[--skeleton-width]"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}



================================================
FILE: client/src/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
FILE: client/src/components/ui/slider.tsx
================================================
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }



================================================
FILE: client/src/components/ui/switch.tsx
================================================
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }



================================================
FILE: client/src/components/ui/table.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}



================================================
FILE: client/src/components/ui/tabs.tsx
================================================
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
FILE: client/src/components/ui/textarea.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }



================================================
FILE: client/src/components/ui/toast.tsx
================================================
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}



================================================
FILE: client/src/components/ui/toaster.tsx
================================================
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}



================================================
FILE: client/src/components/ui/toggle-group.tsx
================================================
import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }



================================================
FILE: client/src/components/ui/toggle.tsx
================================================
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }



================================================
FILE: client/src/components/ui/tooltip.tsx
================================================
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }



================================================
FILE: client/src/hooks/use-mobile.tsx
================================================
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined,
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}



================================================
FILE: client/src/hooks/use-toast.ts
================================================
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }



================================================
FILE: client/src/lib/queryClient.ts
================================================
import { QueryClient, QueryFunction } from "@tanstack/react-query";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    const text = (await res.text()) || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}

export async function apiRequest(
  method: string,
  url: string,
  data?: unknown | undefined,
  options?: RequestInit,
): Promise<Response> {
  const res = await fetch(url, {
    method,
    headers: data ? { "Content-Type": "application/json" } : {},
    body: data ? JSON.stringify(data) : undefined,
    credentials: "include",
    ...options, // Allow passing additional fetch options
  });

  // Don't check response status if we're handling it in the caller (like for the script generator)
  if (options?.signal) {
    return res;
  }

  await throwIfResNotOk(res);
  return res;
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    // Handle array query keys by building URL with params
    let url = queryKey[0] as string;
    let params = new URLSearchParams();
    
    // If queryKey has more than one element, treat the second element as a parameter
    if (Array.isArray(queryKey) && queryKey.length > 1) {
      const paramsObj = queryKey[1];
      
      // Handle specific routes that use simple ID parameters
      if (url.includes('scene-variations') && typeof paramsObj === 'number') {
        params.append('sceneId', String(paramsObj));
      } 
      // Handle parameter objects for search and filtering
      else if (typeof paramsObj === 'object' && paramsObj !== null) {
        Object.entries(paramsObj).forEach(([key, value]) => {
          if (value !== undefined && value !== null && value !== '') {
            params.append(key, String(value));
          }
        });
      }
    }
    
    // Add params to URL if any exist
    const finalUrl = params.toString() ? `${url}?${params.toString()}` : url;
    
    const res = await fetch(finalUrl, {
      credentials: "include",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: Infinity,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});



================================================
FILE: client/src/lib/types.ts
================================================
// client/src/lib/types.ts
import { z } from "zod";
import {
  Product as DbProduct,
  ProductCategory as DbProductCategoryEnumMap,
  Script as DbScriptType, // Renamed from DbScript to avoid conflict
  Scene as DbScene,
  SceneVariation as DbSceneVariation,
  Actor as DbActor,
  Location as DbLocation,
  FilmRatingEnum,
  FilmRatingType,
  DemographicGenderEnum,
  DemographicGenderType,
  DemographicAgeEnum,
  DemographicAgeType,
  GenreEnum,
  GenreType,
  scriptGenerationFormSchema as dbScriptGenerationFormSchema, // Import the Zod schema
} from "@shared/schema";
import { ControversyLevel as ServerControversyLevel } from "../../../server/services/ai-suggestion-service"; // Import from server types

export type Product = DbProduct;
export type ProductCategory = keyof typeof DbProductCategoryEnumMap;
export type Script = DbScriptType;
export type Scene = DbScene;
export type Actor = DbActor;
export type Location = DbLocation;

export type SceneVariation = DbSceneVariation & {
  productName?: string;
  productCategory?: ProductCategory;
  productImageUrl?: string | null;
  videoStatus?: "idle" | "pending" | "generating" | "succeeded" | "failed";
  videoUrl?: string | null;
  videoError?: string | null;
  predictionId?: string | null;
  progress?: number;
  stageMessage?: string;
};

export type TabType =
  | "welcome"
  | "script"
  | "products"
  | "actors"
  | "script-writer" // Added new tab type
  | "locations";
export type FileUploadProps = {
  onFileUpload: (file: File) => Promise<void>;
  isLoading: boolean;
};
export type HeaderProps = {
  activeTab: TabType;
  onTabChange: (tab: TabType) => void;
};

export type ScriptDisplayProps = {
  script: { id: number; title: string; content: string } | null;
  isLoading: boolean;
  onSave: () => Promise<void>;
  onReanalyze: () => Promise<void>;
  onAnalyzeVfx?: () => Promise<void>;
  onGeneratePlacements?: () => Promise<void>;
  onExport?: () => Promise<void>;
  activeScene: Scene | null;
  isSaving?: boolean;
  isReanalyzing?: boolean;
  isAnalyzingVfx?: boolean;
  isGenerating?: boolean;
  isExporting?: boolean;
};

export type BrandableScenesProps = {
  activeSceneDetails: Scene | null | undefined;
  scenes: Scene[];
  projectTitle?: string; // Added projectTitle
  productVariations: SceneVariation[];
  isLoading: boolean;
  selectedSceneId: number | null;
  onGenerateVideoRequest: (variationId: number) => void;
  videoGenerationStates: {
    [key: number]: {
      status: "idle" | "pending" | "generating" | "succeeded" | "failed";
      videoUrl?: string | null;
      error?: string | null;
      progress?: number;
      stageMessage?: string;
    };
  };
  onViewVideo: (videoUrl: string, title: string) => void;
  onImageZoom: (imageUrl: string, title: string) => void; // Added for image zoom
  selectedProducts?: SceneVariation[];
  onProductSelect?: (product: SceneVariation) => void;
};

export type SceneBreakdownProps = {
  scenes: Scene[];
  activeSceneId: number | null;
  projectTitle?: string; // Added projectTitle
  brandableSceneIds: number[];
  isLoading: boolean;
  onSceneSelect: (sceneId: number) => void;
};

export type ProductCardProps = {
  product: Product;
  onEdit: (product: Product) => void;
  onDelete: (product: Product) => void;
};

export const productFormSchema = z.object({
  companyName: z.string().min(2, "Company name must be at least 2 characters"),
  name: z.string().min(2, "Product name must be at least 2 characters"),
  category: z.enum(
    Object.keys(DbProductCategoryEnumMap) as [
      ProductCategory,
      ...ProductCategory[],
    ],
  ),
  filmRating: z.nativeEnum(FilmRatingEnum).optional().nullable(),
  demographicGender: z.nativeEnum(DemographicGenderEnum).optional().nullable(),
  demographicAge: z
    .array(z.nativeEnum(DemographicAgeEnum))
    .default([])
    .optional()
    .nullable(),
  genre: z.nativeEnum(GenreEnum).optional().nullable(),
  imageUrl: z.string().url("Please enter a valid URL"),
  placementLimitations: z.string().optional().nullable(), // Added here
});
export type ProductFormData = z.infer<typeof productFormSchema>;

export type AddProductModalProps = {
  isOpen: boolean;
  onClose: () => void;
  onAdd: (product: ProductFormData) => Promise<void>;
  isSubmitting: boolean;
};
export type EditProductModalProps = {
  isOpen: boolean;
  product: Product | null;
  onClose: () => void;
  onEdit: (id: number, product: ProductFormData) => Promise<void>;
  isSubmitting: boolean;
};
export type DeleteProductDialogProps = {
  isOpen: boolean;
  product: Product | null;
  onClose: () => void;
  onDelete: (id: number) => Promise<void>;
  isDeleting: boolean;
};
export type ActorFormData = {
  name: string;
  gender: string;
  nationality: string;
  notableRoles: string;
  genres: string;
  recentPopularity: string;
  typicalRoles: string;
  estSalaryRange: string;
  socialMediaFollowing: string;
  availability: string;
  bestSuitedRolesStrategic: string;
  dateOfBirth: string;
  imageUrl: string;
};
export const actorFormSchema = z.object({
  name: z.string().min(2),
  gender: z.string().min(1),
  nationality: z.string().min(2),
  notableRoles: z.string(),
  genres: z.string(),
  recentPopularity: z.string().min(1),
  typicalRoles: z.string(),
  estSalaryRange: z.string().min(1),
  socialMediaFollowing: z.string().min(1),
  availability: z.string().min(1),
  bestSuitedRolesStrategic: z.string().min(1),
  dateOfBirth: z.string().optional(),
  imageUrl: z.string().url().or(z.string().length(0).optional()),
});
export type EditActorModalProps = {
  isOpen: boolean;
  actor: Actor | null;
  onClose: () => void;
  onEdit: (id: number, actor: ActorFormData) => Promise<void>;
  isSubmitting: boolean;
};
export type LocationFormData = {
  country: string;
  region: string;
  incentiveProgram: string;
  incentiveDetails: string;
  minimumSpend: string;
  eligibleProductionTypes: string;
  limitsCaps: string;
  qualifyingExpenses: string;
  applicationProcess: string;
  applicationDeadlines: string;
  imageUrl: string;
};
export const locationFormSchema = z.object({
  country: z.string().min(2),
  region: z.string().min(2),
  incentiveProgram: z.string().min(2),
  incentiveDetails: z.string().min(2),
  minimumSpend: z.string().min(1),
  eligibleProductionTypes: z.string().min(1),
  limitsCaps: z.string().optional(),
  qualifyingExpenses: z.string().optional(),
  applicationProcess: z.string().optional(),
  applicationDeadlines: z.string().optional(),
  imageUrl: z.string().url().or(z.string().length(0).optional()),
});
export type AddLocationModalProps = {
  isOpen: boolean;
  onClose: () => void;
  onAdd: (location: LocationFormData) => Promise<void>;
  isSubmitting: boolean;
};
export type EditLocationModalProps = {
  isOpen: boolean;
  location: Location | null;
  onClose: () => void;
  onEdit: (id: number, location: LocationFormData) => Promise<void>;
  isSubmitting: boolean;
};
export type DeleteLocationDialogProps = {
  isOpen: boolean;
  location: Location | null;
  onClose: () => void;
  onDelete: (id: number) => Promise<void>;
  isDeleting: boolean;
};
export type AIAnalysisResponse = {
  brandableScenes: {
    sceneId: number;
    reason: string;
    suggestedProducts: ProductCategory[];
  }[];
};
export type VideoPlayerModalProps = {
  isOpen: boolean;
  onClose: () => void;
  videoUrl: string | null;
  title: string;
};

export type ImageZoomModalProps = {
  // Ensure this matches the component's usage
  isOpen: boolean;
  onClose: () => void;
  imageUrl: string | null;
  title: string;
};

export interface ClientSuggestedLocation extends Location {
  // Changed from SuggestedLocation to ClientSuggestedLocation
  estimatedIncentiveValue?: string; // This was previously estimatedIncentiveNotes from server
  matchReason?: string;
  confidenceScore?: number;
}

export interface SuggestedLocationsProps {
  scriptId: number | null; // Changed from activeScene: Scene | null
  projectBudget?: number;
  isLoading: boolean;
  selectedLocations?: ClientSuggestedLocation[];
  onLocationSelect?: (location: ClientSuggestedLocation) => void;
}

export interface ScriptCharacter {
  name: string;
  estimatedAgeRange?: string;
  actorId?: number;
  actorName?: string;
}

export type ControversyLevel = ServerControversyLevel; // Use the type from the server

export interface ActorSuggestion extends Actor {
  matchReason?: string;
  controversyLevel?: ControversyLevel;
}
export interface CharacterCastingProps {
  scriptId: number | null;
  isLoading: boolean;
  filmGenre?: string;
  projectBudgetTier?: "low" | "medium" | "high" | "any";
  selectedCharacters?: ScriptCharacter[];
  onCharacterSelect?: (character: ScriptCharacter) => void;
}
export interface ActorSuggestionCardProps {
  actor: ActorSuggestion;
  onSelect?: (character: ScriptCharacter) => void;
  isSelected?: boolean;
  characterName?: string;
}
export type ScriptEditorProps = {};

// --- BEGIN MODIFICATION (Task 1.4) ---
export interface FinancialLineItem {
  account: string;
  description: string;
  total: number | null;
}

export interface AboveTheLineFinancials { // Renamed to avoid conflict if backend types were directly imported
  storyRights: FinancialLineItem;
  producer: FinancialLineItem;
  director: FinancialLineItem;
  castAndStunts: FinancialLineItem;
  fringes: FinancialLineItem;
  total: number | null;
}

export interface BelowTheLineProductionFinancials {
  productionStaff: FinancialLineItem;
  extrasStandins: FinancialLineItem;
  setDesign: FinancialLineItem;
  setConstruction: FinancialLineItem;
  setOperations: FinancialLineItem;
  specialEffects: FinancialLineItem;
  setDressing: FinancialLineItem;
  props: FinancialLineItem;
  wardrobe: FinancialLineItem;
  ledVirtual: FinancialLineItem;
  makeupHairdressing: FinancialLineItem;
  setLighting: FinancialLineItem;
  camera: FinancialLineItem;
  productionSound: FinancialLineItem;
  transportation: FinancialLineItem;
  locationExpenses: FinancialLineItem;
  pictureVehiclesAnimals: FinancialLineItem;
  productionFilmLab: FinancialLineItem;
  miscProduction: FinancialLineItem;
  healthSafety: FinancialLineItem;
  overtime: FinancialLineItem;
  studioEquipmentFacilities: FinancialLineItem;
  tests: FinancialLineItem;
  btlTravelLiving: FinancialLineItem;
  serviceCompany: FinancialLineItem;
  fringes: FinancialLineItem;
  total: number | null;
}

export interface PostProductionFinancials {
  filmEditing: FinancialLineItem;
  music: FinancialLineItem;
  sound: FinancialLineItem;
  filmLabPost: FinancialLineItem;
  titles: FinancialLineItem;
  vfx: FinancialLineItem;
  fringes: FinancialLineItem;
  total: number | null;
}

export interface OtherBelowTheLineFinancials {
  publicity: FinancialLineItem;
  insurance: FinancialLineItem;
  miscExpenses: FinancialLineItem;
  legalAccounting: FinancialLineItem;
  fringes: FinancialLineItem;
  total: number | null;
}

export interface FinancialBreakdown {
  projectName: string | null;
  expectedReleaseDate: string | null;
  location: string | null;
  prepWeeks: number | null;
  shootDays: string | null;
  unions: string | null;

  aboveTheLine: AboveTheLineFinancials;
  belowTheLineProduction: BelowTheLineProductionFinancials;
  postProduction: PostProductionFinancials;
  otherBelowTheLine: OtherBelowTheLineFinancials;

  bondFee: FinancialLineItem;
  contingency: FinancialLineItem;

  summaryTotalAboveTheLine: number | null;
  summaryTotalBelowTheLine: number | null;
  summaryTotalAboveAndBelowTheLine: number | null;
  summaryGrandTotal: number | null;

  totalBudgetInput: number | null;
  estimatedBrandSponsorshipValue: number | null;
  estimatedLocationIncentiveValue: number | null;
  netExternalCapitalRequired: number | null;
}

export interface FinancialAnalysisModalProps {
    isOpen: boolean;
    onClose: () => void;
    scriptId: number | null; // To fetch data
    scriptTitle?: string;
}

// --- END MODIFICATION (Task 1.4) ---


// --- Script Writer Page Types ---
export type ScriptGenerationFormData = z.infer<
  typeof dbScriptGenerationFormSchema
>;



================================================
FILE: client/src/lib/utils.ts
================================================
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

export function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength) + '...';
}

export function getFileExtension(filename: string): string {
  return filename.slice(((filename.lastIndexOf(".") - 1) >>> 0) + 2);
}

export function validatePdfFile(file: File): boolean {
  const validExtensions = ['pdf', 'jpg', 'jpeg', 'png'];
  const fileExtension = getFileExtension(file.name).toLowerCase();
  
  if (!validExtensions.includes(fileExtension)) {
    return false;
  }
  
  // 10MB max size
  const maxSize = 10 * 1024 * 1024;
  if (file.size > maxSize) {
    return false;
  }
  
  return true;
}

export function isImageUrl(url: string): boolean {
  const extensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg', '.bmp'];
  const lowercasedUrl = url.toLowerCase();
  return extensions.some(ext => lowercasedUrl.endsWith(ext));
}

export function extractSceneLocation(sceneHeader: string): string {
  // Common scene header patterns: "INT. LOCATION - TIME" or "EXT. LOCATION - TIME"
  const match = sceneHeader.match(/(?:INT\.|EXT\.)\s+([^-\n]+)(?:\s*-\s*(.+))?/i);
  if (match) {
    const location = match[1].trim();
    const time = match[2]?.trim() || '';
    return time ? `${location} - ${time}` : location;
  }
  return sceneHeader; // Fallback to returning the original text
}

export function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export function isValidUrl(url: string): boolean {
  try {
    // Check if the input is a valid URL by creating a URL object
    new URL(url);
    return true;
  } catch (e) {
    return false;
  }
}

export function getSafeImageUrl(url: string, fallbackUrl: string = "https://placehold.co/600x400/gray/white?text=Image+Unavailable"): string {
  if (!url || typeof url !== 'string') {
    return fallbackUrl;
  }
  
  try {
    // Check if the URL is valid
    new URL(url);
    return url;
  } catch (error) {
    console.error("Invalid image URL:", url);
    return fallbackUrl;
  }
}



================================================
FILE: client/src/pages/ActorsDatabase.tsx
================================================
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Actor, ActorFormData } from "@/lib/types";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { 
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue, 
} from "@/components/ui/select";
import { toast } from "@/hooks/use-toast";
import { Edit, Pencil } from "lucide-react";
import EditActorModal from "@/components/actors/EditActorModal";
import { apiRequest } from "@/lib/queryClient";

// Function to calculate age from date of birth
function calculateAge(dob: string): number | string {
  if (!dob) return "-";
  
  try {
    const birthDate = new Date(dob);
    
    // Validate the date is valid
    if (isNaN(birthDate.getTime())) {
      return "-";
    }
    
    const today = new Date();
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    
    // Adjust age if birthday hasn't occurred yet this year
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      age--;
    }
    
    return age;
  } catch (error) {
    console.error("Error calculating age:", error);
    return "-";
  }
}

export default function ActorsDatabase() {
  const [search, setSearch] = useState("");
  const [gender, setGender] = useState("all");
  const [nationality, setNationality] = useState("all");
  const [page, setPage] = useState(1);
  const pageSize = 10;
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [selectedActor, setSelectedActor] = useState<Actor | null>(null);
  const queryClient = useQueryClient();

  // Query to fetch actors with filtering and pagination
  const { data, isLoading, error } = useQuery({
    queryKey: ['/api/actors', search, gender, nationality, page],
    queryFn: async () => {
      const queryParams = new URLSearchParams();
      if (search) queryParams.append('search', search);
      if (gender && gender !== 'all') queryParams.append('gender', gender);
      if (nationality && nationality !== 'all') queryParams.append('nationality', nationality);
      queryParams.append('page', page.toString());
      queryParams.append('pageSize', pageSize.toString());
      
      const response = await fetch(`/api/actors?${queryParams.toString()}`);
      if (!response.ok) {
        throw new Error('Failed to fetch actors');
      }
      return response.json();
    }
  });

  // Handle errors
  if (error) {
    toast({
      title: "Error",
      description: `Failed to load actors: ${(error as Error).message}`,
      variant: "destructive"
    });
  }

  // Handle search form submission
  const handleSearchSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    setPage(1); // Reset to first page when search changes
  };

  // Handle pagination
  const handlePreviousPage = () => {
    if (page > 1) {
      setPage(page - 1);
    }
  };

  const handleNextPage = () => {
    if (data && page < data.totalPages) {
      setPage(page + 1);
    }
  };
  
  // Open edit modal with selected actor
  const openEditModal = (actor: Actor) => {
    setSelectedActor(actor);
    setIsEditModalOpen(true);
  };
  
  // Edit actor mutation
  const editActorMutation = useMutation({
    mutationFn: async ({ id, data }: { id: number, data: ActorFormData }) => {
      return await apiRequest('PUT', `/api/actors/${id}`, data);
    },
    onSuccess: () => {
      toast({
        title: "Actor updated",
        description: "The actor information has been updated successfully.",
      });
      setIsEditModalOpen(false);
      queryClient.invalidateQueries({ 
        queryKey: ['/api/actors', search, gender, nationality, page] 
      });
    },
    onError: (error: Error) => {
      toast({
        variant: "destructive",
        title: "Failed to update actor",
        description: error.message || "There was an error updating the actor.",
      });
    },
  });
  
  // Handle actor edit
  const handleEditActor = async (id: number, data: ActorFormData) => {
    await editActorMutation.mutate({ id, data });
  };

  return (
    <div className="p-4">
      <h1 className="text-3xl font-bold mb-6">Actors Database</h1>
      
      {/* Search and filter form */}
      <form onSubmit={handleSearchSubmit} className="mb-6 flex flex-wrap gap-4">
        <div className="flex-1 min-w-[200px]">
          <Input
            placeholder="Search by name..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
          />
        </div>
        
        <div className="w-[150px]">
          <Select value={gender} onValueChange={setGender}>
            <SelectTrigger>
              <SelectValue placeholder="Gender" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Genders</SelectItem>
              <SelectItem value="Male">Male</SelectItem>
              <SelectItem value="Female">Female</SelectItem>
              <SelectItem value="Non-Binary">Non-Binary</SelectItem>
            </SelectContent>
          </Select>
        </div>
        
        <div className="w-[250px]">
          <Select value={nationality} onValueChange={setNationality}>
            <SelectTrigger>
              <SelectValue placeholder="Nationality" />
            </SelectTrigger>
            <SelectContent className="max-h-[300px]">
              <SelectItem value="all">All Nationalities</SelectItem>
              <SelectItem value="American">American</SelectItem>
              <SelectItem value="American (Born Italy)">American (Born Italy)</SelectItem>
              <SelectItem value="American (Born Puerto Rico)">American (Born Puerto Rico)</SelectItem>
              <SelectItem value="American (Dual Italian)">American (Dual Italian)</SelectItem>
              <SelectItem value="American (Puerto Rican descent)">American (Puerto Rican descent)</SelectItem>
              <SelectItem value="American-Australian">American-Australian</SelectItem>
              <SelectItem value="American-British">American-British</SelectItem>
              <SelectItem value="American-British-Argentine">American-British-Argentine</SelectItem>
              <SelectItem value="American-Danish">American-Danish</SelectItem>
              <SelectItem value="American-French">American-French</SelectItem>
              <SelectItem value="American-Israeli">American-Israeli</SelectItem>
              <SelectItem value="Argentine">Argentine</SelectItem>
              <SelectItem value="Australian">Australian</SelectItem>
              <SelectItem value="Australian (Born NZ)">Australian (Born NZ)</SelectItem>
              <SelectItem value="Australian-American">Australian-American</SelectItem>
              <SelectItem value="Austrian-American">Austrian-American</SelectItem>
              <SelectItem value="Belgian">Belgian</SelectItem>
              <SelectItem value="Brazilian">Brazilian</SelectItem>
              <SelectItem value="British">British</SelectItem>
              <SelectItem value="British (Born Germany)">British (Born Germany)</SelectItem>
              <SelectItem value="British (Born Ireland)">British (Born Ireland)</SelectItem>
              <SelectItem value="British (Dual French)">British (Dual French)</SelectItem>
              <SelectItem value="British (Scottish)">British (Scottish)</SelectItem>
              <SelectItem value="British (Welsh)">British (Welsh)</SelectItem>
              <SelectItem value="British-American">British-American</SelectItem>
              <SelectItem value="British-Australian">British-Australian</SelectItem>
              <SelectItem value="British-Pakistani">British-Pakistani</SelectItem>
              <SelectItem value="Canadian">Canadian</SelectItem>
              <SelectItem value="Canadian (Born UK)">Canadian (Born UK)</SelectItem>
              <SelectItem value="Canadian-American">Canadian-American</SelectItem>
              <SelectItem value="Canadian-New Zealander">Canadian-New Zealander</SelectItem>
              <SelectItem value="Chilean-American">Chilean-American</SelectItem>
              <SelectItem value="Chinese">Chinese</SelectItem>
              <SelectItem value="Chinese (Singaporean citizen)">Chinese (Singaporean citizen)</SelectItem>
              <SelectItem value="Colombian-American">Colombian-American</SelectItem>
              <SelectItem value="Cuban-American">Cuban-American</SelectItem>
              <SelectItem value="Danish">Danish</SelectItem>
              <SelectItem value="Dutch">Dutch</SelectItem>
              <SelectItem value="French">French</SelectItem>
              <SelectItem value="French (Born Morocco)">French (Born Morocco)</SelectItem>
              <SelectItem value="French-Argentine">French-Argentine</SelectItem>
              <SelectItem value="German">German</SelectItem>
              <SelectItem value="German-Austrian">German-Austrian</SelectItem>
              <SelectItem value="German-Irish">German-Irish</SelectItem>
              <SelectItem value="German-Spanish">German-Spanish</SelectItem>
              <SelectItem value="Guatemalan-American">Guatemalan-American</SelectItem>
              <SelectItem value="Hong Kong">Hong Kong</SelectItem>
              <SelectItem value="Indian">Indian</SelectItem>
              <SelectItem value="Irish">Irish</SelectItem>
              <SelectItem value="Irish (Dual American)">Irish (Dual American)</SelectItem>
              <SelectItem value="Irish-American">Irish-American</SelectItem>
              <SelectItem value="Italian">Italian</SelectItem>
              <SelectItem value="Italian (Born Tunisia)">Italian (Born Tunisia)</SelectItem>
              <SelectItem value="Italian-American">Italian-American</SelectItem>
              <SelectItem value="Japanese">Japanese</SelectItem>
              <SelectItem value="Japanese-American">Japanese-American</SelectItem>
              <SelectItem value="Kenyan-Mexican">Kenyan-Mexican</SelectItem>
              <SelectItem value="Korean-American">Korean-American</SelectItem>
              <SelectItem value="Malaysian">Malaysian</SelectItem>
              <SelectItem value="Malaysian-British">Malaysian-British</SelectItem>
              <SelectItem value="Mexican">Mexican</SelectItem>
              <SelectItem value="Mexican-American">Mexican-American</SelectItem>
              <SelectItem value="New Zealander">New Zealander</SelectItem>
              <SelectItem value="New Zealander (Born Northern Ireland)">New Zealander (Born Northern Ireland)</SelectItem>
              <SelectItem value="New Zealander-Australian">New Zealander-Australian</SelectItem>
              <SelectItem value="Northern Irish">Northern Irish</SelectItem>
              <SelectItem value="Pakistani-American">Pakistani-American</SelectItem>
              <SelectItem value="Puerto Rican">Puerto Rican</SelectItem>
              <SelectItem value="Romanian-American">Romanian-American</SelectItem>
              <SelectItem value="Scottish">Scottish</SelectItem>
              <SelectItem value="South African-American">South African-American</SelectItem>
              <SelectItem value="South Korean">South Korean</SelectItem>
              <SelectItem value="Spanish">Spanish</SelectItem>
              <SelectItem value="Swedish">Swedish</SelectItem>
              <SelectItem value="Swedish-American">Swedish-American</SelectItem>
              <SelectItem value="Welsh">Welsh</SelectItem>
              <SelectItem value="Welsh (Dual American)">Welsh (Dual American)</SelectItem>
            </SelectContent>
          </Select>
        </div>
        
        <Button type="submit">Search</Button>
      </form>

      {/* Loading state */}
      {isLoading && (
        <div className="text-center py-10">
          <p className="text-gray-500">Loading actors...</p>
        </div>
      )}

      {/* Actors table */}
      {!isLoading && data?.actors && data.actors.length > 0 && (
        <>
          <div className="overflow-x-auto bg-white shadow-md rounded-lg">
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Image
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Name
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Gender
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Nationality
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Date of Birth
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Age
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Notable Roles
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Genres
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Popularity
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Typical Roles
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Salary Range
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Social Following
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Availability
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Best Suited (Strategic)
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {data.actors.map((actor: Actor) => (
                  <tr key={actor.id || actor.name}>
                    <td className="px-6 py-4 whitespace-nowrap">
                      {actor.imageUrl ? (
                        <div className="h-20 w-16 rounded overflow-hidden">
                          <img
                            src={actor.imageUrl}
                            alt={`${actor.name}`}
                            className="h-full w-full object-cover"
                            onError={(e) => {
                              const target = e.target as HTMLImageElement;
                              target.src = "https://placehold.co/300x400/gray/white?text=No+Image";
                            }}
                          />
                        </div>
                      ) : (
                        <div className="h-20 w-16 bg-gray-200 flex items-center justify-center rounded">
                          <span className="text-gray-500 text-xs text-center">No Image</span>
                        </div>
                      )}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                      {actor.name}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {actor.gender}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {actor.nationality}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {actor.dateOfBirth || "-"}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {actor.dateOfBirth ? calculateAge(actor.dateOfBirth) : "-"}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-500">
                      {Array.isArray(actor.notableRoles) ? actor.notableRoles.join(", ") : actor.notableRoles}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-500">
                      {Array.isArray(actor.genres) ? actor.genres.join(", ") : actor.genres}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {actor.recentPopularity}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-500">
                      {Array.isArray(actor.typicalRoles) ? actor.typicalRoles.join(", ") : actor.typicalRoles}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {actor.estSalaryRange}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {actor.socialMediaFollowing}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {actor.availability}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-500">
                      {actor.bestSuitedRolesStrategic}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      <Button 
                        variant="outline" 
                        size="sm" 
                        onClick={() => openEditModal(actor)}
                        className="flex items-center"
                      >
                        <Edit className="h-3.5 w-3.5 mr-1" />
                        Edit
                      </Button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          {/* Pagination controls */}
          <div className="mt-4 flex justify-between items-center">
            <div className="text-sm text-gray-700">
              Showing <span className="font-medium">{((page - 1) * pageSize) + 1}</span> to{" "}
              <span className="font-medium">
                {Math.min(page * pageSize, data.totalCount)}
              </span>{" "}
              of <span className="font-medium">{data.totalCount}</span> actors
            </div>
            <div className="flex space-x-2">
              <Button 
                variant="outline" 
                onClick={handlePreviousPage} 
                disabled={page === 1}
              >
                Previous
              </Button>
              <Button 
                variant="outline" 
                onClick={handleNextPage} 
                disabled={page >= data.totalPages}
              >
                Next
              </Button>
            </div>
          </div>
        </>
      )}

      {/* No results state */}
      {!isLoading && data?.actors && data.actors.length === 0 && (
        <div className="text-center py-10 bg-gray-50 rounded-lg">
          <p className="text-gray-500">No actors found matching your criteria.</p>
        </div>
      )}

      {/* Edit Actor Modal */}
      <EditActorModal
        isOpen={isEditModalOpen}
        actor={selectedActor}
        onClose={() => setIsEditModalOpen(false)}
        onEdit={handleEditActor}
        isSubmitting={editActorMutation.isPending}
      />
    </div>
  );
}


================================================
FILE: client/src/pages/Contact.tsx
================================================
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { useToast } from "@/hooks/use-toast";
import { 
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle
} from "@/components/ui/card";
import { 
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage
} from "@/components/ui/form";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Mail, Phone, MapPin } from "lucide-react";

// Form validation schema
const contactFormSchema = z.object({
  name: z.string().min(2, {
    message: "Name must be at least 2 characters.",
  }),
  email: z.string().email({
    message: "Please enter a valid email address.",
  }),
  subject: z.string().min(5, {
    message: "Subject must be at least 5 characters.",
  }),
  message: z.string().min(10, {
    message: "Message must be at least 10 characters.",
  }),
});

type ContactFormValues = z.infer<typeof contactFormSchema>;

export default function Contact() {
  const { toast } = useToast();
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Initialize form
  const form = useForm<ContactFormValues>({
    resolver: zodResolver(contactFormSchema),
    defaultValues: {
      name: "",
      email: "",
      subject: "",
      message: ""
    },
  });

  // Form submission handler
  const onSubmit = async (data: ContactFormValues) => {
    setIsSubmitting(true);
    
    // Simulate API call
    setTimeout(() => {
      console.log(data);
      toast({
        title: "Message Sent",
        description: "Thank you for contacting us. We'll get back to you soon!",
      });
      form.reset();
      setIsSubmitting(false);
    }, 1500);
  };

  return (
    <div className="max-w-6xl mx-auto">
      <h1 className="text-3xl font-bold mb-8">Contact Us</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        {/* Contact Form */}
        <Card className="shadow-md">
          <CardHeader>
            <CardTitle>Send us a message</CardTitle>
            <CardDescription>Fill out the form below and we'll get back to you as soon as possible.</CardDescription>
          </CardHeader>
          <CardContent>
            <Form {...form}>
              <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
                <FormField
                  control={form.control}
                  name="name"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Your Name</FormLabel>
                      <FormControl>
                        <Input placeholder="John Doe" {...field} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                <FormField
                  control={form.control}
                  name="email"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Email Address</FormLabel>
                      <FormControl>
                        <Input placeholder="you@example.com" {...field} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                <FormField
                  control={form.control}
                  name="subject"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Subject</FormLabel>
                      <FormControl>
                        <Input placeholder="How can we help you?" {...field} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                <FormField
                  control={form.control}
                  name="message"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Message</FormLabel>
                      <FormControl>
                        <Textarea 
                          placeholder="Tell us more about your inquiry..." 
                          rows={5}
                          {...field} 
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                <Button 
                  type="submit" 
                  className="w-full" 
                  disabled={isSubmitting}
                >
                  {isSubmitting ? "Sending..." : "Send Message"}
                </Button>
              </form>
            </Form>
          </CardContent>
        </Card>
        
        {/* Contact Information */}
        <div className="flex flex-col space-y-6">
          <Card className="shadow-md">
            <CardHeader>
              <CardTitle>Contact Information</CardTitle>
              <CardDescription>Here are the ways you can reach us</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="flex items-start space-x-3">
                <Mail className="h-5 w-5 text-primary mt-0.5" />
                <div>
                  <h3 className="font-medium">Email</h3>
                  <p>contact@vadis-media.com</p>
                </div>
              </div>
              
              <div className="flex items-start space-x-3">
                <Phone className="h-5 w-5 text-primary mt-0.5" />
                <div>
                  <h3 className="font-medium">Phone</h3>
                  <p>+1 (555) 123-4567</p>
                  <p>Mon-Fri, 9AM to 6PM EST</p>
                </div>
              </div>
              
              <div className="flex items-start space-x-3">
                <MapPin className="h-5 w-5 text-primary mt-0.5" />
                <div>
                  <h3 className="font-medium">Office</h3>
                  <p>123 Studio Way</p>
                  <p>Los Angeles, CA 90012</p>
                  <p>United States</p>
                </div>
              </div>
            </CardContent>
          </Card>
          
          <Card className="shadow-md">
            <CardHeader>
              <CardTitle>Business Hours</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <div className="flex justify-between">
                  <span>Monday - Friday</span>
                  <span>9:00 AM - 6:00 PM EST</span>
                </div>
                <div className="flex justify-between">
                  <span>Saturday</span>
                  <span>10:00 AM - 4:00 PM EST</span>
                </div>
                <div className="flex justify-between">
                  <span>Sunday</span>
                  <span>Closed</span>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}


================================================
FILE: client/src/pages/LocationsDatabase.tsx
================================================
// import { useState } from "react";
// import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
// import { Location, LocationFormData } from "@/lib/types";
// import { Button } from "@/components/ui/button";
// import { Input } from "@/components/ui/input";
// import {
//   Select,
//   SelectContent,
//   SelectItem,
//   SelectTrigger,
//   SelectValue,
// } from "@/components/ui/select";
// import { toast } from "@/hooks/use-toast";
// import { Edit, Trash2, MapPin, Plus } from "lucide-react";
// import EditLocationModal from "@/components/locations/EditLocationModal";
// import AddLocationModal from "@/components/locations/AddLocationModal";
// import DeleteLocationDialog from "@/components/locations/DeleteLocationDialog";
// import { apiRequest } from "@/lib/queryClient";

// export default function LocationsDatabase() {
//   const [search, setSearch] = useState("");
//   const [country, setCountry] = useState("all");
//   const [page, setPage] = useState(1);
//   const pageSize = 10;
//   const [isAddModalOpen, setIsAddModalOpen] = useState(false);
//   const [isEditModalOpen, setIsEditModalOpen] = useState(false);
//   const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
//   const [selectedLocation, setSelectedLocation] = useState<Location | null>(null);
//   const queryClient = useQueryClient();

//   // Query to fetch locations with filtering and pagination
//   const { data, isLoading, error } = useQuery({
//     queryKey: ['/api/locations', search, country, page],
//     queryFn: async () => {
//       const queryParams = new URLSearchParams();
//       if (search) queryParams.append('search', search);
//       if (country && country !== 'all') queryParams.append('country', country);
//       queryParams.append('page', page.toString());
//       queryParams.append('pageSize', pageSize.toString());

//       const response = await fetch(`/api/locations?${queryParams.toString()}`);
//       if (!response.ok) {
//         throw new Error('Failed to fetch locations');
//       }
//       return response.json();
//     }
//   });

//   // Query available countries for the dropdown
//   const { data: countriesData } = useQuery({
//     queryKey: ['/api/locations/countries'],
//     queryFn: async () => {
//       // We'll just extract unique countries from the data we have
//       if (data?.locations) {
//         const uniqueCountries = Array.from(new Set(data.locations.map((loc: Location) => loc.country)));
//         return uniqueCountries.sort();
//       }
//       return [];
//     },
//     enabled: !!data?.locations
//   });

//   // Handle errors
//   if (error) {
//     toast({
//       title: "Error",
//       description: `Failed to load locations: ${(error as Error).message}`,
//       variant: "destructive"
//     });
//   }

//   // Add location mutation
//   const addLocationMutation = useMutation({
//     mutationFn: async (data: LocationFormData) => {
//       return await apiRequest('POST', '/api/locations', data);
//     },
//     onSuccess: () => {
//       toast({
//         title: "Location added",
//         description: "The location has been added successfully.",
//       });
//       setIsAddModalOpen(false);
//       queryClient.invalidateQueries({
//         queryKey: ['/api/locations']
//       });
//     },
//     onError: (error: Error) => {
//       toast({
//         variant: "destructive",
//         title: "Failed to add location",
//         description: error.message || "There was an error adding the location.",
//       });
//     },
//   });

//   // Edit location mutation
//   const editLocationMutation = useMutation({
//     mutationFn: async ({ id, data }: { id: number, data: LocationFormData }) => {
//       return await apiRequest('PUT', `/api/locations/${id}`, data);
//     },
//     onSuccess: () => {
//       toast({
//         title: "Location updated",
//         description: "The location information has been updated successfully.",
//       });
//       setIsEditModalOpen(false);
//       queryClient.invalidateQueries({
//         queryKey: ['/api/locations', search, country, page]
//       });
//     },
//     onError: (error: Error) => {
//       toast({
//         variant: "destructive",
//         title: "Failed to update location",
//         description: error.message || "There was an error updating the location.",
//       });
//     },
//   });

//   // Delete location mutation
//   const deleteLocationMutation = useMutation({
//     mutationFn: async (id: number) => {
//       return await apiRequest('DELETE', `/api/locations/${id}`);
//     },
//     onSuccess: () => {
//       toast({
//         title: "Location deleted",
//         description: "The location has been deleted successfully.",
//       });
//       setIsDeleteDialogOpen(false);
//       queryClient.invalidateQueries({
//         queryKey: ['/api/locations', search, country, page]
//       });
//     },
//     onError: (error: Error) => {
//       toast({
//         variant: "destructive",
//         title: "Failed to delete location",
//         description: error.message || "There was an error deleting the location.",
//       });
//     },
//   });

//   // Handle search form submission
//   const handleSearchSubmit = (e: React.FormEvent) => {
//     e.preventDefault();
//     setPage(1); // Reset to first page when search changes
//   };

//   // Handle pagination
//   const handlePreviousPage = () => {
//     if (page > 1) {
//       setPage(page - 1);
//     }
//   };

//   const handleNextPage = () => {
//     if (data && page < data.totalPages) {
//       setPage(page + 1);
//     }
//   };

//   // Open add modal
//   const openAddModal = () => {
//     setIsAddModalOpen(true);
//   };

//   // Open edit modal with selected location
//   const openEditModal = (location: Location) => {
//     setSelectedLocation(location);
//     setIsEditModalOpen(true);
//   };

//   // Open delete dialog with selected location
//   const openDeleteDialog = (location: Location) => {
//     setSelectedLocation(location);
//     setIsDeleteDialogOpen(true);
//   };

//   // Handle location add
//   const handleAddLocation = async (data: LocationFormData) => {
//     await addLocationMutation.mutate(data);
//   };

//   // Handle location edit
//   const handleEditLocation = async (id: number, data: LocationFormData) => {
//     await editLocationMutation.mutate({ id, data });
//   };

//   // Handle location delete
//   const handleDeleteLocation = async (id: number) => {
//     await deleteLocationMutation.mutate(id);
//   };

//   return (
//     <div className="p-4">
//       <div className="flex justify-between items-center mb-6">
//         <h1 className="text-3xl font-bold">Locations Database</h1>
//         <Button
//           onClick={openAddModal}
//           className="flex items-center"
//         >
//           <Plus className="mr-1 h-4 w-4" /> Add Location
//         </Button>
//       </div>

//       {/* Search and filter form */}
//       <form onSubmit={handleSearchSubmit} className="mb-6 flex flex-wrap gap-4">
//         <div className="flex-1 min-w-[200px]">
//           <Input
//             placeholder="Search locations..."
//             value={search}
//             onChange={(e) => setSearch(e.target.value)}
//           />
//         </div>

//         <div className="w-[250px]">
//           <Select value={country} onValueChange={setCountry}>
//             <SelectTrigger>
//               <SelectValue placeholder="Country" />
//             </SelectTrigger>
//             <SelectContent className="max-h-[300px]">
//               <SelectItem value="all">All Countries</SelectItem>
//               {countriesData && countriesData.map((countryName: string) => (
//                 <SelectItem key={countryName} value={countryName}>
//                   {countryName}
//                 </SelectItem>
//               ))}
//             </SelectContent>
//           </Select>
//         </div>

//         <Button type="submit">Search</Button>
//       </form>

//       {/* Loading state */}
//       {isLoading && (
//         <div className="text-center py-10">
//           <p className="text-gray-500">Loading locations...</p>
//         </div>
//       )}

//       {/* Locations table */}
//       {!isLoading && data?.locations && data.locations.length > 0 && (
//         <>
//           <div className="overflow-x-auto bg-white shadow-md rounded-lg">
//             <table className="min-w-full divide-y divide-gray-200">
//               <thead className="bg-gray-50">
//                 <tr>
//                   <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                     Image
//                   </th>
//                   <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                     Country
//                   </th>
//                   <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                     Region
//                   </th>
//                   <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                     Incentive Program
//                   </th>
//                   <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                     Minimum Spend
//                   </th>
//                   <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                     Eligible Production Types
//                   </th>
//                   <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                     Actions
//                   </th>
//                 </tr>
//               </thead>
//               <tbody className="bg-white divide-y divide-gray-200">
//                 {data.locations.map((location: Location) => (
//                   <tr key={location.id}>
//                     <td className="px-6 py-4 whitespace-nowrap">
//                       {location.imageUrl ? (
//                         <div className="h-20 w-32 rounded overflow-hidden">
//                           <img
//                             src={location.imageUrl}
//                             alt={`${location.country} - ${location.region}`}
//                             className="h-full w-full object-cover"
//                             onError={(e) => {
//                               const target = e.target as HTMLImageElement;
//                               target.src = "https://placehold.co/400x300/gray/white?text=No+Image";
//                             }}
//                           />
//                         </div>
//                       ) : (
//                         <div className="h-20 w-32 bg-gray-200 flex items-center justify-center rounded">
//                           <MapPin className="text-gray-400 h-10 w-10" />
//                         </div>
//                       )}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
//                       {location.country}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
//                       {location.region}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
//                       {location.incentiveProgram}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
//                       {location.minimumSpend}
//                     </td>
//                     <td className="px-6 py-4 text-sm text-gray-500">
//                       {location.eligibleProductionTypes}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
//                       <div className="flex space-x-2">
//                         <Button
//                           variant="outline"
//                           size="icon"
//                           onClick={() => openEditModal(location)}
//                           title="Edit Location"
//                         >
//                           <Edit className="h-4 w-4" />
//                         </Button>
//                         <Button
//                           variant="outline"
//                           size="icon"
//                           onClick={() => openDeleteDialog(location)}
//                           className="text-red-500 hover:text-red-700"
//                           title="Delete Location"
//                         >
//                           <Trash2 className="h-4 w-4" />
//                         </Button>
//                       </div>
//                     </td>
//                   </tr>
//                 ))}
//               </tbody>
//             </table>
//           </div>

//           {/* Pagination */}
//           <div className="mt-4 flex justify-between items-center">
//             <div className="text-sm text-gray-500">
//               Showing {((page - 1) * pageSize) + 1} to {Math.min(page * pageSize, data.totalCount)} of {data.totalCount} locations
//             </div>
//             <div className="flex space-x-2">
//               <Button
//                 variant="outline"
//                 onClick={handlePreviousPage}
//                 disabled={page === 1}
//               >
//                 Previous
//               </Button>
//               <Button
//                 variant="outline"
//                 onClick={handleNextPage}
//                 disabled={page >= data.totalPages}
//               >
//                 Next
//               </Button>
//             </div>
//           </div>
//         </>
//       )}

//       {/* No results state */}
//       {!isLoading && data?.locations && data.locations.length === 0 && (
//         <div className="text-center py-10 bg-gray-50 rounded-lg">
//           <p className="text-gray-500">No locations found matching your criteria.</p>
//         </div>
//       )}

//       {/* Add Location Modal */}
//       <AddLocationModal
//         isOpen={isAddModalOpen}
//         onClose={() => setIsAddModalOpen(false)}
//         onAdd={handleAddLocation}
//         isSubmitting={addLocationMutation.isPending}
//       />

//       {/* Edit Location Modal */}
//       <EditLocationModal
//         isOpen={isEditModalOpen}
//         location={selectedLocation}
//         onClose={() => setIsEditModalOpen(false)}
//         onEdit={handleEditLocation}
//         isSubmitting={editLocationMutation.isPending}
//       />

//       {/* Delete Location Dialog */}
//       <DeleteLocationDialog
//         isOpen={isDeleteDialogOpen}
//         location={selectedLocation}
//         onClose={() => setIsDeleteDialogOpen(false)}
//         onDelete={handleDeleteLocation}
//         isDeleting={deleteLocationMutation.isPending}
//       />
//     </div>
//   );
// }

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Location, LocationFormData } from "@/lib/types";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "@/hooks/use-toast";
import { Edit, Trash2, MapPin, Plus, AlertTriangle } from "lucide-react";
import EditLocationModal from "@/components/locations/EditLocationModal";
import AddLocationModal from "@/components/locations/AddLocationModal";
import DeleteLocationDialog from "@/components/locations/DeleteLocationDialog";
import { apiRequest } from "@/lib/queryClient";

export default function LocationsDatabase() {
  const [search, setSearch] = useState("");
  const [country, setCountry] = useState("all");
  const [page, setPage] = useState(1);
  const pageSize = 10;
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [selectedLocation, setSelectedLocation] = useState<Location | null>(
    null,
  );
  const queryClient = useQueryClient();

  // Query to fetch locations with filtering and pagination
  const { data, isLoading, error } = useQuery<{
    locations: Location[];
    totalCount: number;
    totalPages: number;
    currentPage: number;
  }>({
    queryKey: ["/api/locations", { search, country, page, pageSize }],
    queryFn: async () => {
      const queryParams = new URLSearchParams();
      if (search) queryParams.append("search", search);
      if (country && country !== "all") queryParams.append("country", country);
      queryParams.append("page", page.toString());
      queryParams.append("pageSize", pageSize.toString());

      const response = await fetch(`/api/locations?${queryParams.toString()}`);
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(
          `Failed to fetch locations: ${response.status} ${
            errorText || response.statusText
          }`,
        );
      }
      return response.json();
    },
  });

  // Use useEffect to handle errors from the main query and show toast messages
  useEffect(() => {
    if (error) {
      // The toast is now shown via the dedicated error block in JSX,
      // but this useEffect could be used for other side effects if needed.
      // For now, ensure no toast is called directly here to avoid the previous error.
      console.error("Error fetching locations:", error);
    }
  }, [error]);

  // Query available countries for the dropdown
  const { data: countriesData } = useQuery<string[]>({
    queryKey: ["derivedCountriesFromLocations", data?.totalCount], // Re-fetch if total locations count changes significantly
    queryFn: async () => {
      if (data?.locations && data.locations.length > 0) {
        const uniqueCountries = Array.from(
          new Set(data.locations.map((loc: Location) => loc.country)),
        );
        return uniqueCountries.sort();
      }
      try {
        const allLocationsResponse = await queryClient.fetchQuery<{
          locations: Location[];
        }>({
          queryKey: [
            "/api/locations",
            { search: "", country: "all", page: 1, pageSize: 1000 }, // Fetch a large page
          ],
        });
        if (allLocationsResponse?.locations) {
          const uniqueCountries = Array.from(
            new Set(
              allLocationsResponse.locations.map(
                (loc: Location) => loc.country,
              ),
            ),
          );
          return uniqueCountries.sort();
        }
      } catch (e) {
        console.error("Failed to fetch all countries for dropdown:", e);
      }
      return [];
    },
    enabled: true,
    staleTime: 1000 * 60 * 15, // Cache for 15 minutes
  });

  const addLocationMutation = useMutation({
    mutationFn: async (newLocationData: LocationFormData) => {
      return await apiRequest("POST", "/api/locations", newLocationData);
    },
    onSuccess: () => {
      toast({
        title: "Location added",
        description: "The location has been added successfully.",
      });
      setIsAddModalOpen(false);
      queryClient.invalidateQueries({ queryKey: ["/api/locations"] });
      queryClient.invalidateQueries({
        queryKey: ["derivedCountriesFromLocations"],
      });
    },
    onError: (err: Error) => {
      toast({
        variant: "destructive",
        title: "Failed to add location",
        description: err.message || "There was an error adding the location.",
      });
    },
  });

  const editLocationMutation = useMutation({
    mutationFn: async ({
      id,
      data: updatedData,
    }: {
      id: number;
      data: LocationFormData;
    }) => {
      return await apiRequest("PUT", `/api/locations/${id}`, updatedData);
    },
    onSuccess: () => {
      toast({
        title: "Location updated",
        description: "The location information has been updated successfully.",
      });
      setIsEditModalOpen(false);
      queryClient.invalidateQueries({ queryKey: ["/api/locations"] });
      queryClient.invalidateQueries({
        queryKey: ["derivedCountriesFromLocations"],
      });
    },
    onError: (err: Error) => {
      toast({
        variant: "destructive",
        title: "Failed to update location",
        description: err.message || "There was an error updating the location.",
      });
    },
  });

  const deleteLocationMutation = useMutation({
    mutationFn: async (id: number) => {
      return await apiRequest("DELETE", `/api/locations/${id}`);
    },
    onSuccess: () => {
      toast({
        title: "Location deleted",
        description: "The location has been deleted successfully.",
      });
      setIsDeleteDialogOpen(false);
      queryClient.invalidateQueries({ queryKey: ["/api/locations"] });
      queryClient.invalidateQueries({
        queryKey: ["derivedCountriesFromLocations"],
      });
    },
    onError: (err: Error) => {
      toast({
        variant: "destructive",
        title: "Failed to delete location",
        description: err.message || "There was an error deleting the location.",
      });
    },
  });

  const handleSearchSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    setPage(1);
  };
  const handlePreviousPage = () => setPage((p) => Math.max(1, p - 1));
  const handleNextPage = () => {
    if (data && page < data.totalPages) setPage((p) => p + 1);
  };
  const openAddModal = () => setIsAddModalOpen(true);
  const openEditModal = (location: Location) => {
    setSelectedLocation(location);
    setIsEditModalOpen(true);
  };
  const openDeleteDialog = (location: Location) => {
    setSelectedLocation(location);
    setIsDeleteDialogOpen(true);
  };
  const handleAddLocation = async (locationData: LocationFormData) =>
    await addLocationMutation.mutateAsync(locationData);
  const handleEditLocation = async (
    id: number,
    locationData: LocationFormData,
  ) => await editLocationMutation.mutateAsync({ id, data: locationData });
  const handleDeleteLocation = async (id: number) =>
    await deleteLocationMutation.mutateAsync(id);

  const locations = data?.locations;
  const totalCount = data?.totalCount || 0;
  const totalPages = data?.totalPages || 0;

  return (
    <div className="p-4">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold">Locations Database</h1>
        <Button onClick={openAddModal} className="flex items-center">
          <Plus className="mr-1 h-4 w-4" /> Add Location
        </Button>
      </div>

      <form onSubmit={handleSearchSubmit} className="mb-6 flex flex-wrap gap-4">
        <div className="flex-1 min-w-[200px]">
          <Input
            placeholder="Search locations..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
          />
        </div>
        <div className="w-[250px]">
          <Select value={country} onValueChange={setCountry}>
            <SelectTrigger>
              <SelectValue placeholder="Country" />
            </SelectTrigger>
            <SelectContent className="max-h-[300px]">
              <SelectItem value="all">All Countries</SelectItem>
              {countriesData?.map((countryName: string) => (
                <SelectItem key={countryName} value={countryName}>
                  {countryName}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
        <Button type="submit">Search</Button>
      </form>

      {isLoading && (
        <div className="text-center py-10">
          <p className="text-gray-500">Loading locations...</p>
        </div>
      )}

      {!isLoading && error && (
        <div className="text-center py-10 bg-red-50 text-red-700 rounded-lg p-4">
          <AlertTriangle className="mx-auto h-12 w-12 mb-4" />
          <h3 className="text-lg font-medium">Error Fetching Locations</h3>
          <p className="text-sm mt-1">
            {(error as Error).message || "An unknown error occurred."}
          </p>
        </div>
      )}

      {!isLoading && !error && (
        <>
          {locations && locations.length > 0 ? (
            <>
              <div className="overflow-x-auto bg-white shadow-md rounded-lg">
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Image
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Country
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Region
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Incentive Program
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Minimum Spend
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Eligible Production Types
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Actions
                      </th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {locations.map((location: Location) => (
                      <tr key={location.id}>
                        <td className="px-6 py-4 whitespace-nowrap">
                          {location.imageUrl ? (
                            <div className="h-20 w-32 rounded overflow-hidden">
                              <img
                                src={location.imageUrl}
                                alt={`${location.country} - ${location.region}`}
                                className="h-full w-full object-cover"
                                onError={(e) => {
                                  (e.target as HTMLImageElement).src =
                                    "https://placehold.co/400x300/gray/white?text=No+Image";
                                }}
                              />
                            </div>
                          ) : (
                            <div className="h-20 w-32 bg-gray-200 flex items-center justify-center rounded">
                              <MapPin className="text-gray-400 h-10 w-10" />
                            </div>
                          )}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                          {location.country}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                          {location.region}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                          {location.incentiveProgram}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                          {location.minimumSpend}
                        </td>
                        <td className="px-6 py-4 text-sm text-gray-500">
                          {location.eligibleProductionTypes}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                          <div className="flex space-x-2">
                            <Button
                              variant="outline"
                              size="icon"
                              onClick={() => openEditModal(location)}
                              title="Edit Location"
                            >
                              <Edit className="h-4 w-4" />
                            </Button>
                            <Button
                              variant="outline"
                              size="icon"
                              onClick={() => openDeleteDialog(location)}
                              className="text-red-500 hover:text-red-700"
                              title="Delete Location"
                            >
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          </div>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              {totalPages > 1 && (
                <div className="mt-4 flex justify-between items-center">
                  <div className="text-sm text-gray-500">
                    Showing {(page - 1) * pageSize + 1} to{" "}
                    {Math.min(page * pageSize, totalCount)} of {totalCount}{" "}
                    locations
                  </div>
                  <div className="flex space-x-2">
                    <Button
                      variant="outline"
                      onClick={handlePreviousPage}
                      disabled={page === 1}
                    >
                      Previous
                    </Button>
                    <Button
                      variant="outline"
                      onClick={handleNextPage}
                      disabled={page >= totalPages}
                    >
                      Next
                    </Button>
                  </div>
                </div>
              )}
            </>
          ) : (
            <div className="text-center py-10 bg-gray-50 rounded-lg">
              <MapPin className="mx-auto h-12 w-12 text-gray-400 mb-4" />
              <h3 className="text-lg font-medium text-gray-700">
                No Locations Found
              </h3>
              <p className="text-sm text-gray-500 mt-1">
                There are currently no locations in the database matching your
                criteria, or the database is empty.
              </p>
              {!search && (!country || country === "all") && (
                <Button onClick={openAddModal} className="mt-4">
                  <Plus className="mr-2 h-4 w-4" /> Add New Location
                </Button>
              )}
            </div>
          )}
        </>
      )}

      <AddLocationModal
        isOpen={isAddModalOpen}
        onClose={() => setIsAddModalOpen(false)}
        onAdd={handleAddLocation}
        isSubmitting={addLocationMutation.isPending}
      />
      <EditLocationModal
        isOpen={isEditModalOpen}
        location={selectedLocation}
        onClose={() => setIsEditModalOpen(false)}
        onEdit={handleEditLocation}
        isSubmitting={editLocationMutation.isPending}
      />
      <DeleteLocationDialog
        isOpen={isDeleteDialogOpen}
        location={selectedLocation}
        onClose={() => setIsDeleteDialogOpen(false)}
        onDelete={handleDeleteLocation}
        isDeleting={deleteLocationMutation.isPending}
      />
    </div>
  );
}



================================================
FILE: client/src/pages/not-found.tsx
================================================
import { Card, CardContent } from "@/components/ui/card";
import { AlertCircle } from "lucide-react";

export default function NotFound() {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md mx-4">
        <CardContent className="pt-6">
          <div className="flex mb-4 gap-2">
            <AlertCircle className="h-8 w-8 text-red-500" />
            <h1 className="text-2xl font-bold text-gray-900">404 Page Not Found</h1>
          </div>

          <p className="mt-4 text-sm text-gray-600">
            Did you forget to add the page to the router?
          </p>
        </CardContent>
      </Card>
    </div>
  );
}



================================================
FILE: client/src/pages/PrivacyPolicy.tsx
================================================
import { Link } from "wouter";

export default function PrivacyPolicy() {
  return (
    <div className="max-w-4xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Privacy Policy</h1>

      <div className="prose prose-slate dark:prose-invert">
        <p className="text-lg mb-4">Last Updated: May 7, 2025</p>

        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">Introduction</h2>
          <p>
            At VadisMedia, we respect your privacy and are committed to
            protecting your personal data. This privacy policy explains how we
            collect, use, and safeguard your information when you use our
            product placement analysis platform.
          </p>
        </section>

        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">
            Information We Collect
          </h2>
          <p>We may collect several types of information, including:</p>
          <ul className="list-disc pl-6 mb-4">
            <li>
              Personal identification information (Name, email address, phone
              number)
            </li>
            <li>Company information</li>
            <li>Usage data (how you interact with our platform)</li>
            <li>
              Content you upload, including scripts and product information
            </li>
          </ul>
        </section>

        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">
            How We Use Your Information
          </h2>
          <p>We use the collected data for various purposes:</p>
          <ul className="list-disc pl-6 my-4">
            <li>To provide and maintain our service</li>
            <li>To notify you about changes to our service</li>
            <li>To provide customer support</li>
            <li>
              To analyze your uploaded scripts and other content solely for the
              purpose of providing you with our script analysis and product
              placement services.
              <strong>
                Your scripts and their content will not be shared externally or
                with other users of the platform without your explicit consent.
              </strong>
            </li>
            <li>To detect, prevent and address technical issues</li>
          </ul>
        </section>

        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">Data Security</h2>
          <p>
            The security of your data is important to us. We implement
            appropriate technical and organizational measures to protect your
            personal information, including any scripts or other content you
            upload.
          </p>
          <p className="mt-2">
            Uploaded scripts are treated as confidential information. Access to
            script content is restricted internally and is used only to provide
            the features of the VadisMedia platform to you. However, no method
            of transmission over the Internet or electronic storage is 100%
            secure, so we cannot guarantee absolute security.
          </p>
        </section>

        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">Data Retention</h2>
          <p>
            We will retain your personal data only for as long as necessary to
            fulfill the purposes we collected it for, including satisfying any
            legal, accounting, or reporting requirements.
          </p>
        </section>

        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">
            Your Data Protection Rights
          </h2>
          <p>You have the following data protection rights:</p>
          <ul className="list-disc pl-6 mb-4">
            <li>The right to access, update or delete your information</li>
            <li>The right to rectification</li>
            <li>The right to object to processing</li>
            <li>The right of restriction</li>
            <li>The right to data portability</li>
            <li>The right to withdraw consent</li>
          </ul>
        </section>

        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">Contact Us</h2>
          <p>
            If you have any questions about this Privacy Policy, please{" "}
            <Link href="/contact" className="text-primary hover:underline">
              contact us
            </Link>
            .
          </p>
        </section>
      </div>
    </div>
  );
}



================================================
FILE: client/src/pages/ProductDatabase.tsx
================================================
// import { useState } from "react";
// import { useQuery, useMutation } from "@tanstack/react-query";
// import { queryClient } from "@/lib/queryClient";
// import { useToast } from "@/hooks/use-toast";
// import { Product } from "@shared/schema";
// import { ProductFormData } from "@/lib/types";
// import { apiRequest } from "@/lib/queryClient";
// import { Input } from "@/components/ui/input";
// import { Button } from "@/components/ui/button";
// import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
// import { Search, Filter, Plus } from "lucide-react";
// import { Skeleton } from "@/components/ui/skeleton";
// import ProductCard from "@/components/products/ProductCard";
// import AddProductModal from "@/components/products/AddProductModal";
// import EditProductModal from "@/components/products/EditProductModal";
// import DeleteProductDialog from "@/components/products/DeleteProductDialog";

// export default function ProductDatabase() {
//   const [searchQuery, setSearchQuery] = useState("");
//   const [categoryFilter, setCategoryFilter] = useState("ALL");
//   const [isAddModalOpen, setIsAddModalOpen] = useState(false);
//   const [isEditModalOpen, setIsEditModalOpen] = useState(false);
//   const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
//   const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
//   const [currentPage, setCurrentPage] = useState(1);
//   const { toast } = useToast();

//   // Fetch products
//   const {
//     data: productsResponse,
//     isLoading
//   } = useQuery<{
//     products: Product[],
//     totalPages: number,
//     currentPage: number
//   }>({
//     queryKey: ['/api/products', { search: searchQuery, category: categoryFilter, page: currentPage }],
//     refetchOnWindowFocus: false,
//     onSuccess: (data) => {
//       // If we're on a page that no longer exists after data changes (like deletion)
//       if (data.totalPages > 0 && currentPage > data.totalPages) {
//         setCurrentPage(data.totalPages);
//         queryClient.invalidateQueries({
//           queryKey: ['/api/products', { search: searchQuery, category: categoryFilter, page: data.totalPages }]
//         });
//       }
//     }
//   });

//   // Add product mutation
//   const addProductMutation = useMutation({
//     mutationFn: async (data: ProductFormData) => {
//       return await apiRequest('POST', '/api/products', data);
//     },
//     onSuccess: () => {
//       toast({
//         title: "Brand added",
//         description: "The brand has been added successfully.",
//       });
//       setIsAddModalOpen(false);
//       queryClient.invalidateQueries({
//         queryKey: ['/api/products', { search: searchQuery, category: categoryFilter, page: currentPage }]
//       });
//     },
//     onError: (error: Error) => {
//       toast({
//         variant: "destructive",
//         title: "Failed to add brand",
//         description: error.message || "There was an error adding the brand.",
//       });
//     },
//   });

//   // Edit product mutation
//   const editProductMutation = useMutation({
//     mutationFn: async ({ id, data }: { id: number, data: ProductFormData }) => {
//       return await apiRequest('PUT', `/api/products/${id}`, data);
//     },
//     onSuccess: () => {
//       toast({
//         title: "Brand updated",
//         description: "The brand has been updated successfully.",
//       });
//       setIsEditModalOpen(false);
//       queryClient.invalidateQueries({
//         queryKey: ['/api/products', { search: searchQuery, category: categoryFilter, page: currentPage }]
//       });
//     },
//     onError: (error: Error) => {
//       toast({
//         variant: "destructive",
//         title: "Failed to update brand",
//         description: error.message || "There was an error updating the brand.",
//       });
//     },
//   });

//   // Delete product mutation
//   const deleteProductMutation = useMutation({
//     mutationFn: async (id: number) => {
//       return await apiRequest('DELETE', `/api/products/${id}`);
//     },
//     onSuccess: () => {
//       toast({
//         title: "Brand deleted",
//         description: "The brand has been deleted successfully.",
//       });
//       setIsDeleteDialogOpen(false);

//       // Check if we need to go to the previous page
//       // This happens when we've deleted the last item on a page (other than the first page)
//       if (currentPage > 1 && products.length === 1) {
//         setCurrentPage(currentPage - 1);
//         queryClient.invalidateQueries({
//           queryKey: ['/api/products', { search: searchQuery, category: categoryFilter, page: currentPage - 1 }]
//         });
//       } else {
//         queryClient.invalidateQueries({
//           queryKey: ['/api/products', { search: searchQuery, category: categoryFilter, page: currentPage }]
//         });
//       }
//     },
//     onError: (error: Error) => {
//       toast({
//         variant: "destructive",
//         title: "Failed to delete brand",
//         description: error.message || "There was an error deleting the brand.",
//       });
//     },
//   });

//   const handleSearch = (e: React.FormEvent) => {
//     e.preventDefault();
//     setCurrentPage(1); // Reset to first page on new search
//     queryClient.invalidateQueries({
//       queryKey: ['/api/products', { search: searchQuery, category: categoryFilter, page: 1 }]
//     });
//   };

//   const handleCategoryChange = (value: string) => {
//     setCategoryFilter(value);
//     setCurrentPage(1); // Reset to first page on filter change
//     queryClient.invalidateQueries({
//       queryKey: ['/api/products', { search: searchQuery, category: value, page: 1 }]
//     });
//   };

//   const handleAddProduct = async (data: ProductFormData) => {
//     await addProductMutation.mutateAsync(data);
//   };

//   const handleEditProduct = async (id: number, data: ProductFormData) => {
//     await editProductMutation.mutateAsync({ id, data });
//   };

//   const handleDeleteProduct = async (id: number) => {
//     await deleteProductMutation.mutateAsync(id);
//   };

//   const openEditModal = (product: Product) => {
//     setSelectedProduct(product);
//     setIsEditModalOpen(true);
//   };

//   const openDeleteDialog = (product: Product) => {
//     setSelectedProduct(product);
//     setIsDeleteDialogOpen(true);
//   };

//   const products = productsResponse?.products || [];
//   const totalPages = productsResponse?.totalPages || 1;

//   return (
//     <div className="bg-white rounded-lg shadow p-6">
//       <div className="flex justify-between items-center mb-6">
//         <h2 className="text-lg font-semibold text-secondary">Brand Database</h2>
//         <Button
//           onClick={() => setIsAddModalOpen(true)}
//           className="bg-primary text-white"
//         >
//           <Plus className="h-5 w-5 mr-1" />
//           Add New Brand
//         </Button>
//       </div>

//       {/* Filter Controls */}
//       <form
//         className="flex flex-col md:flex-row md:items-center mb-6 space-y-3 md:space-y-0 md:space-x-4"
//         onSubmit={handleSearch}
//       >
//         <div className="flex-grow">
//           <div className="relative">
//             <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
//             <Input
//               type="text"
//               placeholder="Search brands..."
//               value={searchQuery}
//               onChange={(e) => setSearchQuery(e.target.value)}
//               className="pl-10"
//             />
//           </div>
//         </div>
//         <div className="flex space-x-2">
//           <Select
//             value={categoryFilter}
//             onValueChange={handleCategoryChange}
//           >
//             <SelectTrigger className="w-[180px]">
//               <SelectValue placeholder="All Categories" />
//             </SelectTrigger>
//             <SelectContent>
//               <SelectItem value="ALL">All Categories</SelectItem>
//               <SelectItem value="BEVERAGE">Beverage</SelectItem>
//               <SelectItem value="ELECTRONICS">Electronics</SelectItem>
//               <SelectItem value="FOOD">Food</SelectItem>
//               <SelectItem value="AUTOMOTIVE">Automotive</SelectItem>
//               <SelectItem value="FASHION">Fashion</SelectItem>
//               <SelectItem value="OTHER">Other</SelectItem>
//             </SelectContent>
//           </Select>
//           <Button
//             type="submit"
//             variant="outline"
//             size="icon"
//           >
//             <Filter className="h-5 w-5" />
//           </Button>
//         </div>
//       </form>

//       {/* Brands Grid */}
//       {isLoading ? (
//         <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
//           {Array.from({ length: 8 }).map((_, i) => (
//             <div key={i} className="border border-gray-200 rounded-lg overflow-hidden">
//               <Skeleton className="h-40 w-full" />
//               <div className="p-4">
//                 <Skeleton className="h-6 w-3/4 mb-2" />
//                 <Skeleton className="h-4 w-1/3" />
//                 <div className="mt-4 flex justify-end space-x-2">
//                   <Skeleton className="h-9 w-16" />
//                   <Skeleton className="h-9 w-16" />
//                 </div>
//               </div>
//             </div>
//           ))}
//         </div>
//       ) : products.length === 0 ? (
//         <div className="text-center py-12 bg-gray-50 rounded-lg">
//           <h3 className="text-lg font-medium mb-2">No brands found</h3>
//           <p className="text-muted-foreground">
//             {searchQuery || categoryFilter !== "ALL"
//               ? "Try adjusting your search or filter criteria."
//               : "Add your first brand to get started."}
//           </p>
//           <Button
//             variant="default"
//             className="mt-4"
//             onClick={() => setIsAddModalOpen(true)}
//           >
//             <Plus className="h-4 w-4 mr-1" />
//             Add New Brand
//           </Button>
//         </div>
//       ) : (
//         <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
//           {products.map((product) => (
//             <ProductCard
//               key={product.id}
//               product={product}
//               onEdit={openEditModal}
//               onDelete={openDeleteDialog}
//             />
//           ))}
//         </div>
//       )}

//       {/* Pagination */}
//       {products.length > 0 && totalPages > 1 && (
//         <div className="mt-6 flex justify-center">
//           <nav className="flex items-center space-x-2">
//             <Button
//               variant="outline"
//               size="sm"
//               onClick={() => setCurrentPage(prev => Math.max(prev - 1, 1))}
//               disabled={currentPage === 1}
//             >
//               Previous
//             </Button>

//             {Array.from({ length: totalPages }, (_, i) => i + 1).map((page) => (
//               <Button
//                 key={page}
//                 variant={page === currentPage ? "default" : "outline"}
//                 size="sm"
//                 onClick={() => setCurrentPage(page)}
//               >
//                 {page}
//               </Button>
//             ))}

//             <Button
//               variant="outline"
//               size="sm"
//               onClick={() => setCurrentPage(prev => Math.min(prev + 1, totalPages))}
//               disabled={currentPage === totalPages}
//             >
//               Next
//             </Button>
//           </nav>
//         </div>
//       )}

//       {/* Modals */}
//       <AddProductModal
//         isOpen={isAddModalOpen}
//         onClose={() => setIsAddModalOpen(false)}
//         onAdd={handleAddProduct}
//         isSubmitting={addProductMutation.isPending}
//       />

//       <EditProductModal
//         isOpen={isEditModalOpen}
//         product={selectedProduct}
//         onClose={() => setIsEditModalOpen(false)}
//         onEdit={handleEditProduct}
//         isSubmitting={editProductMutation.isPending}
//       />

//       <DeleteProductDialog
//         isOpen={isDeleteDialogOpen}
//         product={selectedProduct}
//         onClose={() => setIsDeleteDialogOpen(false)}
//         onDelete={handleDeleteProduct}
//         isDeleting={deleteProductMutation.isPending}
//       />
//     </div>
//   );
// }

import { useState } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { Product } from "@shared/schema";
import { ProductFormData } from "@/lib/types";
import { apiRequest } from "@/lib/queryClient";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Search, Filter, Plus } from "lucide-react";
import { Skeleton } from "@/components/ui/skeleton";
import ProductCard from "@/components/products/ProductCard";
import AddProductModal from "@/components/products/AddProductModal";
import EditProductModal from "@/components/products/EditProductModal";
import DeleteProductDialog from "@/components/products/DeleteProductDialog";

export default function ProductDatabase() {
  const [searchQuery, setSearchQuery] = useState("");
  const [categoryFilter, setCategoryFilter] = useState("ALL");
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [currentPage, setCurrentPage] = useState(1);
  const { toast } = useToast();

  // Fetch products
  const { data: productsResponse, isLoading } = useQuery<{
    products: Product[];
    totalPages: number;
    currentPage: number;
  }>({
    queryKey: [
      "/api/products",
      { search: searchQuery, category: categoryFilter, page: currentPage },
    ],
    refetchOnWindowFocus: false,
    onSuccess: (data) => {
      // If we're on a page that no longer exists after data changes (like deletion)
      if (data.totalPages > 0 && currentPage > data.totalPages) {
        setCurrentPage(data.totalPages);
        queryClient.invalidateQueries({
          queryKey: [
            "/api/products",
            {
              search: searchQuery,
              category: categoryFilter,
              page: data.totalPages,
            },
          ],
        });
      }
    },
  });

  // Add product mutation
  const addProductMutation = useMutation({
    mutationFn: async (data: ProductFormData) => {
      return await apiRequest("POST", "/api/products", data);
    },
    onSuccess: () => {
      toast({
        title: "Brand added",
        description: "The brand has been added successfully.",
      });
      setIsAddModalOpen(false);
      queryClient.invalidateQueries({
        queryKey: [
          "/api/products",
          { search: searchQuery, category: categoryFilter, page: currentPage },
        ],
      });
    },
    onError: (error: Error) => {
      toast({
        variant: "destructive",
        title: "Failed to add brand",
        description: error.message || "There was an error adding the brand.",
      });
    },
  });

  // Edit product mutation
  const editProductMutation = useMutation({
    mutationFn: async ({ id, data }: { id: number; data: ProductFormData }) => {
      return await apiRequest("PUT", `/api/products/${id}`, data);
    },
    onSuccess: () => {
      toast({
        title: "Brand updated",
        description: "The brand has been updated successfully.",
      });
      setIsEditModalOpen(false);
      queryClient.invalidateQueries({
        queryKey: [
          "/api/products",
          { search: searchQuery, category: categoryFilter, page: currentPage },
        ],
      });
    },
    onError: (error: Error) => {
      toast({
        variant: "destructive",
        title: "Failed to update brand",
        description: error.message || "There was an error updating the brand.",
      });
    },
  });

  // Delete product mutation
  const deleteProductMutation = useMutation({
    mutationFn: async (id: number) => {
      return await apiRequest("DELETE", `/api/products/${id}`);
    },
    onSuccess: () => {
      toast({
        title: "Brand deleted",
        description: "The brand has been deleted successfully.",
      });
      setIsDeleteDialogOpen(false);

      // Check if we need to go to the previous page
      // This happens when we've deleted the last item on a page (other than the first page)
      if (currentPage > 1 && products.length === 1) {
        setCurrentPage(currentPage - 1);
        queryClient.invalidateQueries({
          queryKey: [
            "/api/products",
            {
              search: searchQuery,
              category: categoryFilter,
              page: currentPage - 1,
            },
          ],
        });
      } else {
        queryClient.invalidateQueries({
          queryKey: [
            "/api/products",
            {
              search: searchQuery,
              category: categoryFilter,
              page: currentPage,
            },
          ],
        });
      }
    },
    onError: (error: Error) => {
      toast({
        variant: "destructive",
        title: "Failed to delete brand",
        description: error.message || "There was an error deleting the brand.",
      });
    },
  });

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    setCurrentPage(1); // Reset to first page on new search
    queryClient.invalidateQueries({
      queryKey: [
        "/api/products",
        { search: searchQuery, category: categoryFilter, page: 1 },
      ],
    });
  };

  const handleCategoryChange = (value: string) => {
    setCategoryFilter(value);
    setCurrentPage(1); // Reset to first page on filter change
    queryClient.invalidateQueries({
      queryKey: [
        "/api/products",
        { search: searchQuery, category: value, page: 1 },
      ],
    });
  };

  const handleAddProduct = async (data: ProductFormData) => {
    await addProductMutation.mutateAsync(data);
  };

  const handleEditProduct = async (id: number, data: ProductFormData) => {
    await editProductMutation.mutateAsync({ id, data });
  };

  const handleDeleteProduct = async (id: number) => {
    await deleteProductMutation.mutateAsync(id);
  };

  const openEditModal = (product: Product) => {
    setSelectedProduct(product);
    setIsEditModalOpen(true);
  };

  const openDeleteDialog = (product: Product) => {
    setSelectedProduct(product);
    setIsDeleteDialogOpen(true);
  };

  const products = productsResponse?.products || [];
  const totalPages = productsResponse?.totalPages || 1;

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-lg font-semibold text-foreground">
          Brand Database
        </h2>
        <Button
          onClick={() => setIsAddModalOpen(true)}
          className="bg-primary text-white"
        >
          <Plus className="h-5 w-5 mr-1" />
          Add New Product
        </Button>
      </div>

      {/* Filter Controls */}
      <form
        className="flex flex-col md:flex-row md:items-center mb-6 space-y-3 md:space-y-0 md:space-x-4"
        onSubmit={handleSearch}
      >
        <div className="flex-grow">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <Input
              type="text"
              placeholder="Search brands..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10"
            />
          </div>
        </div>
        <div className="flex space-x-2">
          <Select value={categoryFilter} onValueChange={handleCategoryChange}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="All Categories" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="ALL">All Categories</SelectItem>
              <SelectItem value="BEVERAGE">Beverage</SelectItem>
              <SelectItem value="ELECTRONICS">Electronics</SelectItem>
              <SelectItem value="FOOD">Food</SelectItem>
              <SelectItem value="AUTOMOTIVE">Automotive</SelectItem>
              <SelectItem value="FASHION">Fashion</SelectItem>
              <SelectItem value="WATCH">Watch</SelectItem>
            </SelectContent>
          </Select>
          <Button type="submit" variant="outline" size="icon">
            <Filter className="h-5 w-5" />
          </Button>
        </div>
      </form>

      {/* Brands Grid */}
      {isLoading ? (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
          {Array.from({ length: 8 }).map((_, i) => (
            <div
              key={i}
              className="border border-gray-200 rounded-lg overflow-hidden"
            >
              <Skeleton className="h-40 w-full" />
              <div className="p-4">
                <Skeleton className="h-6 w-3/4 mb-2" />
                <Skeleton className="h-4 w-1/3" />
                <div className="mt-4 flex justify-end space-x-2">
                  <Skeleton className="h-9 w-16" />
                  <Skeleton className="h-9 w-16" />
                </div>
              </div>
            </div>
          ))}
        </div>
      ) : products.length === 0 ? (
        <div className="text-center py-12 bg-gray-50 rounded-lg">
          <h3 className="text-lg font-medium mb-2">No brands found</h3>
          <p className="text-muted-foreground">
            {searchQuery || categoryFilter !== "ALL"
              ? "Try adjusting your search or filter criteria."
              : "Add your first brand to get started."}
          </p>
          <Button
            variant="default"
            className="mt-4"
            onClick={() => setIsAddModalOpen(true)}
          >
            <Plus className="h-4 w-4 mr-1" />
            Add New Brand
          </Button>
        </div>
      ) : (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
          {products.map((product) => (
            <ProductCard
              key={product.id}
              product={product}
              onEdit={openEditModal}
              onDelete={openDeleteDialog}
            />
          ))}
        </div>
      )}

      {/* Pagination */}
      {products.length > 0 && totalPages > 1 && (
        <div className="mt-6 flex justify-center">
          <nav className="flex items-center space-x-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setCurrentPage((prev) => Math.max(prev - 1, 1))}
              disabled={currentPage === 1}
            >
              Previous
            </Button>

            {Array.from({ length: totalPages }, (_, i) => i + 1).map((page) => (
              <Button
                key={page}
                variant={page === currentPage ? "default" : "outline"}
                size="sm"
                onClick={() => setCurrentPage(page)}
              >
                {page}
              </Button>
            ))}

            <Button
              variant="outline"
              size="sm"
              onClick={() =>
                setCurrentPage((prev) => Math.min(prev + 1, totalPages))
              }
              disabled={currentPage === totalPages}
            >
              Next
            </Button>
          </nav>
        </div>
      )}

      {/* Modals */}
      <AddProductModal
        isOpen={isAddModalOpen}
        onClose={() => setIsAddModalOpen(false)}
        onAdd={handleAddProduct}
        isSubmitting={addProductMutation.isPending}
      />

      <EditProductModal
        isOpen={isEditModalOpen}
        product={selectedProduct}
        onClose={() => setIsEditModalOpen(false)}
        onEdit={handleEditProduct}
        isSubmitting={editProductMutation.isPending}
      />

      <DeleteProductDialog
        isOpen={isDeleteDialogOpen}
        product={selectedProduct}
        onClose={() => setIsDeleteDialogOpen(false)}
        onDelete={handleDeleteProduct}
        isDeleting={deleteProductMutation.isPending}
      />
    </div>
  );
}



================================================
FILE: client/src/pages/ScriptEditor.tsx
================================================
// // client/src/pages/ScriptEditor.tsx
// import { useState, useEffect, useRef, useCallback } from "react";
// import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
// import { apiRequest } from "@/lib/queryClient";
// import { useToast } from "@/hooks/use-toast";
// import SceneBreakdown from "@/components/script/SceneBreakdown";
// import ScriptDisplay from "@/components/script/ScriptDisplay";
// import BrandableScenes from "@/components/script/BrandableScenes";
// import VideoPlayerModal from "@/components/script/VideoPlayerModal";
// import ImageZoomModal from "@/components/script/ImageZoomModal"; 
// import SuggestedLocations from "@/components/script/SuggestedLocations";
// import CharacterCasting from "@/components/script/CharacterCasting";
// import {
//     Script,
//     Scene,
//     SceneVariation as SharedSceneVariation,
//     Actor,
//     Location,
//     Product,
// } from "@shared/schema";
// import { 
//     Info, 
//     Loader2, 
//     AlertTriangle, 
//     DollarSign, 
//     PieChart, 
//     BarChart, 
//     ChevronDown, 
//     CheckCircle, 
//     Image as ImageIcon,
//     ZoomIn,
//     PlayCircle
// } from "lucide-react";
// import { SceneVariation, ScriptCharacter, ActorSuggestion, ClientSuggestedLocation } from "@/lib/types";
// import { 
//     Dialog, 
//     DialogContent, 
//     DialogDescription, 
//     DialogHeader, 
//     DialogTitle,
//     DialogTrigger,
//     DialogFooter,
// } from "@/components/ui/dialog";
// import { Button } from "@/components/ui/button";
// import { Label } from "@/components/ui/label";
// import { Input } from "@/components/ui/input";

// type VideoGenerationStatus =
//     | "idle"
//     | "pending"
//     | "generating"
//     | "succeeded"
//     | "failed";
// interface VideoGenerationState {
//     status: VideoGenerationStatus;
//     predictionId?: string | null;
//     videoUrl?: string | null;
//     error?: string | null;
//     logs?: string | null;
//     progress?: number;
//     stageMessage?: string;
// }

// interface PredictionStatusResult {
//     status: VideoGenerationStatus;
//     outputUrl?: string | null;
//     error?: string | null;
//     logs?: string | null;
// }

// const DEFAULT_PROJECT_BUDGET = 1000000;
// const DEFAULT_FILM_GENRE = "ACTION";

// export default function ScriptEditor() {
//     const [activeSceneId, setActiveSceneId] = useState<number | null>(null);
//     const { toast } = useToast();
//     const queryClient = useQueryClient();
//     const [isExporting, setIsExporting] = useState(false);
//     const [videoGenerationStates, setVideoGenerationStates] = useState<{
//         [key: number]: VideoGenerationState;
//     }>({});
//     const [isVideoModalOpen, setIsVideoModalOpen] = useState(false);
//     const [currentVideoUrl, setCurrentVideoUrl] = useState<string | null>(null);
//     const [currentVideoTitle, setCurrentVideoTitle] = useState<string>("");

//     // State for Image Zoom Modal
//     const [isImageZoomModalOpen, setIsImageZoomModalOpen] = useState(false);
//     const [zoomedImageUrl, setZoomedImageUrl] = useState<string | null>(null);
//     const [zoomedImageTitle, setZoomedImageTitle] = useState<string>("");
    
//     // State for selected items
//     const [selectedCharacters, setSelectedCharacters] = useState<ScriptCharacter[]>([]);
//     const [selectedLocations, setSelectedLocations] = useState<ClientSuggestedLocation[]>([]);
//     const [selectedProducts, setSelectedProducts] = useState<SceneVariation[]>([]);
    
//     // State for financial analysis modal
//     const [isFinancialAnalysisModalOpen, setIsFinancialAnalysisModalOpen] = useState(false);
//     const [projectName, setProjectName] = useState<string>("");
//     const [expectedReleaseDate, setExpectedReleaseDate] = useState<string>("");
//     const [totalBudget, setTotalBudget] = useState<number>(DEFAULT_PROJECT_BUDGET);
    
//     // State for info modal
//     const [isSelectionInfoModalOpen, setIsSelectionInfoModalOpen] = useState(false);

//     const pollingIntervals = useRef<{ [key: string]: NodeJS.Timeout }>({});

//     const [projectBudget, setProjectBudget] = useState<number | undefined>(
//         DEFAULT_PROJECT_BUDGET,
//     );
//     const [filmGenreForCasting, setFilmGenreForCasting] =
//         useState<string>(DEFAULT_FILM_GENRE);
//     const [projectBudgetTierForCasting, setProjectBudgetTierForCasting] =
//         useState<"low" | "medium" | "high" | "any">("medium");

//     // --- Queries ---
//     const {
//         data: script,
//         isLoading: isLoadingScript,
//         isError: isScriptError,
//         error: scriptError,
//     } = useQuery<Script | null>({
//         queryKey: ["/api/scripts/current"],
//         refetchOnWindowFocus: false,
//     });

//     const { data: scenes = [], isLoading: isLoadingScenes } = useQuery<Scene[]>(
//         {
//             queryKey: ["/api/scripts/scenes", script?.id],
//             enabled: !!script?.id,
//         },
//     );

//     const {
//         data: brandableSceneObjects = [],
//         isLoading: isLoadingBrandableScenes,
//         refetch: refetchBrandableScenes,
//     } = useQuery<Scene[]>({
//         queryKey: ["/api/scripts/brandable-scenes", script?.id],
//         enabled: !!script?.id && scenes.length > 0,
//     });
//     const brandableSceneIds = brandableSceneObjects.map((scene) => scene.id);

//     const {
//         data: sceneVariations = [],
//         isLoading: isLoadingVariations,
//         isFetching: isFetchingVariations,
//     } = useQuery<SceneVariation[]>({
//         queryKey: ["/api/scripts/scene-variations", activeSceneId],
//         enabled: !!activeSceneId,
//         staleTime: 1 * 60 * 1000,
//         refetchOnWindowFocus: false,
//         onSuccess: (data) => {
//             if (activeSceneId && data.length > 0) {
//                 const currentSceneObject = scenes.find(
//                     (s) => s.id === activeSceneId,
//                 );
//                 if (
//                     currentSceneObject &&
//                     !brandableSceneIds.includes(activeSceneId)
//                 ) {
//                     refetchBrandableScenes();
//                 }
//             }
//         },
//     });

//     const {
//         data: scriptCharacters = [],
//         isLoading: isLoadingScriptCharacters,
//     } = useQuery<ScriptCharacter[]>({
//         queryKey: ["/api/scripts/characters", script?.id],
//         queryFn: async ({ queryKey }) => {
//             const [, sId] = queryKey as [string, number | undefined];
//             if (!sId) return [];
//             const res = await apiRequest(
//                 "GET",
//                 `/api/scripts/${sId}/characters`,
//             );
//             return res.json();
//         },
//         enabled: !!script?.id,
//     });

//     useEffect(() => {
//         setActiveSceneId(null);
//         setVideoGenerationStates({});
//         setProjectBudget(DEFAULT_PROJECT_BUDGET);
//         setFilmGenreForCasting(DEFAULT_FILM_GENRE);
//         Object.values(pollingIntervals.current).forEach(clearInterval);
//         pollingIntervals.current = {};
//     }, [script?.id]);

//     useEffect(() => {
//         setVideoGenerationStates({});
//         Object.values(pollingIntervals.current).forEach(clearInterval);
//         pollingIntervals.current = {};
//     }, [activeSceneId]);

//     useEffect(() => {
//         if (
//             projectBudget === undefined ||
//             projectBudget === null ||
//             isNaN(projectBudget)
//         ) {
//             setProjectBudgetTierForCasting("any");
//         } else if (projectBudget < 1000000) {
//             setProjectBudgetTierForCasting("low");
//         } else if (projectBudget <= 20000000) {
//             setProjectBudgetTierForCasting("medium");
//         } else {
//             setProjectBudgetTierForCasting("high");
//         }
//     }, [projectBudget]);

//     const reanalyzeScriptMutation = useMutation({
//         mutationFn: async () => apiRequest("POST", "/api/scripts/analyze", {}),
//         onSuccess: () => {
//             toast({
//                 title: "Analysis complete",
//                 description: "Script re-analyzed.",
//             });
//             queryClient.invalidateQueries({
//                 queryKey: ["/api/scripts/brandable-scenes", script?.id],
//             });
//             queryClient.invalidateQueries({
//                 queryKey: ["/api/scripts/scenes", script?.id],
//             });
//             if (activeSceneId) {
//                 queryClient.invalidateQueries({
//                     queryKey: ["/api/scripts/scene-variations", activeSceneId],
//                 });
//             }
//         },
//         onError: (error: Error) => {
//             toast({
//                 variant: "destructive",
//                 title: "Analysis failed",
//                 description: error.message,
//             });
//         },
//     });

//     const generatePlacementsMutation = useMutation({
//         mutationFn: async () => {
//             if (activeSceneId) {
//                 return queryClient.invalidateQueries({
//                     queryKey: ["/api/scripts/scene-variations", activeSceneId],
//                 });
//             }
//             return queryClient.invalidateQueries({
//                 queryKey: ["/api/scripts/scene-variations"],
//             });
//         },
//         onSuccess: () => {
//             toast({
//                 title: "Placement Generation Triggered",
//                 description:
//                     "Visual options will be generated for the selected scene.",
//             });
//         },
//         onError: (error: Error) => {
//             toast({
//                 variant: "destructive",
//                 title: "Generation Trigger Failed",
//                 description: error.message,
//             });
//         },
//     });

//     const stopPollingPrediction = useCallback((predictionId: string) => {
//         if (pollingIntervals.current[predictionId]) {
//             clearInterval(pollingIntervals.current[predictionId]);
//             delete pollingIntervals.current[predictionId];
//         }
//     }, []);

//     const pollPredictionStatus = useCallback(
//         async (predictionId: string, variationId: number) => {
//             try {
//                 const response = await fetch(
//                     `/api/replicate/predictions/${predictionId}`,
//                 );
//                 if (!response.ok) {
//                     const errorText = await response.text();
//                     throw new Error(
//                         `API error ${response.status}: ${errorText || "Failed to fetch status"}`,
//                     );
//                 }
//                 const data: PredictionStatusResult = await response.json();

//                 setVideoGenerationStates((prev) => {
//                     // ... (rest of the polling logic remains the same)
//                     const currentState = prev[variationId];
//                     if (
//                         !currentState ||
//                         currentState.predictionId !== predictionId ||
//                         currentState.status === "succeeded" ||
//                         currentState.status === "failed"
//                     ) {
//                         stopPollingPrediction(predictionId);
//                         return prev;
//                     }
//                     let progress = currentState.progress || 0;
//                     let stageMessage =
//                         currentState.stageMessage || "Processing...";
//                     // Ensure visual state updates properly by always setting to "generating" for active states
//                     let updatedStatus = currentState.status;
                    
//                     switch (data.status) {
//                         case "starting":
//                             progress = 30;
//                             stageMessage = "Initializing video engine...";
//                             updatedStatus = "generating"; // Force to generating for visibility
//                             break;
//                         case "processing":
//                             progress = Math.max(progress || 0, 50);
//                             updatedStatus = "generating"; // Force to generating for visibility
                            
//                             if (data.logs) {
//                                 if (
//                                     data.logs
//                                         .toLowerCase()
//                                         .includes("frame generation")
//                                 ) {
//                                     progress = 65;
//                                     stageMessage = "Creating video frames...";
//                                 }
//                                 if (
//                                     data.logs
//                                         .toLowerCase()
//                                         .includes("upscaling")
//                                 ) {
//                                     progress = 85;
//                                     stageMessage = "Enhancing video quality...";
//                                 }
//                             } else {
//                                 stageMessage = "Processing your video...";
//                             }
//                             break;
//                         case "succeeded":
//                             progress = 100;
//                             stageMessage = "Video ready!";
//                             updatedStatus = "succeeded";
//                             break;
//                         case "failed":
//                         case "canceled":
//                             progress = 0;
//                             stageMessage = data.error
//                                 ? `Failed: ${String(data.error).substring(0, 50)}...`
//                                 : "Generation failed.";
//                             updatedStatus = "failed";
//                             break;
//                     }
//                     const newStateUpdate: VideoGenerationState = {
//                         ...currentState,
//                         status: updatedStatus, // Use our properly mapped status
//                         videoUrl: data.outputUrl ?? currentState.videoUrl,
//                         error: data.error ? String(data.error) : null,
//                         logs: data.logs ?? null,
//                         progress: progress,
//                         stageMessage: stageMessage,
//                     };
//                     if (
//                         ["succeeded", "failed", "canceled"].includes(
//                             data.status,
//                         )
//                     ) {
//                         stopPollingPrediction(predictionId);
//                         if (data.status === "succeeded") {
//                             if (!data.outputUrl) {
//                                 toast({
//                                     title: "Video Processed",
//                                     description: `Video for var ${variationId} finished, but no URL.`,
//                                     variant: "destructive",
//                                 });
//                                 newStateUpdate.status = "failed";
//                                 newStateUpdate.error =
//                                     "Succeeded but no output URL.";
//                             } else {
//                                 toast({
//                                     title: "Video Ready!",
//                                     description: `Video for variation ${variationId} is now available. Click "View Video" to watch it.`,
//                                     duration: 6000, // Show this toast longer for better visibility
//                                 });
//                             }
//                         } else {
//                             toast({
//                                 title: "Video Failed",
//                                 description: `Video for var ${variationId} failed: ${data.error || "Unknown"}.`,
//                                 variant: "destructive",
//                             });
//                         }
//                     }
//                     return { ...prev, [variationId]: newStateUpdate };
//                 });
//             } catch (error: any) {
//                 stopPollingPrediction(predictionId);
//                 setVideoGenerationStates((prev) => {
//                     const currentState = prev[variationId];
//                     if (
//                         currentState &&
//                         currentState.predictionId === predictionId
//                     ) {
//                         return {
//                             ...prev,
//                             [variationId]: {
//                                 ...currentState,
//                                 status: "failed",
//                                 error: `Polling failed: ${error.message}`,
//                                 progress: 0,
//                                 stageMessage: "Polling Error",
//                             },
//                         };
//                     }
//                     return prev;
//                 });
//                 toast({
//                     variant: "destructive",
//                     title: "Polling Error",
//                     description: `Could not get video status: ${error.message}`,
//                 });
//             }
//         },
//         [stopPollingPrediction, toast],
//     );

//     const startPollingPrediction = useCallback(
//         (predictionId: string, variationId: number) => {
//             if (pollingIntervals.current[predictionId]) return;
//             const initialTimeout = setTimeout(
//                 () => pollPredictionStatus(predictionId, variationId),
//                 2000,
//             );
//             pollingIntervals.current[predictionId] = setInterval(
//                 () => pollPredictionStatus(predictionId, variationId),
//                 5000,
//             );
//         },
//         [pollPredictionStatus],
//     );

//     useEffect(() => {
//         return () => {
//             Object.values(pollingIntervals.current).forEach(clearInterval);
//             pollingIntervals.current = {};
//         };
//     }, []);

//     const startVideoGenerationMutation = useMutation({
//         mutationFn: async (variationId: number) => {
//             // Set initial pending state with visual feedback
//             setVideoGenerationStates((prev) => ({
//                 ...prev,
//                 [variationId]: {
//                     status: "pending",
//                     error: null,
//                     videoUrl: null,
//                     predictionId: null,
//                     progress: 10,
//                     stageMessage: "Queueing video...",
//                 },
//             }));
            
//             // Toast notification for better visual feedback
//             toast({
//                 title: "Starting Video Generation",
//                 description: "Connecting to video service...",
//                 duration: 3000,
//             });
            
//             // Make the API request
//             const response = await apiRequest(
//                 "POST",
//                 `/api/variations/${variationId}/generate-video`,
//                 {},
//             );
//             const data = await response.json();
//             return { variationId, responseData: data };
//         },
//         onSuccess: (result) => {
//             const { variationId, responseData } = result;
//             console.log("Video generation response:", responseData);
            
//             if (
//                 responseData.predictionId &&
//                 responseData.status &&
//                 !["failed", "canceled"].includes(responseData.status)
//             ) {
//                 // Force state to "generating" for clear visual feedback
//                 setVideoGenerationStates((prev) => ({
//                     ...prev,
//                     [variationId]: {
//                         status: "generating",
//                         predictionId: responseData.predictionId,
//                         error: null,
//                         videoUrl: null,
//                         progress: 20,
//                         stageMessage: "Creating your video...",
//                     },
//                 }));
                
//                 // Start polling for status updates
//                 startPollingPrediction(responseData.predictionId, variationId);
                
//                 // Toast notification with clear instructions
//                 toast({
//                     title: "Video Generation Started",
//                     description: `Processing has begun. The button will update when your video is ready.`,
//                     duration: 5000, // Show this toast a bit longer
//                 });
//             } else {
//                 const errorMsg =
//                     responseData.message ||
//                     responseData.error ||
//                     "Failed to get valid prediction ID.";
//                 setVideoGenerationStates((prev) => ({
//                     ...prev,
//                     [variationId]: {
//                         status: "failed",
//                         error: errorMsg,
//                         predictionId: responseData.predictionId || null,
//                         progress: 0,
//                         stageMessage: `Error: ${String(errorMsg).substring(0, 30)}...`,
//                     },
//                 }));
//                 toast({
//                     title: "Video Start Failed",
//                     description: errorMsg,
//                     variant: "destructive",
//                 });
//             }
//         },
//         onError: (error: Error, variationId) => {
//             // ... (rest of the error logic remains the same)
//             setVideoGenerationStates((prev) => ({
//                 ...prev,
//                 [variationId]: {
//                     status: "failed",
//                     error: `Failed to start: ${error.message}`,
//                     predictionId: null,
//                     progress: 0,
//                     stageMessage: "Request Error",
//                 },
//             }));
//             toast({
//                 variant: "destructive",
//                 title: "Request Error",
//                 description: `Could not start video generation for var ${variationId}: ${error.message}`,
//             });
//         },
//     });

//     const handleExport = async () => {
//         console.log("Export triggered");
//         setIsExporting(true);
//         setIsExporting(false);
//     };
//     const handleSceneSelect = (sceneId: number) => {
//         if (activeSceneId !== sceneId) setActiveSceneId(sceneId);
//     };
//     const handleViewVideo = (videoUrl: string, title: string) => {
//         setCurrentVideoUrl(videoUrl);
//         setCurrentVideoTitle(title);
//         setIsVideoModalOpen(true);
//     };
//     const handleCloseVideoModal = () => {
//         setIsVideoModalOpen(false);
//         setCurrentVideoUrl(null);
//         setCurrentVideoTitle("");
//     };

//     // Handler for image zoom
//     const handleImageZoom = (imageUrl: string, title: string) => {
//         setZoomedImageUrl(imageUrl);
//         setZoomedImageTitle(title);
//         setIsImageZoomModalOpen(true);
//     };
//     const handleCloseImageZoomModal = () => {
//         setIsImageZoomModalOpen(false);
//         setZoomedImageUrl(null);
//         setZoomedImageTitle("");
//     };
    
//     // Selection management functions
//     const handleCharacterSelection = (character: ScriptCharacter) => {
//         setSelectedCharacters(prev => {
//             const exists = prev.some(c => c.name === character.name);
//             if (exists) {
//                 return prev.filter(c => c.name !== character.name);
//             } else {
//                 return [...prev, character];
//             }
//         });
//     };
    
//     const handleLocationSelection = (location: ClientSuggestedLocation) => {
//         setSelectedLocations(prev => {
//             const exists = prev.some(l => l.id === location.id);
//             if (exists) {
//                 return prev.filter(l => l.id !== location.id);
//             } else {
//                 return [...prev, location];
//             }
//         });
//     };
    
//     const handleProductSelection = (product: SceneVariation) => {
//         setSelectedProducts(prev => {
//             const exists = prev.some(p => p.id === product.id);
//             if (exists) {
//                 return prev.filter(p => p.id !== product.id);
//             } else {
//                 return [...prev, product];
//             }
//         });
//     };
    
//     const openSelectionInfoModal = () => {
//         setIsSelectionInfoModalOpen(true);
//     };
    
//     const closeSelectionInfoModal = () => {
//         setIsSelectionInfoModalOpen(false);
//     };
    
//     const openFinancialAnalysisModal = () => {
//         // Set the project name to the script title by default
//         setProjectName(script?.title || "");
//         setIsFinancialAnalysisModalOpen(true);
//     };
    
//     const closeFinancialAnalysisModal = () => {
//         setIsFinancialAnalysisModalOpen(false);
//     };

//     const activeSceneObject = scenes.find((s: Scene) => s.id === activeSceneId);
//     const isPageLoading = isLoadingScript;
//     const isLoadingCurrentVariations =
//         !!activeSceneId && (isLoadingVariations || isFetchingVariations);
//     const displayScript = script
//         ? { id: script.id, title: script.title, content: script.content }
//         : null;

//     if (isPageLoading) {
//         return (
//             <div className="space-y-6 p-4 animate-pulse">
//                 <div className="h-8 bg-gray-200 rounded w-1/3 mb-4"></div>
//                 <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
//                     <div className="lg:col-span-1 space-y-2">
//                         <div className="h-6 bg-gray-200 rounded w-3/4"></div>
//                         {Array.from({ length: 5 }).map((_, i) => (
//                             <div
//                                 key={i}
//                                 className="h-10 bg-gray-200 rounded"
//                             ></div>
//                         ))}
//                     </div>
//                     <div className="lg:col-span-3 space-y-6">
//                         <div className="h-64 bg-gray-200 rounded"></div>
//                         <div className="h-96 bg-gray-200 rounded"></div>
//                     </div>
//                 </div>
//             </div>
//         );
//     }

//     if (isScriptError && !script) {
//         return (
//             <div className="p-6 text-center text-red-600 flex flex-col items-center justify-center h-full">
//                 <AlertTriangle className="h-12 w-12 mb-4" />
//                 <h2 className="text-xl font-semibold">Error Loading Script</h2>
//                 <p>
//                     {(scriptError as Error)?.message ||
//                         "An unknown error occurred. Please try again later."}
//                 </p>
//             </div>
//         );
//     }

//     if (!script) {
//         return (
//             <div className="p-6 text-center text-gray-500 flex flex-col items-center justify-center h-full">
//                 <Info className="h-12 w-12 mb-4" />
//                 <h2 className="text-xl font-semibold">No Script Loaded</h2>
//                 <p>Please upload a script via the Welcome page to begin.</p>
//             </div>
//         );
//     }

//     return (
//         <>
//             {script && (
//                 <div className="flex justify-between items-center mb-4 px-1">
//                     <h1 className="text-2xl font-bold text-gray-800">
//                         Script Analysis: {/* Changed "Editor" to "Analysis" */}
//                         <span className="text-primary">{script.title}</span>
//                     </h1>
//                     <Button 
//                         variant="outline" 
//                         size="icon" 
//                         className="rounded-full" 
//                         onClick={openSelectionInfoModal}
//                         title="View selected items"
//                     >
//                         <Info className="h-5 w-5" />
//                     </Button>
//                 </div>
//             )}
//             <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
//                 <SceneBreakdown
//                     scenes={scenes}
//                     activeSceneId={activeSceneId}
//                     projectTitle={script?.title}
//                     brandableSceneIds={brandableSceneIds || []}
//                     isLoading={isLoadingScenes || isLoadingBrandableScenes}
//                     onSceneSelect={handleSceneSelect}
//                 />
//                 <div className="lg:col-span-3 space-y-6">
//                     <div className="bg-white rounded-lg shadow p-4">
//                         <ScriptDisplay
//                             script={displayScript}
//                             isLoading={false}
//                             onSave={async () => {
//                                 console.warn("Save not implemented");
//                             }}
//                             onReanalyze={() => reanalyzeScriptMutation.mutate()}
//                             onGeneratePlacements={() =>
//                                 generatePlacementsMutation.mutate()
//                             }
//                             onExport={handleExport}
//                             activeScene={activeSceneObject || null}
//                             isSaving={false}
//                             isReanalyzing={reanalyzeScriptMutation.isPending}
//                             isGenerating={generatePlacementsMutation.isPending}
//                             isExporting={isExporting}
//                         />
//                     </div>
//                     {scenes.length > 0 &&
//                     activeSceneId !== null &&
//                     activeSceneObject ? (
//                         <div className="bg-white rounded-lg shadow p-4">
//                             <BrandableScenes
//                                 activeSceneDetails={activeSceneObject}
//                                 projectTitle={script?.title}
//                                 scenes={scenes}
//                                 productVariations={sceneVariations}
//                                 isLoading={isLoadingCurrentVariations}
//                                 selectedSceneId={activeSceneId}
//                                 onGenerateVideoRequest={(variationId) =>
//                                     startVideoGenerationMutation.mutate(
//                                         variationId,
//                                     )
//                                 }
//                                 videoGenerationStates={videoGenerationStates}
//                                 onViewVideo={handleViewVideo}
//                                 onImageZoom={handleImageZoom}
//                                 selectedProducts={selectedProducts}
//                                 onProductSelect={handleProductSelection}
//                             />
//                         </div>
//                     ) : (
//                         activeSceneId === null &&
//                         scenes.length > 0 && (
//                             <div className="bg-white rounded-lg shadow p-6 text-center text-gray-500">
//                                 <Info className="inline-block mr-2 h-5 w-5" />
//                                 Select a scene from the breakdown list to view
//                                 details and placement options.
//                             </div>
//                         )
//                     )}
//                     {script && (
//                         <>
//                             <div className="my-6 border-t border-gray-200"></div>
//                             <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
//                                 <div className="bg-white rounded-lg shadow p-4">
//                                     <h3 className="text-lg font-semibold text-foreground mb-3">
//                                         Optimizing funding: Suggested Filming
//                                         Locations & Incentives
//                                     </h3>
//                                     <div className="mb-4">
//                                         <label
//                                             htmlFor="projectBudget"
//                                             className="text-sm font-medium text-gray-700"
//                                         >
//                                             Estimated Project Budget ($)
//                                         </label>
//                                         <div className="flex items-center space-x-2 mt-1">
//                                             <DollarSign className="h-5 w-5 text-gray-400" />
//                                             <input
//                                                 id="projectBudget"
//                                                 type="number"
//                                                 value={
//                                                     projectBudget === undefined
//                                                         ? ""
//                                                         : projectBudget
//                                                 }
//                                                 onChange={(e) => {
//                                                     const val = e.target.value;
//                                                     setProjectBudget(
//                                                         val === ""
//                                                             ? undefined
//                                                             : parseInt(val, 10),
//                                                     );
//                                                 }}
//                                                 placeholder="e.g., 1000000"
//                                                 className="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-primary focus:border-primary sm:text-sm"
//                                                 step="100000"
//                                             />
//                                         </div>
//                                     </div>
//                                     <SuggestedLocations
//                                         scriptId={script?.id || null}
//                                         projectBudget={projectBudget}
//                                         isLoading={isLoadingScenes}
//                                         selectedLocations={selectedLocations}
//                                         onLocationSelect={handleLocationSelection}
//                                     />
//                                 </div>
//                                 <div className="bg-white rounded-lg shadow p-4">
//                                     <h3 className="text-lg font-semibold text-foreground mb-3">
//                                         Character Casting Suggestions
//                                     </h3>
//                                     <CharacterCasting
//                                         scriptId={script?.id || null}
//                                         isLoading={isLoadingScriptCharacters}
//                                         filmGenre={filmGenreForCasting}
//                                         projectBudgetTier={projectBudgetTierForCasting}
//                                         selectedCharacters={selectedCharacters}
//                                         onCharacterSelect={handleCharacterSelection}
//                                     />
//                                 </div>
//                             </div>
                            
//                             {/* Selection summary and financial analysis button */}
//                             {(selectedCharacters.length > 0 || selectedLocations.length > 0 || selectedProducts.length > 0) && (
//                                 <div className="mt-6 bg-white rounded-lg shadow p-4">
//                                     <div className="flex justify-between items-center mb-4">
//                                         <h3 className="text-lg font-semibold text-foreground">
//                                             Selected Items Summary
//                                         </h3>
//                                         <Button 
//                                             variant="outline" 
//                                             size="sm" 
//                                             onClick={openSelectionInfoModal}
//                                             className="flex items-center gap-1"
//                                         >
//                                             <Info className="h-4 w-4" />
//                                             Details
//                                         </Button>
//                                     </div>
                                    
//                                     <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
//                                         <div>
//                                             <h4 className="text-sm font-medium mb-2 flex items-center">
//                                                 <span className="mr-2">Cast</span>
//                                                 <span className="bg-green-100 text-green-800 text-xs font-medium px-2 py-0.5 rounded-full">
//                                                     {selectedCharacters.length} selected
//                                                 </span>
//                                             </h4>
//                                             <ul className="text-sm">
//                                                 {selectedCharacters.slice(0, 3).map(character => (
//                                                     <li key={character.name} className="flex items-center mb-1">
//                                                         <CheckCircle className="h-4 w-4 text-green-500 mr-1.5" />
//                                                         <span className="flex flex-col">
//                                                             <span>{character.name}</span>
//                                                             {character.actorName && (
//                                                                 <span className="text-xs text-gray-500">
//                                                                     Actor: {character.actorName || 'Unknown'}
//                                                                 </span>
//                                                             )}
//                                                         </span>
//                                                     </li>
//                                                 ))}
//                                                 {selectedCharacters.length > 3 && (
//                                                     <li className="text-gray-500 text-xs">
//                                                         +{selectedCharacters.length - 3} more
//                                                     </li>
//                                                 )}
//                                             </ul>
//                                         </div>
                                        
//                                         <div>
//                                             <h4 className="text-sm font-medium mb-2 flex items-center">
//                                                 <span className="mr-2">Locations</span>
//                                                 <span className="bg-green-100 text-green-800 text-xs font-medium px-2 py-0.5 rounded-full">
//                                                     {selectedLocations.length} selected
//                                                 </span>
//                                             </h4>
//                                             <ul className="text-sm">
//                                                 {selectedLocations.slice(0, 3).map(location => (
//                                                     <li key={location.id} className="flex items-center mb-1">
//                                                         <CheckCircle className="h-4 w-4 text-green-500 mr-1.5" />
//                                                         {location.region}
//                                                     </li>
//                                                 ))}
//                                                 {selectedLocations.length > 3 && (
//                                                     <li className="text-gray-500 text-xs">
//                                                         +{selectedLocations.length - 3} more
//                                                     </li>
//                                                 )}
//                                             </ul>
//                                         </div>
                                        
//                                         <div>
//                                             <h4 className="text-sm font-medium mb-2 flex items-center">
//                                                 <span className="mr-2">Brand Products</span>
//                                                 <span className="bg-green-100 text-green-800 text-xs font-medium px-2 py-0.5 rounded-full">
//                                                     {selectedProducts.length} selected
//                                                 </span>
//                                             </h4>
//                                             <ul className="text-sm">
//                                                 {selectedProducts.slice(0, 3).map(product => (
//                                                     <li key={product.id} className="flex items-center mb-1">
//                                                         <CheckCircle className="h-4 w-4 text-green-500 mr-1.5" />
//                                                         <span className="flex flex-col">
//                                                             <span>{product.productName || 'Unnamed product'}</span>
//                                                             <span className="text-xs text-gray-500">
//                                                                 Product Type: {product.productCategory || 'Unknown'}
//                                                             </span>
//                                                         </span>
//                                                     </li>
//                                                 ))}
//                                                 {selectedProducts.length > 3 && (
//                                                     <li className="text-gray-500 text-xs">
//                                                         +{selectedProducts.length - 3} more
//                                                     </li>
//                                                 )}
//                                             </ul>
//                                         </div>
//                                     </div>
                                    
//                                     <div className="flex justify-center">
//                                         <Button 
//                                             className="bg-green-600 hover:bg-green-700 text-white flex items-center gap-2"
//                                             size="lg"
//                                             disabled={selectedCharacters.length === 0 && selectedLocations.length === 0 && selectedProducts.length === 0}
//                                             onClick={openFinancialAnalysisModal}
//                                         >
//                                             <PieChart className="h-5 w-5" />
//                                             Project Financial Analysis
//                                         </Button>
//                                     </div>
//                                 </div>
//                             )}
//                         </>
//                     )}
//                 </div>
//             </div>
            
//             {/* Selection Info Modal */}
//             <Dialog 
//                 open={isSelectionInfoModalOpen}
//                 onOpenChange={setIsSelectionInfoModalOpen}
//             >
//                 <DialogContent className="max-w-3xl max-h-[80vh] overflow-y-auto">
//                     <DialogHeader>
//                         <DialogTitle>Selected Project Elements</DialogTitle>
//                         <DialogDescription>
//                             Overview of all selected characters, locations, and brand product placements.
//                         </DialogDescription>
//                     </DialogHeader>
                    
//                     <div className="space-y-6 py-4">
//                         <div>
//                             <h4 className="text-base font-semibold mb-2 flex items-center">
//                                 <span className="mr-2">Selected Cast</span>
//                                 <span className="bg-green-100 text-green-800 text-xs font-medium px-2 py-0.5 rounded-full">
//                                     {selectedCharacters.length} characters
//                                 </span>
//                             </h4>
//                             {selectedCharacters.length > 0 ? (
//                                 <div className="border rounded-md divide-y">
//                                     {selectedCharacters.map(character => (
//                                         <div key={character.name} className="p-3 flex justify-between items-center">
//                                             <div>
//                                                 <p className="font-medium">{character.name}</p>
//                                                 {character.actorName && (
//                                                     <p className="text-sm font-medium text-primary">Actor: {character.actorName}</p>
//                                                 )}
//                                                 {character.estimatedAgeRange && (
//                                                     <p className="text-sm text-gray-500">Estimated age: {character.estimatedAgeRange}</p>
//                                                 )}
//                                             </div>
//                                             <Button 
//                                                 variant="ghost" 
//                                                 size="sm" 
//                                                 onClick={() => handleCharacterSelection(character)}
//                                                 className="text-red-500 hover:text-red-700 hover:bg-red-50"
//                                             >
//                                                 Remove
//                                             </Button>
//                                         </div>
//                                     ))}
//                                 </div>
//                             ) : (
//                                 <p className="text-sm text-gray-500 italic">No characters selected yet.</p>
//                             )}
//                         </div>
                        
//                         <div>
//                             <h4 className="text-base font-semibold mb-2 flex items-center">
//                                 <span className="mr-2">Selected Filming Locations</span>
//                                 <span className="bg-green-100 text-green-800 text-xs font-medium px-2 py-0.5 rounded-full">
//                                     {selectedLocations.length} locations
//                                 </span>
//                             </h4>
//                             {selectedLocations.length > 0 ? (
//                                 <div className="border rounded-md divide-y">
//                                     {selectedLocations.map(location => (
//                                         <div key={location.id} className="p-3 flex justify-between items-center">
//                                             <div>
//                                                 <p className="font-medium">{location.region}, {location.country}</p>
//                                                 {location.incentiveProgram && (
//                                                     <p className="text-sm text-gray-500">{location.incentiveProgram}</p>
//                                                 )}
//                                                 {location.estimatedIncentiveValue && (
//                                                     <p className="text-sm text-green-600">Est. benefit: {location.estimatedIncentiveValue}</p>
//                                                 )}
//                                             </div>
//                                             <Button 
//                                                 variant="ghost" 
//                                                 size="sm" 
//                                                 onClick={() => handleLocationSelection(location)}
//                                                 className="text-red-500 hover:text-red-700 hover:bg-red-50"
//                                             >
//                                                 Remove
//                                             </Button>
//                                         </div>
//                                     ))}
//                                 </div>
//                             ) : (
//                                 <p className="text-sm text-gray-500 italic">No locations selected yet.</p>
//                             )}
//                         </div>
                        
//                         <div>
//                             <h4 className="text-base font-semibold mb-2 flex items-center">
//                                 <span className="mr-2">Selected Brand Products</span>
//                                 <span className="bg-green-100 text-green-800 text-xs font-medium px-2 py-0.5 rounded-full">
//                                     {selectedProducts.length} placements
//                                 </span>
//                             </h4>
//                             {selectedProducts.length > 0 ? (
//                                 <div className="border rounded-md divide-y">
//                                     {selectedProducts.map(product => (
//                                         <div key={product.id} className="p-3 flex justify-between items-start">
//                                             <div className="flex gap-3">
//                                                 {product.imageUrl && (
//                                                     <div 
//                                                         className="w-24 h-24 bg-gray-100 rounded overflow-hidden flex-shrink-0 cursor-pointer"
//                                                         onClick={() => handleImageZoom(product.imageUrl, product.productName || 'Product image')}
//                                                     >
//                                                         <img 
//                                                             src={product.imageUrl} 
//                                                             alt={product.productName || 'Product placement'} 
//                                                             className="w-full h-full object-cover"
//                                                         />
//                                                     </div>
//                                                 )}
//                                                 <div>
//                                                     <p className="font-medium">{product.productName || 'Unnamed product'}</p>
//                                                     {product.productCategory && (
//                                                         <p className="text-sm font-medium text-primary">Product Type: {product.productCategory}</p>
//                                                     )}
//                                                     <p className="text-sm text-gray-500">Scene: {
//                                                         scenes.find(s => s.id === product.sceneId)?.sceneNumber || product.sceneId
//                                                     }</p>
//                                                     {videoGenerationStates[product.id]?.videoUrl && (
//                                                         <Button 
//                                                             variant="outline" 
//                                                             size="sm"
//                                                             className="mt-2 text-xs"
//                                                             onClick={() => handleViewVideo(
//                                                                 videoGenerationStates[product.id].videoUrl || '',
//                                                                 `${product.productName} - Scene ${scenes.find(s => s.id === product.sceneId)?.sceneNumber || product.sceneId}`
//                                                             )}
//                                                         >
//                                                             <PlayCircle className="h-3 w-3 mr-1" />
//                                                             View Video
//                                                         </Button>
//                                                     )}
//                                                 </div>
//                                             </div>
//                                             <Button 
//                                                 variant="ghost" 
//                                                 size="sm" 
//                                                 onClick={() => handleProductSelection(product)}
//                                                 className="text-red-500 hover:text-red-700 hover:bg-red-50"
//                                             >
//                                                 Remove
//                                             </Button>
//                                         </div>
//                                     ))}
//                                 </div>
//                             ) : (
//                                 <p className="text-sm text-gray-500 italic">No brand products selected yet.</p>
//                             )}
//                         </div>
//                     </div>
                    
//                     <DialogFooter>
//                         <Button variant="outline" onClick={closeSelectionInfoModal}>Close</Button>
//                     </DialogFooter>
//                 </DialogContent>
//             </Dialog>
            
//             <VideoPlayerModal
//                 isOpen={isVideoModalOpen}
//                 onClose={handleCloseVideoModal}
//                 videoUrl={currentVideoUrl}
//                 title={currentVideoTitle}
//             />
//             <ImageZoomModal
//                 isOpen={isImageZoomModalOpen}
//                 onClose={handleCloseImageZoomModal}
//                 imageUrl={zoomedImageUrl}
//                 title={zoomedImageTitle}
//             />
            
//             {/* Financial Analysis Modal */}
//             <Dialog 
//                 open={isFinancialAnalysisModalOpen}
//                 onOpenChange={setIsFinancialAnalysisModalOpen}
//             >
//                 <DialogContent className="max-w-3xl max-h-[80vh] overflow-y-auto">
//                     <DialogHeader>
//                         <DialogTitle>Project Financial Analysis</DialogTitle>
//                         <DialogDescription>
//                             Complete the key project information to generate a financial analysis.
//                         </DialogDescription>
//                     </DialogHeader>
                    
//                     <div className="space-y-6 py-4">
//                         <div className="space-y-4">
//                             <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
//                                 <div className="space-y-2">
//                                     <Label htmlFor="project-name">Project Name</Label>
//                                     <Input 
//                                         id="project-name" 
//                                         value={projectName} 
//                                         onChange={(e) => setProjectName(e.target.value)}
//                                         placeholder="Enter project name"
//                                     />
//                                 </div>
//                                 <div className="space-y-2">
//                                     <Label htmlFor="release-date">Expected Release Date</Label>
//                                     <Input 
//                                         id="release-date" 
//                                         type="date" 
//                                         value={expectedReleaseDate} 
//                                         onChange={(e) => setExpectedReleaseDate(e.target.value)}
//                                     />
//                                 </div>
//                             </div>
                            
//                             <div className="space-y-2">
//                                 <Label htmlFor="budget">Total Budget ($)</Label>
//                                 <Input 
//                                     id="budget" 
//                                     type="number" 
//                                     value={totalBudget} 
//                                     onChange={(e) => setTotalBudget(Number(e.target.value))}
//                                     placeholder="Enter total budget"
//                                 />
//                             </div>
//                         </div>
                        
//                         <div className="rounded-lg border p-4 bg-muted/30">
//                             <h3 className="text-lg font-medium mb-2 flex items-center">
//                                 <BarChart className="h-5 w-5 mr-2 text-primary" />
//                                 Project Summary
//                             </h3>
//                             <div className="space-y-3">
//                                 <p><strong>Selected Cast:</strong> {selectedCharacters.length} characters</p>
//                                 <p><strong>Selected Locations:</strong> {selectedLocations.length} locations</p>
//                                 <p><strong>Selected Brand Placements:</strong> {selectedProducts.length} placements</p>
//                             </div>
//                         </div>
                        
//                         {selectedProducts.length > 0 && (
//                             <div>
//                                 <h3 className="text-lg font-medium mb-3 flex items-center">
//                                     <ImageIcon className="h-5 w-5 mr-2 text-primary" />
//                                     Selected Assets for Export
//                                 </h3>
//                                 <div className="space-y-4">
//                                     {/* Images Section */}
//                                     <div>
//                                         <h4 className="text-md font-medium mb-2">Images</h4>
//                                         <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2">
//                                             {selectedProducts.filter(p => p.imageUrl).map(product => (
//                                                 <div 
//                                                     key={`img-${product.id}`}
//                                                     className="aspect-video bg-gray-100 rounded overflow-hidden relative group cursor-pointer"
//                                                     onClick={() => handleImageZoom(product.imageUrl || '', product.productName || 'Product')}
//                                                 >
//                                                     <img 
//                                                         src={product.imageUrl} 
//                                                         alt={product.productName || 'Product placement'} 
//                                                         className="w-full h-full object-cover"
//                                                     />
//                                                     <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
//                                                         <ZoomIn className="h-6 w-6 text-white" />
//                                                     </div>
//                                                 </div>
//                                             ))}
//                                         </div>
//                                     </div>
                                    
//                                     {/* Videos Section */}
//                                     {selectedProducts.some(p => videoGenerationStates[p.id]?.videoUrl) && (
//                                         <div>
//                                             <h4 className="text-md font-medium mb-2">Videos</h4>
//                                             <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-2">
//                                                 {selectedProducts
//                                                     .filter(p => videoGenerationStates[p.id]?.videoUrl)
//                                                     .map(product => (
//                                                         <div 
//                                                             key={`vid-${product.id}`}
//                                                             className="bg-gray-100 rounded overflow-hidden relative group border"
//                                                         >
//                                                             <div className="p-2 flex justify-between items-center">
//                                                                 <span className="text-sm font-medium truncate">
//                                                                     {product.productName || 'Video'} - Scene {
//                                                                         scenes.find(s => s.id === product.sceneId)?.sceneNumber || product.sceneId
//                                                                     }
//                                                                 </span>
//                                                                 <Button
//                                                                     variant="ghost"
//                                                                     size="sm"
//                                                                     onClick={() => handleViewVideo(
//                                                                         videoGenerationStates[product.id]?.videoUrl || '',
//                                                                         `${product.productName} - Scene ${scenes.find(s => s.id === product.sceneId)?.sceneNumber || product.sceneId}`
//                                                                     )}
//                                                                 >
//                                                                     <PlayCircle className="h-4 w-4" />
//                                                                 </Button>
//                                                             </div>
//                                                         </div>
//                                                     ))
//                                                 }
//                                             </div>
//                                         </div>
//                                     )}
//                                 </div>
//                             </div>
//                         )}
//                     </div>
                    
//                     <DialogFooter className="flex justify-between items-center">
//                         <Button variant="outline" onClick={closeFinancialAnalysisModal}>Cancel</Button>
//                         <Button 
//                             onClick={closeFinancialAnalysisModal}
//                             disabled={selectedProducts.length === 0 || !projectName || !expectedReleaseDate || !totalBudget}
//                         >
//                             Export Project Assets
//                         </Button>
//                     </DialogFooter>
//                 </DialogContent>
//             </Dialog>
//         </>
//     );
// }


// client/src/pages/ScriptEditor.tsx
import { useState, useEffect, useRef, useCallback } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import SceneBreakdown from "@/components/script/SceneBreakdown";
import ScriptDisplay from "@/components/script/ScriptDisplay";
import BrandableScenes from "@/components/script/BrandableScenes";
import VideoPlayerModal from "@/components/script/VideoPlayerModal";
import ImageZoomModal from "@/components/script/ImageZoomModal";
import SuggestedLocations from "@/components/script/SuggestedLocations";
import CharacterCasting from "@/components/script/CharacterCasting";
// --- BEGIN MODIFICATION (Task 1.4) ---
import FinancialAnalysisModal from "@/components/script/FinancialAnalysisModal";
// --- END MODIFICATION (Task 1.4) ---

import {
    Script,
    Scene,
    // SceneVariation as SharedSceneVariation, // Not directly used, Client type used
    // Actor, // Not directly used, Client type used
    // Location, // Not directly used, Client type used
    // Product, // Not directly used, Client type used
} from "@shared/schema";
import { 
    Info, 
    Loader2, 
    AlertTriangle, 
    DollarSign, 
    PieChart, 
    BarChart, 
    // ChevronDown, // Not used currently
    CheckCircle, 
    ImageIcon,
    ZoomIn,
    PlayCircle
} from "lucide-react";
import { SceneVariation, ScriptCharacter, ClientSuggestedLocation, FinancialBreakdown } from "@/lib/types"; // Added FinancialBreakdown
import { 
    Dialog, 
    DialogContent, 
    DialogDescription, 
    DialogHeader, 
    DialogTitle,
    // DialogTrigger, // Not used currently
    DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";


type VideoGenerationStatus =
    | "idle"
    | "pending"
    | "generating"
    | "succeeded"
    | "failed";
interface VideoGenerationState {
    status: VideoGenerationStatus;
    predictionId?: string | null;
    videoUrl?: string | null;
    error?: string | null;
    logs?: string | null;
    progress?: number;
    stageMessage?: string;
}

interface PredictionStatusResult {
    status: VideoGenerationStatus;
    outputUrl?: string | null;
    error?: string | null;
    logs?: string | null;
}

const DEFAULT_PROJECT_BUDGET = 1000000; // This will be overridden by DB value if present
const DEFAULT_FILM_GENRE = "ACTION";

export default function ScriptEditor() {
    const [activeSceneId, setActiveSceneId] = useState<number | null>(null);
    const { toast } = useToast();
    const queryClient = useQueryClient();
    const [isExporting, setIsExporting] = useState(false); // Keep for future PDF/Asset export
    const [videoGenerationStates, setVideoGenerationStates] = useState<{
        [key: number]: VideoGenerationState;
    }>({});
    const [isVideoModalOpen, setIsVideoModalOpen] = useState(false);
    const [currentVideoUrl, setCurrentVideoUrl] = useState<string | null>(null);
    const [currentVideoTitle, setCurrentVideoTitle] = useState<string>("");

    const [isImageZoomModalOpen, setIsImageZoomModalOpen] = useState(false);
    const [zoomedImageUrl, setZoomedImageUrl] = useState<string | null>(null);
    const [zoomedImageTitle, setZoomedImageTitle] = useState<string>("");

    const [selectedCharacters, setSelectedCharacters] = useState<ScriptCharacter[]>([]);
    const [selectedLocations, setSelectedLocations] = useState<ClientSuggestedLocation[]>([]);
    const [selectedProducts, setSelectedProducts] = useState<SceneVariation[]>([]);

    // --- BEGIN MODIFICATION (Task 1.4) ---
    const [isFinancialAnalysisModalOpen, setIsFinancialAnalysisModalOpen] = useState(false);
    // projectBudget state is now primarily for display/UI interaction for location suggestions,
    // the actual budget for financial analysis will come from the script record.
    const [projectBudgetForUISuggestions, setProjectBudgetForUISuggestions] = useState<number | undefined>(
        DEFAULT_PROJECT_BUDGET,
    );
    // --- END MODIFICATION (Task 1.4) ---

    const [isSelectionInfoModalOpen, setIsSelectionInfoModalOpen] = useState(false);
    // const [projectName, setProjectName] = useState<string>(""); // This was for old financial modal, remove if not used elsewhere
    // const [expectedReleaseDate, setExpectedReleaseDate] = useState<string>(""); // Remove
    // const [totalBudget, setTotalBudget] = useState<number>(DEFAULT_PROJECT_BUDGET); // Remove

    const pollingIntervals = useRef<{ [key: string]: NodeJS.Timeout }>({});

    // filmGenreForCasting and projectBudgetTierForCasting are derived from script or UI inputs
    const [filmGenreForCasting, setFilmGenreForCasting] = useState<string>(DEFAULT_FILM_GENRE);
    const [projectBudgetTierForCasting, setProjectBudgetTierForCasting] = useState<"low" | "medium" | "high" | "any">("medium");

    // Queries
    const {
        data: script,
        isLoading: isLoadingScript,
        isError: isScriptError,
        error: scriptError,
    } = useQuery<Script | null>({
        queryKey: ["/api/scripts/current"],
        refetchOnWindowFocus: false,
        onSuccess: (data) => {
            if (data && data.totalBudget !== null && data.totalBudget !== undefined) {
                setProjectBudgetForUISuggestions(data.totalBudget);
            } else {
                setProjectBudgetForUISuggestions(DEFAULT_PROJECT_BUDGET);
            }
             // Potentially set filmGenreForCasting from script data if available in future
        }
    });

    // ... (other queries: scenes, brandableScenes, sceneVariations, scriptCharacters remain the same)
    const { data: scenes = [], isLoading: isLoadingScenes } = useQuery<Scene[]>({
        queryKey: ["/api/scripts/scenes", script?.id],
        enabled: !!script?.id,
    });

    const {
        data: brandableSceneObjects = [],
        isLoading: isLoadingBrandableScenes,
        refetch: refetchBrandableScenes,
    } = useQuery<Scene[]>({
        queryKey: ["/api/scripts/brandable-scenes", script?.id],
        enabled: !!script?.id && scenes.length > 0,
    });
    const brandableSceneIds = brandableSceneObjects.map((scene) => scene.id);

    // VFX scenes query
    const {
        data: vfxScenesWithDetails = [],
        isLoading: isLoadingVfxScenes,
        refetch: refetchVfxScenes,
    } = useQuery<any[]>({
        queryKey: ["/api/scripts/vfx-scenes", script?.id],
        enabled: !!script?.id,
    });

    const {
        data: sceneVariations = [],
        isLoading: isLoadingVariations,
        isFetching: isFetchingVariations,
    } = useQuery<SceneVariation[]>({
        queryKey: ["/api/scripts/scene-variations", activeSceneId],
        enabled: !!activeSceneId,
        staleTime: 1 * 60 * 1000,
        refetchOnWindowFocus: false,
        onSuccess: (data) => {
            if (activeSceneId && data.length > 0) {
                const currentSceneObject = scenes.find(
                    (s) => s.id === activeSceneId,
                );
                if (
                    currentSceneObject &&
                    !brandableSceneIds.includes(activeSceneId)
                ) {
                    refetchBrandableScenes();
                }
            }
        },
    });

    const {
        data: scriptCharacters = [], // This is the list of characters from the script
        isLoading: isLoadingScriptCharacters,
    } = useQuery<ScriptCharacter[]>({ // Type might need adjustment if backend changed response
        queryKey: ["/api/scripts/characters", script?.id],
        queryFn: async ({ queryKey }) => {
            const [, sId] = queryKey as [string, number | undefined];
            if (!sId) return [];
            const res = await apiRequest(
                "GET",
                `/api/scripts/${sId}/characters`,
            );
            return res.json();
        },
        enabled: !!script?.id,
    });


    useEffect(() => {
        setActiveSceneId(null);
        setVideoGenerationStates({});
        // setProjectBudgetForUISuggestions(script?.totalBudget ?? DEFAULT_PROJECT_BUDGET); // Set from script on script change
        Object.values(pollingIntervals.current).forEach(clearInterval);
        pollingIntervals.current = {};
    }, [script?.id]);

    useEffect(() => {
        setVideoGenerationStates({});
        Object.values(pollingIntervals.current).forEach(clearInterval);
        pollingIntervals.current = {};
    }, [activeSceneId]);

    useEffect(() => {
        const budget = script?.totalBudget ?? projectBudgetForUISuggestions;
        if (budget === undefined || budget === null || isNaN(budget) ) {
            setProjectBudgetTierForCasting("any");
        } else if (budget < 1000000) {
            setProjectBudgetTierForCasting("low");
        } else if (budget <= 20000000) {
            setProjectBudgetTierForCasting("medium");
        } else {
            setProjectBudgetTierForCasting("high");
        }
    }, [projectBudgetForUISuggestions, script?.totalBudget]);


    // ... (mutations: reanalyzeScriptMutation, generatePlacementsMutation remain the same)
    const reanalyzeScriptMutation = useMutation({
        mutationFn: async () => apiRequest("POST", "/api/scripts/analyze", {}),
        onSuccess: () => {
            toast({
                title: "Analysis complete",
                description: "Script re-analyzed.",
            });
            queryClient.invalidateQueries({ queryKey: ["/api/scripts/brandable-scenes", script?.id] });
            queryClient.invalidateQueries({ queryKey: ["/api/scripts/scenes", script?.id] });
            queryClient.invalidateQueries({ queryKey: ["/api/scripts/characters", script?.id] });
            if (activeSceneId) {
                queryClient.invalidateQueries({ queryKey: ["/api/scripts/scene-variations", activeSceneId] });
            }
        },
        onError: (error: Error) => {
            toast({ variant: "destructive", title: "Analysis failed", description: error.message });
        },
    });

    const analyzeVfxMutation = useMutation({
        mutationFn: async () => {
            if (!script?.id) throw new Error("No script available");
            return apiRequest("POST", `/api/scripts/${script.id}/initiate-vfx-analysis`, {});
        },
        onSuccess: () => {
            toast({
                title: "VFX Analysis Complete",
                description: "VFX scenes have been analyzed and identified.",
            });
            queryClient.invalidateQueries({ queryKey: ["/api/scripts/scenes", script?.id] });
            queryClient.invalidateQueries({ queryKey: ["/api/scripts/brandable-scenes", script?.id] });
        },
        onError: (error: Error) => {
            toast({ 
                variant: "destructive", 
                title: "VFX Analysis Failed", 
                description: error.message 
            });
        },
    });

    const generatePlacementsMutation = useMutation({
        mutationFn: async () => {
            if (activeSceneId) {
                return queryClient.invalidateQueries({ queryKey: ["/api/scripts/scene-variations", activeSceneId] });
            }
            return queryClient.invalidateQueries({ queryKey: ["/api/scripts/scene-variations"] });
        },
        onSuccess: () => {
            toast({ title: "Placement Generation Triggered", description: "Visual options will be generated for the selected scene." });
        },
        onError: (error: Error) => {
            toast({ variant: "destructive", title: "Generation Trigger Failed", description: error.message });
        },
    });

    // VFX tier selection mutation
    const selectVfxTierMutation = useMutation({
        mutationFn: async ({ sceneId, qualityTier }: { sceneId: number; qualityTier: string }) => {
            return apiRequest(`/api/scenes/${sceneId}/select-vfx-tier`, {
                method: "PUT",
                body: JSON.stringify({ qualityTier }),
                headers: { "Content-Type": "application/json" },
            });
        },
        onSuccess: (data) => {
            toast({
                title: "VFX Tier Selected",
                description: `${data.selectedTier} quality tier selected with cost $${data.selectedCost?.toLocaleString() || 0}`,
            });
            // Invalidate queries to refresh data
            queryClient.invalidateQueries({ queryKey: ["/api/scripts/scenes"] });
            queryClient.invalidateQueries({ queryKey: ["/api/scripts/vfx-scenes"] });
        },
        onError: (error: Error) => {
            console.error("VFX tier selection failed:", error);
            toast({
                title: "VFX Tier Selection Failed",
                description: error.message || "An unknown error occurred.",
                variant: "destructive",
            });
        },
    });


    // ... (video polling logic: stopPollingPrediction, pollPredictionStatus, startPollingPrediction, and startVideoGenerationMutation remain the same)
    const stopPollingPrediction = useCallback((predictionId: string) => {
        if (pollingIntervals.current[predictionId]) {
            clearInterval(pollingIntervals.current[predictionId]);
            delete pollingIntervals.current[predictionId];
        }
    }, []);

    const pollPredictionStatus = useCallback(
        async (predictionId: string, variationId: number) => {
            try {
                const response = await fetch(`/api/replicate/predictions/${predictionId}`);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API error ${response.status}: ${errorText || "Failed to fetch status"}`);
                }
                const data: PredictionStatusResult = await response.json();

                setVideoGenerationStates((prev) => {
                    const currentState = prev[variationId];
                    if (!currentState || currentState.predictionId !== predictionId || currentState.status === "succeeded" || currentState.status === "failed") {
                        stopPollingPrediction(predictionId);
                        return prev;
                    }
                    let progress = currentState.progress || 0;
                    let stageMessage = currentState.stageMessage || "Processing...";
                    let updatedStatus = currentState.status;

                    switch (data.status) {
                        case "starting": progress = 30; stageMessage = "Initializing video engine..."; updatedStatus = "generating"; break;
                        case "processing":
                            progress = Math.max(progress || 0, 50); updatedStatus = "generating";
                            if (data.logs) {
                                if (data.logs.toLowerCase().includes("frame generation")) { progress = 65; stageMessage = "Creating video frames..."; }
                                if (data.logs.toLowerCase().includes("upscaling")) { progress = 85; stageMessage = "Enhancing video quality..."; }
                            } else { stageMessage = "Processing your video..."; }
                            break;
                        case "succeeded": progress = 100; stageMessage = "Video ready!"; updatedStatus = "succeeded"; break;
                        case "failed": case "canceled":
                            progress = 0; stageMessage = data.error ? `Failed: ${String(data.error).substring(0, 50)}...` : "Generation failed."; updatedStatus = "failed"; break;
                    }
                    const newStateUpdate: VideoGenerationState = {
                        ...currentState, status: updatedStatus, videoUrl: data.outputUrl ?? currentState.videoUrl,
                        error: data.error ? String(data.error) : null, logs: data.logs ?? null, progress: progress, stageMessage: stageMessage,
                    };
                    if (["succeeded", "failed", "canceled"].includes(data.status)) {
                        stopPollingPrediction(predictionId);
                        if (data.status === "succeeded") {
                            if (!data.outputUrl) {
                                toast({ title: "Video Processed", description: `Video for var ${variationId} finished, but no URL.`, variant: "destructive" });
                                newStateUpdate.status = "failed"; newStateUpdate.error = "Succeeded but no output URL.";
                            } else {
                                toast({ title: "Video Ready!", description: `Video for variation ${variationId} is now available. Click "View Video" to watch it.`, duration: 6000 });
                            }
                        } else {
                            toast({ title: "Video Failed", description: `Video for var ${variationId} failed: ${data.error || "Unknown"}.`, variant: "destructive" });
                        }
                    }
                    return { ...prev, [variationId]: newStateUpdate };
                });
            } catch (error: any) {
                stopPollingPrediction(predictionId);
                setVideoGenerationStates((prev) => {
                    const currentState = prev[variationId];
                    if (currentState && currentState.predictionId === predictionId) {
                        return { ...prev, [variationId]: { ...currentState, status: "failed", error: `Polling failed: ${error.message}`, progress: 0, stageMessage: "Polling Error" }};
                    }
                    return prev;
                });
                toast({ variant: "destructive", title: "Polling Error", description: `Could not get video status: ${error.message}` });
            }
        }, [stopPollingPrediction, toast]
    );

    const startPollingPrediction = useCallback(
        (predictionId: string, variationId: number) => {
            if (pollingIntervals.current[predictionId]) return;
            const initialTimeout = setTimeout(() => pollPredictionStatus(predictionId, variationId), 2000);
            pollingIntervals.current[predictionId] = setInterval(() => pollPredictionStatus(predictionId, variationId), 5000);
        }, [pollPredictionStatus]
    );

    useEffect(() => {
        return () => { Object.values(pollingIntervals.current).forEach(clearInterval); pollingIntervals.current = {}; };
    }, []);

    const startVideoGenerationMutation = useMutation({
        mutationFn: async (variationId: number) => {
            setVideoGenerationStates((prev) => ({ ...prev, [variationId]: { status: "pending", error: null, videoUrl: null, predictionId: null, progress: 10, stageMessage: "Queueing video..." }}));
            toast({ title: "Starting Video Generation", description: "Connecting to video service...", duration: 3000 });
            const response = await apiRequest("POST", `/api/variations/${variationId}/generate-video`, {});
            const data = await response.json();
            return { variationId, responseData: data };
        },
        onSuccess: (result) => {
            const { variationId, responseData } = result;
            if (responseData.predictionId && responseData.status && !["failed", "canceled"].includes(responseData.status)) {
                setVideoGenerationStates((prev) => ({ ...prev, [variationId]: { status: "generating", predictionId: responseData.predictionId, error: null, videoUrl: null, progress: 20, stageMessage: "Creating your video..." }}));
                startPollingPrediction(responseData.predictionId, variationId);
                toast({ title: "Video Generation Started", description: `Processing has begun. The button will update when your video is ready.`, duration: 5000 });
            } else {
                const errorMsg = responseData.message || responseData.error || "Failed to get valid prediction ID.";
                setVideoGenerationStates((prev) => ({ ...prev, [variationId]: { status: "failed", error: errorMsg, predictionId: responseData.predictionId || null, progress: 0, stageMessage: `Error: ${String(errorMsg).substring(0, 30)}...` }}));
                toast({ title: "Video Start Failed", description: errorMsg, variant: "destructive" });
            }
        },
        onError: (error: Error, variationId) => {
            setVideoGenerationStates((prev) => ({ ...prev, [variationId]: { status: "failed", error: `Failed to start: ${error.message}`, predictionId: null, progress: 0, stageMessage: "Request Error" }}));
            toast({ variant: "destructive", title: "Request Error", description: `Could not start video generation for var ${variationId}: ${error.message}` });
        },
    });


    const handleExport = async () => { console.log("Export triggered"); setIsExporting(true); setIsExporting(false); };
    const handleSceneSelect = (sceneId: number) => { if (activeSceneId !== sceneId) setActiveSceneId(sceneId); };
    const handleViewVideo = (videoUrl: string, title: string) => { setCurrentVideoUrl(videoUrl); setCurrentVideoTitle(title); setIsVideoModalOpen(true); };
    const handleCloseVideoModal = () => { setIsVideoModalOpen(false); setCurrentVideoUrl(null); setCurrentVideoTitle(""); };
    const handleImageZoom = (imageUrl: string, title: string) => { setZoomedImageUrl(imageUrl); setZoomedImageTitle(title); setIsImageZoomModalOpen(true); };
    const handleCloseImageZoomModal = () => { setIsImageZoomModalOpen(false); setZoomedImageUrl(null); setZoomedImageTitle(""); };

    const handleCharacterSelection = (character: ScriptCharacter) => { setSelectedCharacters(prev => { const exists = prev.some(c => c.name === character.name); if (exists) { return prev.filter(c => c.name !== character.name); } else { return [...prev, character]; } }); };
    const handleLocationSelection = (location: ClientSuggestedLocation) => { setSelectedLocations(prev => { const exists = prev.some(l => l.id === location.id); if (exists) { return prev.filter(l => l.id !== location.id); } else { return [...prev, location]; } }); };
    const handleProductSelection = (product: SceneVariation) => { setSelectedProducts(prev => { const exists = prev.some(p => p.id === product.id); if (exists) { return prev.filter(p => p.id !== product.id); } else { return [...prev, product]; } }); };

    // VFX tier selection handler
    const handleVfxTierSelect = (sceneId: number, tier: string, cost: number) => {
        selectVfxTierMutation.mutate({ sceneId, qualityTier: tier });
    };

    const openSelectionInfoModal = () => { setIsSelectionInfoModalOpen(true); };

    // --- BEGIN MODIFICATION (Task 1.4) ---
    const openFinancialAnalysisModal = () => {
        if (script?.id) {
            setIsFinancialAnalysisModalOpen(true);
        } else {
            toast({ title: "No Script Loaded", description: "Cannot open financial analysis without a script.", variant: "destructive" });
        }
    };
    // --- END MODIFICATION (Task 1.4) ---

    const activeSceneObject = scenes.find((s: Scene) => s.id === activeSceneId);
    const isPageLoading = isLoadingScript;
    const isLoadingCurrentVariations = !!activeSceneId && (isLoadingVariations || isFetchingVariations);
    const displayScript = script ? { id: script.id, title: script.title, content: script.content } : null;

    if (isPageLoading) { /* ... (loading skeleton remains the same) ... */ 
        return (
            <div className="space-y-6 p-4 animate-pulse">
                <div className="h-8 bg-gray-200 rounded w-1/3 mb-4"></div>
                <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
                    <div className="lg:col-span-1 space-y-2">
                        <div className="h-6 bg-gray-200 rounded w-3/4"></div>
                        {Array.from({ length: 5 }).map((_, i) => (
                            <div key={i} className="h-10 bg-gray-200 rounded"></div>
                        ))}
                    </div>
                    <div className="lg:col-span-3 space-y-6">
                        <div className="h-64 bg-gray-200 rounded"></div>
                        <div className="h-96 bg-gray-200 rounded"></div>
                    </div>
                </div>
            </div>
        );
    }
    if (isScriptError && !script) { /* ... (error display remains the same) ... */ 
        return (
            <div className="p-6 text-center text-red-600 flex flex-col items-center justify-center h-full">
                <AlertTriangle className="h-12 w-12 mb-4" />
                <h2 className="text-xl font-semibold">Error Loading Script</h2>
                <p>{(scriptError as Error)?.message || "An unknown error occurred. Please try again later."}</p>
            </div>
        );
    }
    if (!script) { /* ... (no script display remains the same) ... */ 
        return (
            <div className="p-6 text-center text-gray-500 flex flex-col items-center justify-center h-full">
                <Info className="h-12 w-12 mb-4" />
                <h2 className="text-xl font-semibold">No Script Loaded</h2>
                <p>Please upload a script via the Welcome page to begin.</p>
            </div>
        );
    }

    return (
        <>
            {script && (
                <div className="flex justify-between items-center mb-4 px-1">
                    <h1 className="text-2xl font-bold text-gray-800">
                        Script Analysis: <span className="text-primary">{script.title}</span>
                    </h1>
                    <div className="flex items-center gap-2">
                        {/* --- BEGIN MODIFICATION (Task 1.4) --- */}
                        <Button 
                            variant="default" // Make it more prominent
                            size="sm"
                            onClick={openFinancialAnalysisModal}
                            disabled={!script?.id}
                            className="flex items-center gap-1 bg-green-600 hover:bg-green-700 text-white"
                            title="View Project Financial Analysis"
                        >
                            <PieChart className="h-4 w-4" />
                            Financials
                        </Button>
                        {/* --- END MODIFICATION (Task 1.4) --- */}
                        <Button 
                            variant="outline" 
                            size="sm" 
                            onClick={openSelectionInfoModal}
                            className="flex items-center gap-2"
                        >
                            <Info className="h-4 w-4" />
                            Summary
                        </Button>
                    </div>
                </div>
            )}
            {/* ... (rest of the JSX for SceneBreakdown, ScriptDisplay, BrandableScenes, etc.) */}
            <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
                <SceneBreakdown
                    scenes={scenes}
                    activeSceneId={activeSceneId}
                    projectTitle={script?.title}
                    brandableSceneIds={brandableSceneIds || []}
                    isLoading={isLoadingScenes || isLoadingBrandableScenes}
                    onSceneSelect={handleSceneSelect}
                />
                <div className="lg:col-span-3 space-y-6">
                    <div className="bg-white rounded-lg shadow p-4">
                        <ScriptDisplay
                            script={displayScript}
                            isLoading={false}
                            onSave={async () => { console.warn("Save not implemented"); }}
                            onReanalyze={() => reanalyzeScriptMutation.mutate()}
                            onAnalyzeVfx={() => analyzeVfxMutation.mutate()}
                            onGeneratePlacements={() => generatePlacementsMutation.mutate()}
                            onExport={handleExport}
                            activeScene={activeSceneObject || null}
                            isSaving={false}
                            isReanalyzing={reanalyzeScriptMutation.isPending}
                            isAnalyzingVfx={analyzeVfxMutation.isPending}
                            isGenerating={generatePlacementsMutation.isPending}
                            isExporting={isExporting}
                        />
                    </div>
                    {scenes.length > 0 && activeSceneId !== null && activeSceneObject ? (
                        <>
                            <div className="bg-white rounded-lg shadow p-4">
                                <BrandableScenes
                                    activeSceneDetails={activeSceneObject}
                                    projectTitle={script?.title}
                                    scenes={scenes}
                                    productVariations={sceneVariations}
                                    isLoading={isLoadingCurrentVariations}
                                    selectedSceneId={activeSceneId}
                                    onGenerateVideoRequest={(variationId) => startVideoGenerationMutation.mutate(variationId)}
                                    videoGenerationStates={videoGenerationStates}
                                    onViewVideo={handleViewVideo}
                                    onImageZoom={handleImageZoom}
                                    selectedProducts={selectedProducts}
                                    onProductSelect={handleProductSelection}
                                />
                            </div>
                            

                        </>
                    ) : (
                        activeSceneId === null && scenes.length > 0 && (
                            <div className="bg-white rounded-lg shadow p-6 text-center text-gray-500">
                                <Info className="inline-block mr-2 h-5 w-5" />
                                Select a scene from the breakdown list to view details and placement options.
                            </div>
                        )
                    )}
                    {script && (
                        <>
                            <div className="my-6 border-t border-gray-200"></div>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div className="bg-white rounded-lg shadow p-4">
                                    <h3 className="text-lg font-semibold text-foreground mb-3">
                                        Optimizing funding: Suggested Filming Locations & Incentives
                                    </h3>
                                    <div className="mb-4">
                                        <label htmlFor="projectBudgetForUISuggestions" className="text-sm font-medium text-gray-700">
                                            Filter Locations by Estimated Project Budget ($)
                                        </label>
                                        <div className="flex items-center space-x-2 mt-1">
                                            <DollarSign className="h-5 w-5 text-gray-400" />
                                            <Input
                                                id="projectBudgetForUISuggestions" type="number"
                                                value={projectBudgetForUISuggestions === undefined ? "" : projectBudgetForUISuggestions}
                                                onChange={(e) => {
                                                    const val = e.target.value;
                                                    setProjectBudgetForUISuggestions(val === "" ? undefined : parseInt(val, 10));
                                                }}
                                                placeholder="e.g., 1000000"
                                                className="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-primary focus:border-primary sm:text-sm"
                                                step="100000"
                                            />
                                        </div>
                                        <p className="text-xs text-muted-foreground mt-1">This budget is used to filter location suggestions. The official project budget is set on the Welcome page.</p>
                                    </div>
                                    <SuggestedLocations
                                        scriptId={script?.id || null}
                                        projectBudget={projectBudgetForUISuggestions}
                                        isLoading={isLoadingScenes}
                                        selectedLocations={selectedLocations}
                                        onLocationSelect={handleLocationSelection}
                                    />
                                </div>
                                <div className="bg-white rounded-lg shadow p-4">
                                    <h3 className="text-lg font-semibold text-foreground mb-3">
                                        Character Casting Suggestions
                                    </h3>
                                    <CharacterCasting
                                        scriptId={script?.id || null}
                                        isLoading={isLoadingScriptCharacters} // Pass the correct loading state
                                        filmGenre={filmGenreForCasting}
                                        projectBudgetTier={projectBudgetTierForCasting}
                                        selectedCharacters={selectedCharacters}
                                        onCharacterSelect={handleCharacterSelection}
                                    />
                                </div>
                            </div>

                            {/* Selection summary - this UI part can be reused or adapted for the Financial Analysis Modal trigger */}
                            {/* The button to open financial analysis is now at the top */}
                        </>
                    )}
                </div>
            </div>

            {/* --- BEGIN MODIFICATION (Task 1.4) --- */}
            {/* Render Financial Analysis Modal */}
            <FinancialAnalysisModal
                isOpen={isFinancialAnalysisModalOpen}
                onClose={() => setIsFinancialAnalysisModalOpen(false)}
                scriptId={script?.id || null}
                scriptTitle={script?.title}
            />
            {/* --- END MODIFICATION (Task 1.4) --- */}

            {/* Selection Info Modal */}
            <Dialog open={isSelectionInfoModalOpen} onOpenChange={setIsSelectionInfoModalOpen}>
                {/* ... (SelectionInfoModal content remains the same) ... */}
                <DialogContent className="max-w-3xl max-h-[80vh] overflow-y-auto">
                    <DialogHeader>
                        <DialogTitle>Selected Project Elements</DialogTitle>
                        <DialogDescription>Overview of all selected characters, locations, and brand product placements.</DialogDescription>
                    </DialogHeader>
                    <div className="space-y-6 py-4">
                        <div>
                            <h4 className="text-base font-semibold mb-2 flex items-center">
                                <span className="mr-2">Selected Cast</span>
                                <span className="bg-green-100 text-green-800 text-xs font-medium px-2 py-0.5 rounded-full">{selectedCharacters.length} characters</span>
                            </h4>
                            {selectedCharacters.length > 0 ? (<div className="border rounded-md divide-y">
                                {selectedCharacters.map(character => (
                                    <div key={character.name} className="p-3 flex justify-between items-center">
                                        <div>
                                            <p className="font-medium">{character.name}</p>
                                            {character.actorName && (<p className="text-sm font-medium text-primary">Actor: {character.actorName}</p>)}
                                            {character.estimatedAgeRange && (<p className="text-sm text-gray-500">Estimated age: {character.estimatedAgeRange}</p>)}
                                        </div>
                                        <Button variant="ghost" size="sm" onClick={() => handleCharacterSelection(character)} className="text-red-500 hover:text-red-700 hover:bg-red-50">Remove</Button>
                                    </div>
                                ))}
                            </div>) : (<p className="text-sm text-gray-500 italic">No characters selected yet.</p>)}
                        </div>
                        <div>
                            <h4 className="text-base font-semibold mb-2 flex items-center">
                                <span className="mr-2">Selected Filming Locations</span>
                                <span className="bg-green-100 text-green-800 text-xs font-medium px-2 py-0.5 rounded-full">{selectedLocations.length} locations</span>
                            </h4>
                            {selectedLocations.length > 0 ? (<div className="border rounded-md divide-y">
                                {selectedLocations.map(location => (
                                    <div key={location.id} className="p-3 flex justify-between items-center">
                                        <div>
                                            <p className="font-medium">{location.region}, {location.country}</p>
                                            {location.incentiveProgram && (<p className="text-sm text-gray-500">{location.incentiveProgram}</p>)}
                                            {location.estimatedIncentiveValue && (<p className="text-sm text-green-600">Est. benefit: {location.estimatedIncentiveValue}</p>)}
                                        </div>
                                        <Button variant="ghost" size="sm" onClick={() => handleLocationSelection(location)} className="text-red-500 hover:text-red-700 hover:bg-red-50">Remove</Button>
                                    </div>
                                ))}
                            </div>) : (<p className="text-sm text-gray-500 italic">No locations selected yet.</p>)}
                        </div>
                        <div>
                            <h4 className="text-base font-semibold mb-2 flex items-center">
                                <span className="mr-2">Selected Brand Products</span>
                                <span className="bg-green-100 text-green-800 text-xs font-medium px-2 py-0.5 rounded-full">{selectedProducts.length} placements</span>
                            </h4>
                            {selectedProducts.length > 0 ? (<div className="border rounded-md divide-y">
                                {selectedProducts.map(product => (
                                    <div key={product.id} className="p-3 flex justify-between items-start">
                                        <div className="flex gap-3">
                                            {product.imageUrl && (<div className="w-24 h-24 bg-gray-100 rounded overflow-hidden flex-shrink-0 cursor-pointer" onClick={() => handleImageZoom(product.imageUrl || '', product.productName || 'Product image')}>
                                                <img src={product.imageUrl} alt={product.productName || 'Product placement'} className="w-full h-full object-cover"/>
                                            </div>)}
                                            <div>
                                                <p className="font-medium">{product.productName || 'Unnamed product'}</p>
                                                {product.productCategory && (<p className="text-sm font-medium text-primary">Product Type: {product.productCategory}</p>)}
                                                <p className="text-sm text-gray-500">Scene: {scenes.find(s => s.id === product.sceneId)?.sceneNumber || product.sceneId}</p>
                                                {videoGenerationStates[product.id]?.videoUrl && (<Button variant="outline" size="sm" className="mt-2 text-xs" onClick={() => handleViewVideo(videoGenerationStates[product.id].videoUrl || '', `${product.productName} - Scene ${scenes.find(s => s.id === product.sceneId)?.sceneNumber || product.sceneId}`)}><PlayCircle className="h-3 w-3 mr-1" />View Video</Button>)}
                                            </div>
                                        </div>
                                        <Button variant="ghost" size="sm" onClick={() => handleProductSelection(product)} className="text-red-500 hover:text-red-700 hover:bg-red-50">Remove</Button>
                                    </div>
                                ))}
                            </div>) : (<p className="text-sm text-gray-500 italic">No brand products selected yet.</p>)}
                        </div>
                    </div>
                    <DialogFooter>
                        <Button variant="outline" onClick={() => setIsSelectionInfoModalOpen(false)}>Close</Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>

            <VideoPlayerModal isOpen={isVideoModalOpen} onClose={handleCloseVideoModal} videoUrl={currentVideoUrl} title={currentVideoTitle} />
            <ImageZoomModal isOpen={isImageZoomModalOpen} onClose={handleCloseImageZoomModal} imageUrl={zoomedImageUrl} title={zoomedImageTitle} />

            {/* Financial Analysis Modal has been moved up for rendering */}
        </>
    );
}


================================================
FILE: client/src/pages/ScriptWriter.tsx
================================================
// // client/src/pages/ScriptWriter.tsx
// import { useState, useEffect } from "react";
// import { useForm } from "react-hook-form";
// import { zodResolver } from "@hookform/resolvers/zod";
// import { Button } from "@/components/ui/button";
// import { Input } from "@/components/ui/input";
// import { Textarea } from "@/components/ui/textarea";
// import {
//   Select,
//   SelectContent,
//   SelectItem,
//   SelectTrigger,
//   SelectValue,
// } from "@/components/ui/select";
// import {
//   Form,
//   FormControl,
//   FormField,
//   FormItem,
//   FormLabel,
//   FormMessage,
// } from "@/components/ui/form";
// import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
// import { Progress } from "@/components/ui/progress";
// import { Loader2, FileText, Download, AlertCircle } from "lucide-react";
// import { useMutation } from "@tanstack/react-query";
// import { useToast } from "@/hooks/use-toast";
// import { apiRequest } from "@/lib/queryClient";
// import { ScriptGenerationFormData } from "@/lib/types";
// import { scriptGenerationFormSchema, FilmRatingEnum, FilmRatingType } from "@shared/schema";
// import { ScrollArea } from "@/components/ui/scroll-area";
// // No need to import useLocation from wouter if we use window.location directly for this one-time read

// export default function ScriptWriter() {
//   const { toast } = useToast();
//   const [generatedScript, setGeneratedScript] = useState<string | null>(null);
//   const [isGenerating, setIsGenerating] = useState(false);
//   const [generationProgress, setGenerationProgress] = useState(0);
//   const [generationError, setGenerationError] = useState<string | null>(null);

//   const form = useForm<ScriptGenerationFormData>({
//     resolver: zodResolver(scriptGenerationFormSchema),
//     defaultValues: {
//       projectTitle: "", // Initialize empty; will be set by useEffect
//       logline: "",
//       description: "",
//       genre: "",
//       concept: "",
//       targetedRating: "PG_13" as FilmRatingType,
//       storyLocation: "",
//       specialRequest: "",
//     },
//   });

//   // This useEffect hook runs once when the component mounts.
//   // It's the most reliable place to read initial URL parameters.
//   useEffect(() => {
//     // Directly use window.location.search to get the query string
//     const searchParams = new URLSearchParams(window.location.search);
//     const projectNameFromURL = searchParams.get("projectName");

//     // console.log("[ScriptWriter] Mounted. projectName from URL:", projectNameFromURL); // For debugging

//     if (projectNameFromURL) {
//       // Decode the project name as it was URI encoded
//       const decodedProjectName = decodeURIComponent(projectNameFromURL);
//       // Use setValue to update the form field after initialization
//       form.setValue("projectTitle", decodedProjectName, {
//         shouldValidate: true, // Optional: validate after setting
//         shouldDirty: true,    // Optional: mark the field as dirty as if user typed it
//       });
//       // console.log(`[ScriptWriter] Set projectTitle to: ${decodedProjectName}`); // For debugging
//     }
//     // The empty dependency array [] ensures this effect runs only once on mount.
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, []); // IMPORTANT: Empty dependency array

//   const generateScriptMutation = useMutation({
//     mutationFn: async (data: ScriptGenerationFormData) => {
//       setIsGenerating(true);
//       setGenerationProgress(10);
//       setGeneratedScript(null);
//       setGenerationError(null);

//       const progressInterval = setInterval(() => {
//         setGenerationProgress((prev) => {
//           if (prev >= 90) {
//             clearInterval(progressInterval);
//             return 90;
//           }
//           return prev + Math.floor(Math.random() * 5) + 5;
//         });
//       }, 2000);

//       try {
//         const controller = new AbortController();
//         const timeoutId = setTimeout(() => controller.abort(), 120000);

//         const response = await apiRequest(
//           "POST", 
//           "/api/scripts/generate-from-prompt", 
//           data,
//           { signal: controller.signal }
//         );

//         clearTimeout(timeoutId);

//         if (!response.ok) {
//           const errorData = await response.json().catch(() => ({ 
//             message: "Failed to generate script. Server error." 
//           }));
//           let errorMessage = errorData.message || `Error ${response.status}`;
//           if (response.status === 500) errorMessage = "Our script generator is currently experiencing issues. Please try again later.";
//           else if (response.status === 400) errorMessage = "Please check your script details and try again.";
//           else if (response.status === 429) errorMessage = "You've made too many requests. Please wait a moment and try again.";
//           throw new Error(errorMessage);
//         }

//         const result = await response.json();
//         clearInterval(progressInterval);
//         setGenerationProgress(100);
//         return result.script;
//       } catch (error: any) {
//         clearInterval(progressInterval);
//         setGenerationProgress(0);
//         if (error.name === 'AbortError') throw new Error("Script generation timed out. Please try again with a simpler concept.");
//         if (error.message?.includes("fetch failed")) throw new Error("Network error. Please check your connection and try again.");
//         throw error;
//       }
//     },
//     onSuccess: (scriptText: string) => {
//       setGeneratedScript(scriptText);
//       toast({
//         title: "Script Generated",
//         description: "Your script has been successfully generated.",
//       });
//       setIsGenerating(false);
//     },
//     onError: (error: Error) => {
//       const errorMsg = error.message || "Failed to generate script. Please try again.";
//       setGenerationError(errorMsg);
//       if (!errorMsg.includes("Network error")) {
//         toast({
//           variant: "destructive",
//           title: "Generation Failed",
//           description: errorMsg,
//         });
//       }
//       setIsGenerating(false);
//       setGenerationProgress(0);
//     },
//   });

//   const exportPdfMutation = useMutation({
//     mutationFn: async (scriptText: string) => {
//       const response = await fetch("/api/scripts/export-pdf", {
//         method: "POST",
//         headers: { "Content-Type": "application/json" },
//         body: JSON.stringify({ scriptContent: scriptText, title: form.getValues("projectTitle") || "GeneratedScript" }),
//       });

//       if (!response.ok) {
//         const errorData = await response.json().catch(() => ({ message: "Failed to initiate PDF download." }));
//         throw new Error(errorData.message || "PDF generation failed.");
//       }
//       return response.blob();
//     },
//     onSuccess: (blob) => {
//       const url = window.URL.createObjectURL(blob);
//       const a = document.createElement("a");
//       a.href = url;
//       a.download = `${(form.getValues("projectTitle") || "GeneratedScript").replace(/[^a-z0-9]/gi, '_')}.pdf`;
//       document.body.appendChild(a);
//       a.click();
//       window.URL.revokeObjectURL(url);
//       a.remove();
//       toast({
//         title: "PDF Exported",
//         description: "Your script has been downloaded as a PDF.",
//       });
//     },
//     onError: (error: Error) => {
//       toast({
//         variant: "destructive",
//         title: "PDF Export Failed",
//         description: error.message,
//       });
//     },
//   });

//   const onSubmit = (data: ScriptGenerationFormData) => {
//     generateScriptMutation.mutate(data);
//   };

//   const handleExportPdf = () => {
//     if (generatedScript) {
//       exportPdfMutation.mutate(generatedScript);
//     } else {
//       toast({
//         variant: "destructive",
//         title: "No Script to Export",
//         description: "Please generate a script first.",
//       });
//     }
//   };

//   return (
//     <div className="container mx-auto py-4 sm:py-8 px-3 sm:px-4">
//       <h1 className="text-2xl sm:text-3xl font-bold mb-6 sm:mb-8 text-center">Vadis Script Writer</h1>
//       <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 sm:gap-8">
//         <Card className="shadow-lg">
//           <CardHeader className="pb-4 sm:pb-6">
//             <CardTitle className="text-xl sm:text-2xl">Script Details</CardTitle>
//             <CardDescription>Provide the details for your new script.</CardDescription>
//           </CardHeader>
//           <CardContent>
//             <Form {...form}>
//               <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4 sm:space-y-6">
//                 <FormField control={form.control} name="projectTitle" render={({ field }) => (
//                   <FormItem>
//                     <FormLabel>Project Title</FormLabel>
//                     <FormControl><Input placeholder="e.g., The Last Starfighter" {...field} /></FormControl>
//                     <FormMessage />
//                   </FormItem>
//                 )} />
//                 <FormField control={form.control} name="logline" render={({ field }) => (
//                   <FormItem>
//                     <FormLabel>Logline (1-2 sentences)</FormLabel>
//                     <FormControl><Input placeholder="A brief summary of your story" {...field} /></FormControl>
//                     <FormMessage />
//                   </FormItem>
//                 )} />
//                  <FormField control={form.control} name="description" render={({ field }) => (
//                   <FormItem>
//                     <FormLabel>Description / Synopsis</FormLabel>
//                     <FormControl><Textarea placeholder="Overview of the plot and themes" {...field} rows={3} /></FormControl>
//                     <FormMessage />
//                   </FormItem>
//                 )} />
//                 <FormField control={form.control} name="genre" render={({ field }) => (
//                   <FormItem>
//                     <FormLabel>Genre</FormLabel>
//                     <FormControl><Input placeholder="e.g., Sci-Fi, Drama, Comedy" {...field} /></FormControl>
//                     <FormMessage />
//                   </FormItem>
//                 )} />
//                  <FormField control={form.control} name="concept" render={({ field }) => (
//                   <FormItem>
//                     <FormLabel>Core Concept / Idea</FormLabel>
//                     <FormControl><Textarea placeholder="Central idea of your story" {...field} rows={3} /></FormControl>
//                     <FormMessage />
//                   </FormItem>
//                 )} />
//                 <FormField control={form.control} name="targetedRating" render={({ field }) => (
//                   <FormItem>
//                     <FormLabel>Targeted Rating</FormLabel>
//                     <Select onValueChange={field.onChange} defaultValue={field.value}>
//                       <FormControl><SelectTrigger><SelectValue placeholder="Select a rating" /></SelectTrigger></FormControl>
//                       <SelectContent>
//                         {Object.entries(FilmRatingEnum).map(([key, value]) => (
//                           <SelectItem key={key} value={key as FilmRatingType}>
//                             {value}
//                           </SelectItem>
//                         ))}
//                       </SelectContent>
//                     </Select>
//                     <FormMessage />
//                   </FormItem>
//                 )} />
//                 <FormField control={form.control} name="storyLocation" render={({ field }) => (
//                   <FormItem>
//                     <FormLabel>Primary Story Location</FormLabel>
//                     <FormControl><Input placeholder="e.g., Mars Colony, Paris, Forest" {...field} /></FormControl>
//                     <FormMessage />
//                   </FormItem>
//                 )} />
//                 <FormField control={form.control} name="specialRequest" render={({ field }) => (
//                   <FormItem>
//                     <FormLabel>Special Requests (Optional)</FormLabel>
//                     <FormControl><Textarea placeholder="Any specific elements to include?" {...field} rows={2} /></FormControl>
//                     <FormMessage />
//                   </FormItem>
//                 )} />
//                 <Button type="submit" className="w-full" disabled={isGenerating}>
//                   {isGenerating ? <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Generating...</> : "Generate Script"}
//                 </Button>
//               </form>
//             </Form>
//           </CardContent>
//         </Card>

//         <Card className="shadow-lg">
//           <CardHeader className="pb-4 sm:pb-6">
//             <CardTitle className="text-xl sm:text-2xl">Generated Script Preview</CardTitle>
//             <CardDescription>Your script will appear here.</CardDescription>
//           </CardHeader>
//           <CardContent className="h-[400px] sm:h-[500px] md:h-[600px] flex flex-col">
//             {isGenerating && (
//               <div className="flex flex-col items-center justify-center h-full p-4">
//                 <Loader2 className="h-10 w-10 sm:h-12 sm:w-12 text-primary animate-spin mb-4" />
//                 <p className="text-base sm:text-lg font-medium mb-2 text-center">Generating Script...</p>
//                 <p className="text-xs sm:text-sm text-muted-foreground mb-4 text-center">This may take a few minutes. Please wait.</p>
//                 <Progress value={generationProgress} className="w-full max-w-xs sm:max-w-md" />
//                 <p className="text-xs text-muted-foreground mt-2">{generationProgress}%</p>
//               </div>
//             )}
//             {generationError && !isGenerating && (
//                 <div className="flex flex-col items-center justify-center h-full text-destructive p-4">
//                     <AlertCircle className="h-10 w-10 sm:h-12 sm:w-12 mb-4" />
//                     <p className="text-base sm:text-lg font-medium mb-2 text-center">Generation Failed</p>
//                     <p className="text-xs sm:text-sm text-center px-2">
//                         {generationError === "An error occurred during AI script generation." 
//                             ? "We couldn't generate your script. This could be due to server load or content restrictions. Please try again with different details."
//                             : generationError}
//                     </p>
//                     <Button 
//                         variant="outline" 
//                         size="sm" 
//                         className="mt-4" 
//                         onClick={() => setGenerationError(null)}
//                     >
//                         Dismiss
//                     </Button>
//                 </div>
//             )}
//             {!isGenerating && generatedScript && (
//               <ScrollArea className="flex-grow border rounded-md p-2 sm:p-4 bg-gray-50 whitespace-pre-wrap font-mono text-xs sm:text-sm">
//                 {generatedScript}
//               </ScrollArea>
//             )}
//             {!isGenerating && !generatedScript && !generationError && (
//               <div className="flex flex-col items-center justify-center h-full text-muted-foreground p-4">
//                 <FileText className="h-12 w-12 sm:h-16 sm:w-16 mb-4" />
//                 <p className="text-center text-sm sm:text-base">Fill out the form and click "Generate Script" to create your screenplay.</p>
//               </div>
//             )}
//           </CardContent>
//           {generatedScript && !isGenerating && (
//             <CardFooter>
//               <Button 
//                 onClick={handleExportPdf} 
//                 className="w-full"
//                 disabled={exportPdfMutation.isPending}
//               >
//                 {exportPdfMutation.isPending ? (
//                   <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Exporting...</>
//                 ) : (
//                   <><Download className="mr-2 h-4 w-4" /> Download PDF</>
//                 )}
//               </Button>
//             </CardFooter>
//           )}
//         </Card>
//       </div>
//     </div>
//   );
// }

// client/src/pages/ScriptWriter.tsx
import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Loader2, FileText, Download, AlertCircle } from "lucide-react";
import { useMutation } from "@tanstack/react-query";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from "@/lib/queryClient";
import { ScriptGenerationFormData } from "@/lib/types";
import { scriptGenerationFormSchema, FilmRatingEnum, FilmRatingType } from "@shared/schema";
import { ScrollArea } from "@/components/ui/scroll-area";

// Increase client-side timeout to 10 minutes (1,000,000 ms) to allow server ample time for 10 agents
const SCRIPT_GENERATION_CLIENT_TIMEOUT_MS = 1000000; 

export default function ScriptWriter() {
  const { toast } = useToast();
  const [generatedScript, setGeneratedScript] = useState<string | null>(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const [generationProgress, setGenerationProgress] = useState(0);
  const [generationError, setGenerationError] = useState<string | null>(null);

  const form = useForm<ScriptGenerationFormData>({
    resolver: zodResolver(scriptGenerationFormSchema),
    defaultValues: {
      projectTitle: "", 
      logline: "",
      description: "",
      genre: "",
      concept: "",
      targetedRating: "PG_13" as FilmRatingType,
      storyLocation: "",
      specialRequest: "",
    },
  });

  useEffect(() => {
    const searchParams = new URLSearchParams(window.location.search);
    const projectNameFromURL = searchParams.get("projectName");
    if (projectNameFromURL) {
      const decodedProjectName = decodeURIComponent(projectNameFromURL);
      form.setValue("projectTitle", decodedProjectName, {
        shouldValidate: true, 
        shouldDirty: true,    
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); 

  const generateScriptMutation = useMutation({
    mutationFn: async (data: ScriptGenerationFormData) => {
      setIsGenerating(true);
      setGenerationProgress(10);
      setGeneratedScript(null);
      setGenerationError(null);

      // Client-side progress simulation (remains unchanged)
      const progressInterval = setInterval(() => {
        setGenerationProgress((prev) => {
          if (prev >= 90) {
            clearInterval(progressInterval);
            return 90;
          }
          return prev + Math.floor(Math.random() * 5) + 5;
        });
      }, 2000); // This interval is for UI progress, not related to API timeout

      try {
        const controller = new AbortController();
        // Use the increased client-side timeout
        const timeoutId = setTimeout(() => {
          console.warn(`[Client] Script generation request timed out after ${SCRIPT_GENERATION_CLIENT_TIMEOUT_MS / 1000}s.`);
          controller.abort();
        }, SCRIPT_GENERATION_CLIENT_TIMEOUT_MS); 

        const response = await apiRequest(
          "POST", 
          "/api/scripts/generate-from-prompt", 
          data,
          { signal: controller.signal } // Pass the signal for this specific API request
        );

        clearTimeout(timeoutId); // Clear the client-side timeout if request completes

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ 
            message: "Failed to generate script. Server error or unexpected response." 
          }));
          let errorMessage = errorData.message || `Error ${response.status}`;
          if (response.status === 500) errorMessage = "Our script generator is currently experiencing issues. Please try again later.";
          else if (response.status === 400) errorMessage = "Please check your script details and try again.";
          else if (response.status === 429) errorMessage = "You've made too many requests. Please wait a moment and try again.";
          throw new Error(errorMessage);
        }

        const result = await response.json();
        clearInterval(progressInterval); // Clear client-side progress simulation interval
        setGenerationProgress(100);
        return result.script;
      } catch (error: any) {
        clearInterval(progressInterval); // Also clear on error
        setGenerationProgress(0);
        if (error.name === 'AbortError') { // This error is thrown by fetch when controller.abort() is called
          throw new Error(`Script generation timed out on client after ${SCRIPT_GENERATION_CLIENT_TIMEOUT_MS / 1000 / 60} minutes. The server might still be processing or encountered an issue. Try a simpler concept or check server logs.`);
        }
        if (error.message?.includes("fetch failed")) { // Network error
          throw new Error("Network error. Please check your connection and try again.");
        }
        throw error; // Re-throw other errors (e.g., server errors parsed above)
      }
    },
    onSuccess: (scriptText: string) => {
      setGeneratedScript(scriptText);
      toast({
        title: "Script Generated",
        description: "Your script has been successfully generated.",
      });
      setIsGenerating(false);
    },
    onError: (error: Error) => {
      const errorMsg = error.message || "Failed to generate script. Please try again.";
      setGenerationError(errorMsg);
      // Only show toast for actual generation errors, not client-side timeouts if already handled by error message
      if (!errorMsg.toLowerCase().includes("timed out on client")) {
        toast({
          variant: "destructive",
          title: "Generation Failed",
          description: errorMsg,
        });
      }
      setIsGenerating(false);
      setGenerationProgress(0);
    },
  });

  const exportPdfMutation = useMutation({
    mutationFn: async (scriptText: string) => {
      const response = await fetch("/api/scripts/export-pdf", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ scriptContent: scriptText, title: form.getValues("projectTitle") || "GeneratedScript" }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ message: "Failed to initiate PDF download." }));
        throw new Error(errorData.message || "PDF generation failed.");
      }
      return response.blob();
    },
    onSuccess: (blob) => {
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${(form.getValues("projectTitle") || "GeneratedScript").replace(/[^a-z0-9]/gi, '_')}.pdf`;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      a.remove();
      toast({
        title: "PDF Exported",
        description: "Your script has been downloaded as a PDF.",
      });
    },
    onError: (error: Error) => {
      toast({
        variant: "destructive",
        title: "PDF Export Failed",
        description: error.message,
      });
    },
  });

  const onSubmit = (data: ScriptGenerationFormData) => {
    generateScriptMutation.mutate(data);
  };

  const handleExportPdf = () => {
    if (generatedScript) {
      exportPdfMutation.mutate(generatedScript);
    } else {
      toast({
        variant: "destructive",
        title: "No Script to Export",
        description: "Please generate a script first.",
      });
    }
  };

  return (
    <div className="container mx-auto py-4 sm:py-8 px-3 sm:px-4">
      <h1 className="text-2xl sm:text-3xl font-bold mb-6 sm:mb-8 text-center">Vadis Script Writer</h1>
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 sm:gap-8">
        <Card className="shadow-lg">
          <CardHeader className="pb-4 sm:pb-6">
            <CardTitle className="text-xl sm:text-2xl">Script Details</CardTitle>
            <CardDescription>Provide the details for your new script.</CardDescription>
          </CardHeader>
          <CardContent>
            <Form {...form}>
              <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4 sm:space-y-6">
                <FormField control={form.control} name="projectTitle" render={({ field }) => (
                  <FormItem>
                    <FormLabel>Project Title</FormLabel>
                    <FormControl><Input placeholder="e.g., The Last Starfighter" {...field} /></FormControl>
                    <FormMessage />
                  </FormItem>
                )} />
                <FormField control={form.control} name="logline" render={({ field }) => (
                  <FormItem>
                    <FormLabel>Logline (1-2 sentences)</FormLabel>
                    <FormControl><Input placeholder="A brief summary of your story" {...field} /></FormControl>
                    <FormMessage />
                  </FormItem>
                )} />
                 <FormField control={form.control} name="description" render={({ field }) => (
                  <FormItem>
                    <FormLabel>Description / Synopsis</FormLabel>
                    <FormControl><Textarea placeholder="Overview of the plot and themes" {...field} rows={3} /></FormControl>
                    <FormMessage />
                  </FormItem>
                )} />
                <FormField control={form.control} name="genre" render={({ field }) => (
                  <FormItem>
                    <FormLabel>Genre</FormLabel>
                    <FormControl><Input placeholder="e.g., Sci-Fi, Drama, Comedy" {...field} /></FormControl>
                    <FormMessage />
                  </FormItem>
                )} />
                 <FormField control={form.control} name="concept" render={({ field }) => (
                  <FormItem>
                    <FormLabel>Core Concept / Idea</FormLabel>
                    <FormControl><Textarea placeholder="Central idea of your story" {...field} rows={3} /></FormControl>
                    <FormMessage />
                  </FormItem>
                )} />
                <FormField control={form.control} name="targetedRating" render={({ field }) => (
                  <FormItem>
                    <FormLabel>Targeted Rating</FormLabel>
                    <Select onValueChange={field.onChange} defaultValue={field.value}>
                      <FormControl><SelectTrigger><SelectValue placeholder="Select a rating" /></SelectTrigger></FormControl>
                      <SelectContent>
                        {Object.entries(FilmRatingEnum).map(([key, value]) => (
                          <SelectItem key={key} value={key as FilmRatingType}>
                            {value}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )} />
                <FormField control={form.control} name="storyLocation" render={({ field }) => (
                  <FormItem>
                    <FormLabel>Primary Story Location</FormLabel>
                    <FormControl><Input placeholder="e.g., Mars Colony, Paris, Forest" {...field} /></FormControl>
                    <FormMessage />
                  </FormItem>
                )} />
                <FormField control={form.control} name="specialRequest" render={({ field }) => (
                  <FormItem>
                    <FormLabel>Special Requests (Optional)</FormLabel>
                    <FormControl><Textarea placeholder="Any specific elements to include?" {...field} rows={2} /></FormControl>
                    <FormMessage />
                  </FormItem>
                )} />
                <Button type="submit" className="w-full" disabled={isGenerating}>
                  {isGenerating ? <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Generating...</> : "Generate Script"}
                </Button>
              </form>
            </Form>
          </CardContent>
        </Card>

        <Card className="shadow-lg">
          <CardHeader className="pb-4 sm:pb-6">
            <CardTitle className="text-xl sm:text-2xl">Generated Script Preview</CardTitle>
            <CardDescription>Your script will appear here.</CardDescription>
          </CardHeader>
          <CardContent className="h-[400px] sm:h-[500px] md:h-[600px] flex flex-col">
            {isGenerating && (
              <div className="flex flex-col items-center justify-center h-full p-4">
                <Loader2 className="h-10 w-10 sm:h-12 sm:w-12 text-primary animate-spin mb-4" />
                <p className="text-base sm:text-lg font-medium mb-2 text-center">Generating Script...</p>
                <p className="text-xs sm:text-sm text-muted-foreground mb-4 text-center">This may take a few minutes. Please wait.</p>
                <Progress value={generationProgress} className="w-full max-w-xs sm:max-w-md" />
                <p className="text-xs text-muted-foreground mt-2">{generationProgress}%</p>
              </div>
            )}
            {generationError && !isGenerating && (
                <div className="flex flex-col items-center justify-center h-full text-destructive p-4">
                    <AlertCircle className="h-10 w-10 sm:h-12 sm:w-12 mb-4" />
                    <p className="text-base sm:text-lg font-medium mb-2 text-center">Generation Failed</p>
                    <p className="text-xs sm:text-sm text-center px-2">
                        {generationError}
                    </p>
                    <Button 
                        variant="outline" 
                        size="sm" 
                        className="mt-4" 
                        onClick={() => setGenerationError(null)}
                    >
                        Dismiss
                    </Button>
                </div>
            )}
            {!isGenerating && generatedScript && (
              <ScrollArea className="flex-grow border rounded-md p-2 sm:p-4 bg-gray-50 whitespace-pre-wrap font-mono text-xs sm:text-sm">
                {generatedScript}
              </ScrollArea>
            )}
            {!isGenerating && !generatedScript && !generationError && (
              <div className="flex flex-col items-center justify-center h-full text-muted-foreground p-4">
                <FileText className="h-12 w-12 sm:h-16 sm:w-16 mb-4" />
                <p className="text-center text-sm sm:text-base">Fill out the form and click "Generate Script" to create your screenplay.</p>
              </div>
            )}
          </CardContent>
          {generatedScript && !isGenerating && (
            <CardFooter>
              <Button 
                onClick={handleExportPdf} 
                className="w-full"
                disabled={exportPdfMutation.isPending}
              >
                {exportPdfMutation.isPending ? (
                  <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Exporting...</>
                ) : (
                  <><Download className="mr-2 h-4 w-4" /> Download PDF</>
                )}
              </Button>
            </CardFooter>
          )}
        </Card>
      </div>
    </div>
  );
}


================================================
FILE: client/src/pages/TermsOfService.tsx
================================================
import { Link } from "wouter";

export default function TermsOfService() {
  return (
    <div className="max-w-4xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Terms of Service</h1>
      
      <div className="prose prose-slate dark:prose-invert">
        <p className="text-lg mb-4">Last Updated: May 7, 2025</p>
        
        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">Agreement to Terms</h2>
          <p>
            By accessing or using the VadisMedia platform, you agree to be bound by these Terms and 
            Conditions. If you disagree with any part of the terms, you may not access the service.
          </p>
        </section>
        
        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">Subscription and Payments</h2>
          <p>
            Some aspects of our service may require a paid subscription. By choosing a paid subscription, 
            you agree to pay the subscription fees indicated. Fees are non-refundable except as required by law 
            or as explicitly stated in our refund policy.
          </p>
        </section>
        
        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">Intellectual Property</h2>
          <p>
            The VadisMedia platform and its original content, features, and functionality are owned by 
            VadisMedia and are protected by international copyright, trademark, patent, trade secret, 
            and other intellectual property laws.
          </p>
          <p className="mt-2">
            You retain all rights to the content you upload to our platform. However, by uploading content, 
            you grant us a non-exclusive, worldwide, royalty-free license to use, reproduce, and process that 
            content solely for the purpose of providing our services to you.
          </p>
        </section>
        
        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">User Content</h2>
          <p>
            You are solely responsible for the content you upload to our platform. You agree not to upload 
            content that is illegal, infringing, harmful, threatening, abusive, harassing, defamatory, vulgar, 
            obscene, or otherwise objectionable.
          </p>
        </section>
        
        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">Limitation of Liability</h2>
          <p>
            To the maximum extent permitted by law, VadisMedia, its directors, employees, partners, agents, 
            suppliers, or affiliates shall not be liable for any indirect, incidental, special, consequential, 
            or punitive damages, including without limitation, loss of profits, data, use, goodwill, or other 
            intangible losses.
          </p>
        </section>
        
        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">Indemnification</h2>
          <p>
            You agree to indemnify and hold harmless VadisMedia, its officers, directors, employees, agents, 
            suppliers, and affiliates from and against any claims, liabilities, damages, losses, and expenses, 
            including without limitation reasonable attorney's fees, arising out of or in any way connected with 
            your access to or use of the service.
          </p>
        </section>
        
        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">Governing Law</h2>
          <p>
            These Terms shall be governed by and construed in accordance with the laws of the jurisdiction in 
            which VadisMedia is established, without regard to its conflict of law provisions.
          </p>
        </section>
        
        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">Changes to Terms</h2>
          <p>
            We reserve the right to modify these Terms at any time. We will provide notice of any significant 
            changes by posting the new Terms on this page and updating the "Last Updated" date.
          </p>
        </section>
        
        <section className="mb-6">
          <h2 className="text-2xl font-semibold mb-3">Contact Us</h2>
          <p>
            If you have any questions about these Terms, please <Link href="/contact" className="text-primary hover:underline">contact us</Link>.
          </p>
        </section>
      </div>
    </div>
  );
}


================================================
FILE: client/src/pages/Welcome.tsx
================================================
// // client/src/pages/Welcome.tsx
// import { TabType } from "@/lib/types";
// import { 
//   Pencil, 
//   Search, // For "Begin Analysis"
//   Upload as UploadBoxIcon, // For the "Get Started" box title
//   Loader2, 
//   ShieldCheck, 
//   PlaySquare 
// } from "lucide-react";
// import { Input } from "@/components/ui/input";
// import FileUpload from "@/components/script/FileUpload";
// import { Progress } from "@/components/ui/progress";
// import { Button } from "@/components/ui/button";
// import { useState, useEffect } from "react";
// import { useMutation, useQueryClient } from "@tanstack/react-query";
// import { useToast } from "@/hooks/use-toast";
// import { useLocation } from "wouter"; // For navigation
// import { formatFileSize } from "@/lib/utils";
// import { Tooltip, TooltipProvider, TooltipTrigger, TooltipContent } from "@/components/ui/tooltip";

// interface WelcomeProps {
//   onTabChange?: (tab: TabType) => void;
// }

// export default function Welcome({ onTabChange }: WelcomeProps) {
//   const { toast } = useToast();
//   const queryClient = useQueryClient();
//   const [_wLocation, setLocation] = useLocation(); // Wouter's navigation

//   const [processingProgress, setProcessingProgress] = useState(0);
//   const [processingStatus, setProcessingStatus] = useState("");
//   const [projectNameInput, setProjectNameInput] = useState("");
//   const [selectedFile, setSelectedFile] = useState<File | null>(null);

//   useEffect(() => {
//     // Clear caches on Welcome page mount (existing logic)
//     queryClient.removeQueries({ queryKey: ["/api/scripts/current"] });
//     queryClient.removeQueries({ queryKey: ["/api/scripts/scenes"] });
//     queryClient.removeQueries({ queryKey: ["/api/scripts/brandable-scenes"] });
//     queryClient.removeQueries({ queryKey: ["/api/scripts/scene-variations"] });
//     queryClient.removeQueries({ queryKey: ["/api/scripts/characters"] });
//     queryClient.removeQueries({ queryKey: ["/api/scripts/extracted-characters"] });
//     queryClient.removeQueries({ queryKey: ["/api/scripts/suggest-locations"] });
//     queryClient.removeQueries({ queryKey: ["/api/scenes/suggest-locations"] });
//     queryClient.removeQueries({ queryKey: ["/api/characters/suggest-actors"] });
//     console.log("[Welcome] Relevant React Query caches cleared on mount.");
//   }, [queryClient]);

//   const uploadScriptMutation = useMutation({
//     onMutate: async () => {
//       setProcessingProgress(5);
//       setProcessingStatus("Preparing for new script upload...");
//       await queryClient.removeQueries(); // Clear all caches for a new session
//       console.log("[Welcome] All client-side React Query caches reset for new script session.");
//     },
//     mutationFn: async (fileToUpload: File) => { // Renamed 'file' to 'fileToUpload' for clarity
//       setProcessingProgress(10);
//       setProcessingStatus("Uploading script file...");
//       const formData = new FormData();
//       formData.append("script", fileToUpload);
//       if (projectNameInput.trim() !== "") {
//         formData.append("projectName", projectNameInput.trim());
//       }
//       const response = await fetch("/api/scripts/upload", {
//         method: "POST",
//         body: formData,
//         credentials: "include",
//       });
//       if (!response.ok) {
//         const errorText = await response.text();
//         throw new Error(errorText || "Failed to upload script");
//       }
//       return await response.json();
//     },
//     onSuccess: async (data) => {
//       toast({
//         title: "Script Uploaded & Processed",
//         description: "Server processing initiated and completed.",
//       });
//       setProcessingProgress(75); 
//       setProcessingStatus("Server has processed the script...");

//       console.log("[Welcome] Upload successful. ScriptEditor will fetch fresh data.");

//       setProcessingProgress(100);
//       setProcessingStatus("Redirecting to Script Analysis...");

//       if (onTabChange) {
//         setTimeout(() => {
//           onTabChange("script"); // Navigate to script editor tab
//           setProcessingProgress(0);
//           setProcessingStatus("");
//           setSelectedFile(null); // Clear selected file after successful upload and redirect
//           // setProjectNameInput(""); // Optionally clear project name
//         }, 500);
//       }
//     },
//     onError: (error: Error) => {
//       toast({
//         variant: "destructive",
//         title: "Upload failed",
//         description: error.message,
//       });
//       setProcessingProgress(0);
//       setProcessingStatus("Upload failed. Please try again.");
//       // Keep selectedFile so user doesn't have to re-select if it was a transient error.
//       // If the error is due to the file itself, FileUpload should handle it.
//     },
//   });

//   const isProcessingScript =
//     uploadScriptMutation.isPending ||
//     (uploadScriptMutation.isSuccess &&
//       processingProgress < 100 &&
//       processingStatus.includes("Redirecting"));

//   // This function is now called by the "Begin Analysis" button
//   const handleInitiateUploadForAnalysis = async (file: File) => {
//     await uploadScriptMutation.mutateAsync(file);
//   };

//   const handleFileSelection = (file: File | null) => {
//     setSelectedFile(file);
//     if (file) {
//       toast({
//         title: "File Selected",
//         description: `${file.name} is ready. Click "Begin Analysis" when ready.`,
//       });
//     } else if (selectedFile) {
//       toast({
//         variant: "destructive",
//         title: "File Cleared",
//         description: "Previous file selection was removed or invalid.",
//       });
//     }
//   };

//   const handleStartWriting = () => {
//     if (!projectNameInput.trim() || isProcessingScript || !!selectedFile) return;
//     const projectName = projectNameInput.trim();
//     setLocation(`/script-writer?projectName=${encodeURIComponent(projectName)}`);
//     if (onTabChange) {
//       onTabChange("script-writer");
//     }
//   };

//   const handleBeginAnalysisClick = () => {
//     if (selectedFile && projectNameInput.trim() && !isProcessingScript) {
//       handleInitiateUploadForAnalysis(selectedFile);
//     }
//   };

//   const canStartWriting = projectNameInput.trim() && !selectedFile && !isProcessingScript;
//   const canBeginAnalysis = projectNameInput.trim() && !!selectedFile && !isProcessingScript;

//   return (
//     <div className="flex-grow flex flex-col items-center justify-center py-10 md:py-14 px-4 bg-vadis-light-gray-bg">
//       <div className="text-center mb-10 md:mb-14 max-w-4xl w-full">
//         <div className="flex justify-center mb-8 md:mb-10">
//           <img
//             src="/assets/vadis-media-logo-dark.png"
//             alt="Vadis Media Logo"
//             className="w-full h-auto max-w-[280px] sm:max-w-[320px] md:max-w-[380px]"
//           />
//         </div>
//         <p className="text-lg md:text-xl text-gray-700 mb-10 md:mb-14">
//           AI-powered script analysis for Optimizing Funding and Casting
//         </p>

//         <div className="space-y-10 md:space-y-12">
//           {/* Get Started Box - Content changes based on isProcessingScript */}
//           <div className="bg-card rounded-xl shadow-xl p-6 sm:p-8 md:p-10 max-w-3xl mx-auto">
//             {isProcessingScript ? (
//               <div className="flex flex-col items-center">
//                 <Loader2 className="h-10 w-10 text-primary animate-spin mb-4" />
//                 <h2 className="text-xl font-semibold mb-4 text-vadis-dark-text">
//                   Processing Your Script
//                 </h2>
//                 <p className="text-gray-600 mb-6 text-center">
//                   {processingStatus.includes("Redirecting")
//                     ? processingStatus
//                     : "Please wait while we upload and analyze your screenplay."}
//                 </p>
//                 <div className="w-full max-w-md">
//                   <Progress
//                     value={processingProgress}
//                     className="h-2 mb-2 bg-muted [&>div]:bg-primary"
//                   />
//                   {!processingStatus.includes("Redirecting") && (
//                     <p className="text-sm text-gray-500 text-center">
//                       {processingStatus}
//                     </p>
//                   )}
//                 </div>
//               </div>
//             ) : (
//               <>
//                 <h2 className="text-2xl font-semibold mb-4 flex items-center text-vadis-dark-text">
//                   <UploadBoxIcon className="mr-2 h-6 w-6 text-primary" />
//                   Get Started
//                 </h2>
//                 <p className="text-gray-600 mb-6">
//                   Enter your project name, then either start writing a new script or upload an existing one for analysis.
//                 </p>

//                 <div className="mb-6 max-w-md mx-auto">
//                   <label
//                     htmlFor="projectName"
//                     className="block text-sm font-medium text-gray-700 mb-1 text-left"
//                   >
//                     Project Name <span className="text-red-500">*</span>
//                   </label>
//                   <Input
//                     id="projectName"
//                     type="text"
//                     placeholder="e.g., The Adventures of Captain Code"
//                     value={projectNameInput}
//                     onChange={(e) => setProjectNameInput(e.target.value)}
//                     className="bg-white"
//                     disabled={isProcessingScript}
//                   />
//                   {!projectNameInput.trim() && (
//                     <p className="text-xs text-red-500 mt-1 text-left">Project name is required.</p>
//                   )}
//                 </div>

//                 <div className="mb-8">
//                   <FileUpload
//                     onFileSelected={handleFileSelection}
//                     isLoading={isProcessingScript}
//                   />
//                   {selectedFile && (
//                     <p className="text-sm text-green-600 mt-2">
//                       Selected for analysis: {selectedFile.name} ({formatFileSize(selectedFile.size)})
//                     </p>
//                   )}
//                 </div>

//                 <TooltipProvider delayDuration={100}>
//                   <div className="flex flex-col sm:flex-row justify-center items-center gap-3 sm:gap-4">
//                     <Tooltip>
//                       <TooltipTrigger asChild>
//                         {/* Button is wrapped by span for Tooltip to work when button is disabled */}
//                         <span> 
//                           <Button
//                             onClick={handleStartWriting}
//                             disabled={!canStartWriting}
//                             className="w-full sm:w-auto"
//                           >
//                             <Pencil className="mr-2 h-4 w-4" /> Start Writing
//                           </Button>
//                         </span>
//                       </TooltipTrigger>
//                       <TooltipContent>
//                         {!projectNameInput.trim() ? <p>Enter project name to enable.</p> :
//                          selectedFile ? <p>A file is selected for analysis. Clear it or complete analysis first.</p> :
//                          isProcessingScript ? <p>Cannot start writing while another process is active.</p> :
//                          <p>Create a new script from scratch using the project name.</p>}
//                       </TooltipContent>
//                     </Tooltip>

//                     <Tooltip>
//                       <TooltipTrigger asChild>
//                         <span>
//                           <Button
//                             onClick={handleBeginAnalysisClick}
//                             disabled={!canBeginAnalysis}
//                             className="w-full sm:w-auto"
//                           >
//                             <Search className="mr-2 h-4 w-4" /> Begin Analysis
//                           </Button>
//                         </span>
//                       </TooltipTrigger>
//                       <TooltipContent>
//                         {!projectNameInput.trim() ? <p>Enter project name to enable.</p> :
//                          !selectedFile ? <p>Upload a script file above to enable analysis.</p> :
//                          isProcessingScript ? <p>Processing another task.</p> :
//                          <p>Analyze the selected script: {selectedFile?.name || ""}</p>}
//                       </TooltipContent>
//                     </Tooltip>
//                   </div>
//                 </TooltipProvider>

//                 <div className="text-xs text-muted-foreground mt-6 flex items-center justify-center space-x-1">
//                   <ShieldCheck className="h-4 w-4 text-green-600" />
//                   <span>Your script is processed securely and will not be shared.</span>
//                 </div>
//               </>
//             )}
//           </div>

//           {/* How It Works Section (remains unchanged) */}
//           <div className="bg-card rounded-xl shadow-xl p-6 sm:p-8 md:p-10 max-w-3xl mx-auto">
//             <h2 className="text-2xl font-semibold mb-4 flex items-center text-vadis-dark-text">
//               <PlaySquare className="mr-2 h-6 w-6 text-primary" />
//               How It Works
//             </h2>
//             <ul className="space-y-4 text-gray-700 text-left">
//               {[
//                 "Upload your script PDF file.",
//                 "Vadis AI will extract scenes from the script and analyze brand sponsorship opportunities.",
//                 "Select the brand sponsors you'd like to feature in the scenes from your script.",
//                 "Review AI-generated stills and videos featuring the Brand Sponsors you've selected for each scene.",
//                 "Export for production.",
//               ].map((step, index) => (
//                 <li key={index} className="flex items-start text-gray-600">
//                   <span className="flex-shrink-0 bg-primary text-primary-foreground h-6 w-6 flex items-center justify-center rounded-full text-sm font-semibold mr-4 mt-0.5">
//                     {index + 1}
//                   </span>
//                   <span>{step}</span>
//                 </li>
//               ))}
//             </ul>
//           </div>
//         </div>
//       </div>
//     </div>
//   );
// }

// client/src/pages/Welcome.tsx
import { TabType } from "@/lib/types";
import {
  Pencil,
  Search, // For "Begin Analysis"
  UploadCloud as UploadBoxIcon, // Renamed for clarity
  Loader2,
  ShieldCheck,
  PlaySquare,
} from "lucide-react";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label"; // Added Label
import FileUpload from "@/components/script/FileUpload";
import { Progress } from "@/components/ui/progress";
import { Button } from "@/components/ui/button";
import { useState, useEffect } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useToast } from "@/hooks/use-toast";
import { useLocation } from "wouter"; // For navigation
import { formatFileSize } from "@/lib/utils";
import {
  Tooltip,
  TooltipProvider,
  TooltipTrigger,
  TooltipContent,
} from "@/components/ui/tooltip";

interface WelcomeProps {
  onTabChange?: (tab: TabType) => void;
}

export default function Welcome({ onTabChange }: WelcomeProps) {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [_wLocation, setLocation] = useLocation(); // Wouter's navigation

  const [processingProgress, setProcessingProgress] = useState(0);
  const [processingStatus, setProcessingStatus] = useState("");
  const [projectNameInput, setProjectNameInput] = useState("");
  const [selectedFile, setSelectedFile] = useState<File | null>(null);

  // --- BEGIN MODIFICATION (Task 1.1) ---
  const [expectedReleaseDateInput, setExpectedReleaseDateInput] = useState("");
  const [totalBudgetInput, setTotalBudgetInput] = useState<string>(""); // Store as string to allow empty input initially
  // --- END MODIFICATION (Task 1.1) ---

  useEffect(() => {
    // Clear caches on Welcome page mount (existing logic)
    queryClient.removeQueries({ queryKey: ["/api/scripts/current"] });
    queryClient.removeQueries({ queryKey: ["/api/scripts/scenes"] });
    queryClient.removeQueries({ queryKey: ["/api/scripts/brandable-scenes"] });
    queryClient.removeQueries({ queryKey: ["/api/scripts/scene-variations"] });
    queryClient.removeQueries({ queryKey: ["/api/scripts/characters"] });
    queryClient.removeQueries({
      queryKey: ["/api/scripts/extracted-characters"],
    });
    queryClient.removeQueries({
      queryKey: ["/api/scripts/suggest-locations"],
    });
    queryClient.removeQueries({
      queryKey: ["/api/scenes/suggest-locations"],
    });
    queryClient.removeQueries({
      queryKey: ["/api/characters/suggest-actors"],
    });
    console.log("[Welcome] Relevant React Query caches cleared on mount.");
  }, [queryClient]);

  const uploadScriptMutation = useMutation({
    onMutate: async () => {
      setProcessingProgress(5);
      setProcessingStatus("Preparing for new script upload...");
      await queryClient.removeQueries(); // Clear all caches for a new session
      console.log(
        "[Welcome] All client-side React Query caches reset for new script session.",
      );
    },
    mutationFn: async (fileToUpload: File) => {
      setProcessingProgress(10);
      setProcessingStatus("Uploading script file...");
      const formData = new FormData();
      formData.append("script", fileToUpload);

      // --- BEGIN MODIFICATION (Task 1.1) ---
      // Prepare to pass new fields; actual sending will be fully enabled in Task 1.2
      if (projectNameInput.trim() !== "") {
        formData.append("projectName", projectNameInput.trim());
      }
      if (expectedReleaseDateInput) {
        formData.append("expectedReleaseDate", expectedReleaseDateInput);
      }
      if (totalBudgetInput) {
        const budgetValue = parseFloat(totalBudgetInput);
        if (!isNaN(budgetValue) && budgetValue >= 0) {
          formData.append("totalBudget", budgetValue.toString());
        }
      }
      // --- END MODIFICATION (Task 1.1) ---

      const response = await fetch("/api/scripts/upload", {
        method: "POST",
        body: formData,
        credentials: "include",
      });
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || "Failed to upload script");
      }
      return await response.json();
    },
    onSuccess: async (data) => {
      toast({
        title: "Script Uploaded & Processed",
        description: "Server processing initiated and completed.",
      });
      setProcessingProgress(75);
      setProcessingStatus("Server has processed the script...");
      console.log(
        "[Welcome] Upload successful. ScriptEditor will fetch fresh data.",
      );
      setProcessingProgress(100);
      setProcessingStatus("Redirecting to Script Analysis...");
      if (onTabChange) {
        setTimeout(() => {
          onTabChange("script");
          setProcessingProgress(0);
          setProcessingStatus("");
          setSelectedFile(null);
          // Optionally clear other inputs too, or leave them for quick re-upload
          // setProjectNameInput("");
          // setExpectedReleaseDateInput("");
          // setTotalBudgetInput("");
        }, 500);
      }
    },
    onError: (error: Error) => {
      toast({
        variant: "destructive",
        title: "Upload failed",
        description: error.message,
      });
      setProcessingProgress(0);
      setProcessingStatus("Upload failed. Please try again.");
    },
  });

  const isProcessingScript =
    uploadScriptMutation.isPending ||
    (uploadScriptMutation.isSuccess &&
      processingProgress < 100 &&
      processingStatus.includes("Redirecting"));

  const handleInitiateUploadForAnalysis = async (file: File) => {
    await uploadScriptMutation.mutateAsync(file);
  };

  const handleFileSelection = (file: File | null) => {
    setSelectedFile(file);
    if (file) {
      toast({
        title: "File Selected",
        description: `${file.name} is ready. Click "Begin Analysis" when ready.`,
      });
    } else if (selectedFile) {
      toast({
        variant: "destructive",
        title: "File Cleared",
        description: "Previous file selection was removed or invalid.",
      });
    }
  };

  const handleStartWriting = () => {
    // --- BEGIN MODIFICATION (Task 1.1) ---
    // Ensure project name is provided for ScriptWriter
    if (!projectNameInput.trim() || isProcessingScript || !!selectedFile) {
        if (!projectNameInput.trim()){
             toast({
                variant: "destructive",
                title: "Project Name Required",
                description: "Please enter a project name to start writing.",
            });
        }
        return;
    }
    // --- END MODIFICATION (Task 1.1) ---
    const projectName = projectNameInput.trim();
    setLocation(`/script-writer?projectName=${encodeURIComponent(projectName)}`);
    if (onTabChange) {
      onTabChange("script-writer");
    }
  };

  const handleBeginAnalysisClick = () => {
    if (selectedFile && projectNameInput.trim() && !isProcessingScript) {
      handleInitiateUploadForAnalysis(selectedFile);
    }
  };

  const canStartWriting =
    projectNameInput.trim() && !selectedFile && !isProcessingScript;
  const canBeginAnalysis =
    projectNameInput.trim() && !!selectedFile && !isProcessingScript;

  return (
    <div className="flex-grow flex flex-col items-center justify-center py-10 md:py-14 px-4 bg-vadis-light-gray-bg">
      <div className="text-center mb-10 md:mb-14 max-w-4xl w-full">
        <div className="flex justify-center mb-8 md:mb-10">
          <img
            src="/assets/vadis-media-logo-dark.png"
            alt="Vadis Media Logo"
            className="w-full h-auto max-w-[280px] sm:max-w-[320px] md:max-w-[380px]"
          />
        </div>
        <p className="text-lg md:text-xl text-gray-700 mb-10 md:mb-14">
          AI-powered script analysis for Optimizing Funding and Casting
        </p>

        <div className="space-y-10 md:space-y-12">
          <div className="bg-card rounded-xl shadow-xl p-6 sm:p-8 md:p-10 max-w-3xl mx-auto">
            {isProcessingScript ? (
              <div className="flex flex-col items-center">
                <Loader2 className="h-10 w-10 text-primary animate-spin mb-4" />
                <h2 className="text-xl font-semibold mb-4 text-vadis-dark-text">
                  Processing Your Script
                </h2>
                <p className="text-gray-600 mb-6 text-center">
                  {processingStatus.includes("Redirecting")
                    ? processingStatus
                    : "Please wait while we upload and analyze your screenplay."}
                </p>
                <div className="w-full max-w-md">
                  <Progress
                    value={processingProgress}
                    className="h-2 mb-2 bg-muted [&>div]:bg-primary"
                  />
                  {!processingStatus.includes("Redirecting") && (
                    <p className="text-sm text-gray-500 text-center">
                      {processingStatus}
                    </p>
                  )}
                </div>
              </div>
            ) : (
              <>
                <h2 className="text-2xl font-semibold mb-4 flex items-center text-vadis-dark-text">
                  <UploadBoxIcon className="mr-2 h-6 w-6 text-primary" />
                  Get Started
                </h2>
                <p className="text-gray-600 mb-6">
                  Enter your project details, then either start writing a new
                  script or upload an existing one for analysis.
                </p>

                {/* --- BEGIN MODIFICATION (Task 1.1) --- */}
                <div className="space-y-4 mb-6 max-w-md mx-auto text-left">
                  <div>
                    <Label htmlFor="projectName" className="font-medium text-gray-700">
                      Project Name <span className="text-red-500">*</span>
                    </Label>
                    <Input
                      id="projectName"
                      type="text"
                      placeholder="e.g., The Adventures of Captain Code"
                      value={projectNameInput}
                      onChange={(e) => setProjectNameInput(e.target.value)}
                      className="bg-white mt-1"
                      disabled={isProcessingScript}
                    />
                    {!projectNameInput.trim() && (
                      <p className="text-xs text-red-500 mt-1">
                        Project name is required.
                      </p>
                    )}
                  </div>

                  <div>
                    <Label htmlFor="expectedReleaseDate" className="font-medium text-gray-700">
                      Expected Release Date (Optional)
                    </Label>
                    <Input
                      id="expectedReleaseDate"
                      type="date"
                      value={expectedReleaseDateInput}
                      onChange={(e) =>
                        setExpectedReleaseDateInput(e.target.value)
                      }
                      className="bg-white mt-1"
                      disabled={isProcessingScript}
                    />
                  </div>

                  <div>
                    <Label htmlFor="totalBudget" className="font-medium text-gray-700">
                      Total Estimated Budget (USD, Optional)
                    </Label>
                    <Input
                      id="totalBudget"
                      type="number"
                      placeholder="e.g., 15000000"
                      value={totalBudgetInput}
                      onChange={(e) => setTotalBudgetInput(e.target.value)}
                      className="bg-white mt-1"
                      min="0"
                      disabled={isProcessingScript}
                    />
                  </div>
                </div>
                {/* --- END MODIFICATION (Task 1.1) --- */}

                <div className="mb-8">
                  <FileUpload
                    onFileSelected={handleFileSelection} // Changed prop name
                    isLoading={isProcessingScript}
                  />
                  {selectedFile && (
                    <p className="text-sm text-green-600 mt-2">
                      Selected for analysis: {selectedFile.name} (
                      {formatFileSize(selectedFile.size)})
                    </p>
                  )}
                </div>

                <TooltipProvider delayDuration={100}>
                  <div className="flex flex-col sm:flex-row justify-center items-center gap-3 sm:gap-4">
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <span>
                          <Button
                            onClick={handleStartWriting}
                            disabled={!canStartWriting}
                            className="w-full sm:w-auto"
                          >
                            <Pencil className="mr-2 h-4 w-4" /> Start Writing
                          </Button>
                        </span>
                      </TooltipTrigger>
                      <TooltipContent>
                        {!projectNameInput.trim() ? (
                          <p>Enter project name to enable.</p>
                        ) : selectedFile ? (
                          <p>
                            A file is selected for analysis. Clear it or
                            complete analysis first.
                          </p>
                        ) : isProcessingScript ? (
                          <p>
                            Cannot start writing while another process is
                            active.
                          </p>
                        ) : (
                          <p>
                            Create a new script from scratch using the project
                            name.
                          </p>
                        )}
                      </TooltipContent>
                    </Tooltip>

                    <Tooltip>
                      <TooltipTrigger asChild>
                        <span>
                          <Button
                            onClick={handleBeginAnalysisClick}
                            disabled={!canBeginAnalysis}
                            className="w-full sm:w-auto"
                          >
                            <Search className="mr-2 h-4 w-4" /> Begin Analysis
                          </Button>
                        </span>
                      </TooltipTrigger>
                      <TooltipContent>
                        {!projectNameInput.trim() ? (
                          <p>Enter project name to enable.</p>
                        ) : !selectedFile ? (
                          <p>
                            Upload a script file above to enable analysis.
                          </p>
                        ) : isProcessingScript ? (
                          <p>Processing another task.</p>
                        ) : (
                          <p>
                            Analyze the selected script:{" "}
                            {selectedFile?.name || ""}
                          </p>
                        )}
                      </TooltipContent>
                    </Tooltip>
                  </div>
                </TooltipProvider>

                <div className="text-xs text-muted-foreground mt-6 flex items-center justify-center space-x-1">
                  <ShieldCheck className="h-4 w-4 text-green-600" />
                  <span>
                    Your script is processed securely and will not be shared.
                  </span>
                </div>
              </>
            )}
          </div>

          <div className="bg-card rounded-xl shadow-xl p-6 sm:p-8 md:p-10 max-w-3xl mx-auto">
            <h2 className="text-2xl font-semibold mb-4 flex items-center text-vadis-dark-text">
              <PlaySquare className="mr-2 h-6 w-6 text-primary" />
              How It Works
            </h2>
            <ul className="space-y-4 text-gray-700 text-left">
              {[
                "Enter your Project Name. Optionally add Release Date & Budget.",
                "To write a new script, click 'Start Writing'.",
                "To analyze an existing script, upload your PDF file, then click 'Begin Analysis'.",
                "Vadis AI will extract scenes, identify brandable opportunities, and suggest locations & cast.",
                "Review AI-generated stills and videos for selected brand placements.",
                "Use the Financial Analysis tool to see potential funding offsets.",
                "Export your project assets and reports.",
              ].map((step, index) => (
                <li key={index} className="flex items-start text-gray-600">
                  <span className="flex-shrink-0 bg-primary text-primary-foreground h-6 w-6 flex items-center justify-center rounded-full text-sm font-semibold mr-4 mt-0.5">
                    {index + 1}
                  </span>
                  <span>{step}</span>
                </li>
              ))}
            </ul>
          </div>
        </div>
      </div>
    </div>
  );
}


================================================
FILE: db/index.ts
================================================
import { Pool, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-serverless';
import ws from "ws";
import * as schema from "@shared/schema";

// This is the correct way neon config - DO NOT change this
neonConfig.webSocketConstructor = ws;

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle({ client: pool, schema });


================================================
FILE: db/seed.ts
================================================
import { db } from "./index";
import * as schema from "@shared/schema";
import { eq } from "drizzle-orm";
import * as fs from "fs";
import * as path from "path";

async function seed() {
  try {
    console.log("Starting database seeding...");

    // Check if products already exist
    const existingProducts = await db.select({ count: { value: schema.products.id } })
      .from(schema.products)
      .limit(1);
    
    if (existingProducts.length > 0 && existingProducts[0].count.value > 0) {
      console.log("Products already exist in the database, skipping seed.");
      return;
    }

    // Sample product data based on the design
    const productsData = [
      {
        companyName: "Starbucks",
        name: "Starbucks Coffee",
        category: "BEVERAGE",
        imageUrl: "https://images.unsplash.com/photo-1577590835286-1cdd24c08fd7?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&h=160",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        companyName: "Apple",
        name: "Apple MacBook",
        category: "ELECTRONICS",
        imageUrl: "https://images.unsplash.com/photo-1611186871348-b1ce696e52c9?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&h=160",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        companyName: "Godiva",
        name: "Godiva Chocolate",
        category: "FOOD",
        imageUrl: "https://pixabay.com/get/g019557ea5a868fc7b6a061116435d92cb542c700e53c1c6d346ec4788cd236162754a6972e833c18688ad9d4cbe468383638fbbb8c2adee77141514db1c6a25a_1280.jpg",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        companyName: "Tesla",
        name: "Tesla Model 3",
        category: "AUTOMOTIVE",
        imageUrl: "https://images.unsplash.com/photo-1617788138017-80ad40651399?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&h=160",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        companyName: "Ray-Ban",
        name: "Ray-Ban Sunglasses",
        category: "FASHION",
        imageUrl: "https://images.unsplash.com/photo-1572635196237-14b3f281503f?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&h=160",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        companyName: "The Coca-Cola Company",
        name: "Coca-Cola",
        category: "BEVERAGE",
        imageUrl: "https://images.unsplash.com/photo-1554866585-cd94860890b7?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&h=160",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        companyName: "Samsung",
        name: "Samsung Galaxy S22",
        category: "ELECTRONICS",
        imageUrl: "https://images.unsplash.com/photo-1610945415295-d9bbf067e59c?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&h=160",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        companyName: "Mars Inc.",
        name: "Snickers",
        category: "FOOD",
        imageUrl: "https://images.unsplash.com/photo-1634913940786-58ce67cf72a7?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&h=160",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        companyName: "BMW",
        name: "BMW i8",
        category: "AUTOMOTIVE",
        imageUrl: "https://images.unsplash.com/photo-1556800572-1b8aeef2c54f?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&h=160",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        companyName: "Nike",
        name: "Nike Air Jordan",
        category: "FASHION",
        imageUrl: "https://images.unsplash.com/photo-1556906781-9a412961c28c?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&h=160",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        companyName: "Monster Beverage",
        name: "Monster Energy",
        category: "BEVERAGE",
        imageUrl: "https://images.unsplash.com/photo-1622543925917-763c34d1a86e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&h=160",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        companyName: "Sony",
        name: "Sony PlayStation 5",
        category: "ELECTRONICS",
        imageUrl: "https://images.unsplash.com/photo-1607853202273-797f1c22a38e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&h=160",
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ];

    // Insert products
    await db.insert(schema.products).values(productsData);

    // Sample script data
    const scriptData = {
      title: "COFFEE SHOP ROMANCE",
      content: `INT. COFFEE SHOP - DAY

SARAH (28) sits by the window, typing on her laptop. The coffee shop is moderately busy with morning customers.

MICHAEL (30) enters, spots Sarah, and approaches her table.

MICHAEL
Hey, sorry I'm late. Traffic was a nightmare.

SARAH
(looking up)
No worries, I just got here.

Michael sits down and places his bag on the empty chair.

MICHAEL
Have you ordered yet?

SARAH
Just a coffee. I was waiting for you before getting breakfast.

A BARISTA approaches their table.

BARISTA
Can I get you anything?

MICHAEL
I'll have a large coffee, please.

SARAH
And I'll take a blueberry muffin.

The barista nods and walks away.

MICHAEL
So, about the project...

Sarah opens a document on her laptop and turns it towards Michael.`,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // Only insert script if none exists
    const existingScripts = await db.select({ count: { value: schema.scripts.id } })
      .from(schema.scripts)
      .limit(1);
    
    if (existingScripts.length === 0 || existingScripts[0].count.value === 0) {
      const [script] = await db.insert(schema.scripts).values(scriptData).returning();
      
      // Create a sample scene
      const sceneData = {
        scriptId: script.id,
        sceneNumber: 1,
        heading: "INT. COFFEE SHOP - DAY",
        content: scriptData.content,
        isBrandable: true,
        brandableReason: "Coffee shop setting provides natural opportunities for beverage and food product placement",
        suggestedCategories: ["BEVERAGE", "FOOD", "ELECTRONICS"],
        createdAt: new Date()
      };
      
      await db.insert(schema.scenes).values(sceneData);
    }

    // Check if actors already exist
    const existingActors = await db.select({ count: { value: schema.actors.id } })
      .from(schema.actors)
      .limit(1);
    
    if (existingActors.length === 0 || existingActors[0].count.value === 0) {
      try {
        console.log("Seeding actors from actorDatabase.txt...");
        
        // Read the actor database file
        const actorFilePath = path.join(__dirname, '..', 'attached_assets', 'actorDatabase.txt');
        const actorFileContent = fs.readFileSync(actorFilePath, 'utf8');
        
        // Skip the header line and process each actor line
        const actorLines = actorFileContent.split('\n').filter(line => line.trim().length > 0);
        const header = actorLines[0]; // Skip header
        
        const actorsData = [];
        
        // Process each actor line starting from line 2 (index 1)
        for (let i = 1; i < actorLines.length; i++) {
          const line = actorLines[i];
          
          // Split by pipe character and trim spaces
          const parts = line.split('|').map(part => part.trim());
          
          if (parts.length >= 11) {
            const name = parts[0].replace(/\*\*/g, ''); // Remove ** from names
            const gender = parts[1];
            const nationality = parts[2];
            
            // Extract notable roles - remove * markers and split by comma
            const notableRolesText = parts[3].replace(/\*/g, '');
            const notableRoles = notableRolesText.split(',').map(role => role.trim());
            
            // Split genres by comma
            const genres = parts[4].split(',').map(genre => genre.trim());
            
            const recentPopularity = parts[5];
            
            // Split typical roles by comma
            const typicalRolesText = parts[6];
            const typicalRoles = typicalRolesText.split(',').map(role => role.trim());
            
            const estSalaryRange = parts[7];
            const socialMediaFollowing = parts[8];
            const availability = parts[9];
            const bestSuitedRolesStrategic = parts[10];
            
            actorsData.push({
              name,
              gender,
              nationality,
              notableRoles,
              genres,
              recentPopularity,
              typicalRoles,
              estSalaryRange,
              socialMediaFollowing,
              availability,
              bestSuitedRolesStrategic,
              createdAt: new Date(),
              updatedAt: new Date()
            });
          }
        }
        
        if (actorsData.length > 0) {
          // Insert actors in batches to avoid very large queries
          const batchSize = 10;
          for (let i = 0; i < actorsData.length; i += batchSize) {
            const batch = actorsData.slice(i, i + batchSize);
            await db.insert(schema.actors).values(batch);
          }
          
          console.log(`Successfully seeded ${actorsData.length} actors.`);
        } else {
          console.log("No actor data found to seed.");
        }
      } catch (error) {
        console.error("Error seeding actors:", error);
      }
    } else {
      console.log("Actors already exist in the database, skipping actor seed.");
    }

    console.log("Database seeding completed successfully.");
  } catch (error) {
    console.error("Error seeding database:", error);
    throw error;
  }
}

seed().catch(error => {
  console.error("Fatal error during seeding:", error);
  process.exit(1);
});



================================================
FILE: server/index.ts
================================================
// import express, { type Request, Response, NextFunction } from "express";
// import { registerRoutes } from "./routes";
// import { setupVite, serveStatic, log } from "./vite";

// const app = express();
// app.use(express.json());
// app.use(express.urlencoded({ extended: false }));

// app.use((req, res, next) => {
//   const start = Date.now();
//   const path = req.path;
//   let capturedJsonResponse: Record<string, any> | undefined = undefined;

//   const originalResJson = res.json;
//   res.json = function (bodyJson, ...args) {
//     capturedJsonResponse = bodyJson;
//     return originalResJson.apply(res, [bodyJson, ...args]);
//   };

//   res.on("finish", () => {
//     const duration = Date.now() - start;
//     if (path.startsWith("/api")) {
//       let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
//       if (capturedJsonResponse) {
//         logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
//       }

//       if (logLine.length > 80) {
//         logLine = logLine.slice(0, 79) + "…";
//       }

//       log(logLine);
//     }
//   });

//   next();
// });

// (async () => {
//   const server = await registerRoutes(app);

//   app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
//     const status = err.status || err.statusCode || 500;
//     const message = err.message || "Internal Server Error";

//     res.status(status).json({ message });
//     throw err;
//   });

//   // importantly only setup vite in development and after
//   // setting up all the other routes so the catch-all route
//   // doesn't interfere with the other routes
//   if (app.get("env") === "development") {
//     await setupVite(app, server);
//   } else {
//     serveStatic(app);
//   }

//   // ALWAYS serve the app on port 5000
//   // this serves both the API and the client.
//   // It is the only port that is not firewalled.
//   const port = 5000;
//   server.listen({
//     port,
//     host: "0.0.0.0",
//     reusePort: true,
//   }, () => {
//     log(`serving on port ${port}`);
//   });
// })();


import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";

const app = express();

// Increase the limit for JSON payloads
// Default is 100kb. Let's set it to something like 10MB to be safe for large scripts.
app.use(express.json({ limit: '10mb' }));
// Also increase for URL-encoded data, though less likely to be the issue here
app.use(express.urlencoded({ limit: '10mb', extended: false }));


app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "…";
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  const server = await registerRoutes(app);

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    // If the error is due to payload too large, provide a more specific message
    if (err.type === 'entity.too.large') {
        log(`Error: Request entity too large for ${err.requestPath || _req.path}. Length: ${err.length}, Limit: ${err.limit}`);
        return res.status(413).json({ message: "The script data is too large to process for PDF export in a single request. Please try with a shorter script or contact support." });
    }

    res.status(status).json({ message });
    // Removed "throw err;" as it might cause unhandled rejection if not caught upstream
    // console.error("Unhandled error in middleware:", err); 
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  // ALWAYS serve the app on port 5000
  // this serves both the API and the client.
  // It is the only port that is not firewalled.
  const port = 5000;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true,
  }, () => {
    log(`serving on port ${port}`);
  });
})();



================================================
FILE: server/routes.ts
================================================
// server/routes.ts
import type { Express } from "express";
import { createServer, type Server } from "http";
import * as storage from "./storage";
import multer from "multer";
import { extractScriptFromPdf } from "./services/pdf-service";
import {
    generateProductPlacement,
    generateVideoFromVariation,
    getPredictionStatus,
} from "./services/replicate-service";
import {
    identifyBrandableScenesWithGemini,
    generateCreativePlacementPrompt,
    AIAnalysisResponseForRoutes,
    extractCharactersWithGemini,
    ExtractedCharacter as BackendExtractedCharacter,
} from "./services/file-upload-service";
import {
    suggestActorsForCharacterViaGemini,
    ActorAISuggestion,
    suggestLocationsForScriptViaGemini,
    LocationAISuggestion,
} from "./services/ai-suggestion-service";
import { z } from "zod";
import {
    insertProductSchema,
    insertActorSchema,
    insertLocationSchema,
    scriptGenerationFormSchema,
    ProductCategory,
    Product as DbProduct,
    Scene as DbScene,
    Actor as DbActor,
    Location as DbLocation,
    ScriptGenerationFormData as DbScriptGenerationFormData,
    SceneVariation as DbSceneVariation,
    Product,
    Script,
} from "@shared/schema";
import { ZodError } from "zod";
import {
    ActorSuggestion as ClientActorSuggestion,
    ClientSuggestedLocation,
    ScriptCharacter,
} from "../../client/src/lib/types";
import { generateScriptWithGemini } from "./services/script-generation-service";
import { generateScriptPdf } from "./services/pdf-generation-service";
import { generateFinancialBreakdown } from "./services/financial-analysis-service";
import { analyzeAndStoreScriptVFX } from "./services/vfx-analysis-service";
// Character suggestion functionality moved to character-suggestion-optimizer


// ... (interfaces, utility functions, multer setup, _generateAndSaveSceneVariationsForRoute remain the same)
// --- Interfaces ---
interface SceneVariation extends DbSceneVariation {
    productName?: string;
    productCategory?: ProductCategory;
    productImageUrl?: string | null;
}

// --- Utility Functions ---
const sanitizeString = (str: string | null | undefined): string => {
    if (!str) return "";
    return str.replace(/\u0000/g, "").replace(/[^\x20-\x7E\u00A0-\uFFFF]/g, "");
};

// --- Multer Setup ---
const upload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 15 * 1024 * 1024 },
    fileFilter: (req, file, cb) => {
        const allowedTypes = [
            "application/pdf",
            "image/jpeg",
            "image/png",
            "image/jpg",
        ];
        if (allowedTypes.includes(file.mimetype)) {
            cb(null, true);
        } else {
            cb(new Error("Invalid file type. Only PDF, JPG, PNG allowed."));
        }
    },
});

async function _generateAndSaveSceneVariationsForRoute(
    sceneId: number,
): Promise<SceneVariation[]> {
    // ... (this function remains largely the same)
    const logPrefix = `[VarGen Route S:${sceneId}]`;
    try {
        let scene = await storage.getSceneById(sceneId);
        if (!scene) {
            console.error(`${logPrefix} Scene not found.`);
            return [];
        }
        if (
            !scene.isBrandable ||
            !scene.suggestedCategories ||
            scene.suggestedCategories.length === 0
        ) {
            try {
                const analysisResult = await identifyBrandableScenesWithGemini(
                    [scene],
                    1,
                );
                if (
                    analysisResult.brandableScenes.length > 0 &&
                    analysisResult.brandableScenes[0].sceneId === scene.id
                ) {
                    const brandableData = analysisResult.brandableScenes[0];
                    const updatedSceneInDb = await storage.updateScene(
                        scene.id,
                        {
                            isBrandable: true,
                            brandableReason: brandableData.reason,
                            suggestedCategories:
                                brandableData.suggestedProducts,
                        },
                    );
                    if (updatedSceneInDb) scene = updatedSceneInDb;
                } else {
                    if (!scene.isBrandable) {
                        const updatedSceneInDb = await storage.updateScene(
                            scene.id,
                            { isBrandable: true },
                        );
                        if (updatedSceneInDb) scene = updatedSceneInDb;
                    }
                }
            } catch (analysisError) {
                console.error(
                    `${logPrefix} Error during on-demand scene analysis:`,
                    analysisError,
                );
            }
        }
        const categories = scene.suggestedCategories || [];
        const selectedProducts = await storage.getTopMatchingProductsForScene(
            sceneId,
            categories,
            3,
        );
        if (selectedProducts.length === 0) return [];
        const variationPromises = selectedProducts.map(async (product, i) => {
            const variationNumber = i + 1;
            const varLogPrefixV = `${logPrefix} V${variationNumber} (P:${product.id})`;
            try {
                const creativePrompt = await generateCreativePlacementPrompt(
                    scene!,
                    product,
                );
                if (!creativePrompt || creativePrompt.includes("Error:")) {
                    throw new Error(`Gemini prompt error: ${creativePrompt}`);
                }
                const generationResult = await generateProductPlacement({
                    scene: scene!,
                    product,
                    variationNumber,
                    prompt: creativePrompt,
                });
                const cleanDescription = `Variation ${variationNumber}: ${product.name} in ${scene!.heading}. Prompt used: ${creativePrompt.substring(0, 50)}...`;
                const variationData = {
                    sceneId: scene!.id,
                    productId: product.id,
                    variationNumber,
                    description: sanitizeString(cleanDescription),
                    imageUrl: generationResult.imageUrl,
                    geminiPrompt: creativePrompt,
                    isSelected: false,
                };
                const newVariationDb =
                    await storage.createSceneVariation(variationData);
                return {
                    ...newVariationDb,
                    productName: product.name,
                    productCategory: product.category,
                    productImageUrl: product.imageUrl,
                } as SceneVariation;
            } catch (error) {
                console.error(
                    `${varLogPrefixV} Error in variation generation:`,
                    error,
                );
                return null;
            }
        });
        const results = await Promise.all(variationPromises);
        return results.filter((v): v is SceneVariation => v !== null);
    } catch (outerError) {
        console.error(
            `${logPrefix} CRITICAL ERROR in on-demand variation generation process:`,
            outerError,
        );
        return [];
    }
}


export async function registerRoutes(app: Express): Promise<Server> {
    const apiPrefix = "/api";

    // --- Actor Routes ---
    // ...

    // --- Product Routes ---
    // ...

    // --- Location Routes ---
    // ...

    // --- Script Routes ---
    // ... (existing script routes up to /api/scripts/export)
    app.get(`${apiPrefix}/actors`, async (req, res, next) => {
        try {
            const page = parseInt((req.query.page as string) || "1");
            const pageSize = parseInt((req.query.pageSize as string) || "10");
            const search = (req.query.search as string) || "";
            const gender = (req.query.gender as string) || "";
            const nationality = (req.query.nationality as string) || "";
            const result = await storage.getActors({
                search,
                gender,
                nationality,
                page,
                pageSize,
            });
            res.json(result);
        } catch (e) {
            next(e);
        }
    });
    app.put(`${apiPrefix}/actors/:id`, async (req, res, next) => {
        try {
            const id = parseInt(req.params.id);
            if (isNaN(id))
                return res.status(400).json({ message: "Invalid ID" });
            const data = insertActorSchema.partial().parse(req.body);
            const updated = await storage.updateActor(id, data);
            if (!updated) return res.status(404).json({ message: "Not found" });
            res.json(updated);
        } catch (e) {
            if (e instanceof ZodError)
                return res
                    .status(400)
                    .json({ message: "Validation failed", errors: e.errors });
            next(e);
        }
    });


    // --- Product Routes ---
    app.get(`${apiPrefix}/products`, async (req, res, next) => {
        try {
            const page = parseInt((req.query.page as string) || "1");
            const pageSize = parseInt((req.query.pageSize as string) || "12");
            const search = (req.query.search as string) || "";
            const category = (req.query.category as string) || "ALL";
            const result = await storage.getProducts({
                search,
                category,
                page,
                pageSize,
            });
            res.json(result);
        } catch (e) {
            next(e);
        }
    });
    app.post(`${apiPrefix}/products`, async (req, res, next) => {
        try {
            const data = insertProductSchema.parse(req.body);
            const newProd = await storage.createProduct(data);
            res.status(201).json(newProd);
        } catch (e) {
            if (e instanceof ZodError)
                return res
                    .status(400)
                    .json({ message: "Validation failed", errors: e.errors });
            next(e);
        }
    });
    app.put(`${apiPrefix}/products/:id`, async (req, res, next) => {
        try {
            const id = parseInt(req.params.id);
            if (isNaN(id))
                return res.status(400).json({ message: "Invalid ID" });
            const data = insertProductSchema
                .partial()
                .omit({ id: true, createdAt: true, updatedAt: true })
                .parse(req.body);
            const updated = await storage.updateProduct(id, data);
            if (!updated) return res.status(404).json({ message: "Not found" });
            res.json(updated);
        } catch (e) {
            if (e instanceof ZodError)
                return res
                    .status(400)
                    .json({ message: "Validation failed", errors: e.errors });
            next(e);
        }
    });
    app.delete(`${apiPrefix}/products/:id`, async (req, res, next) => {
        try {
            const id = parseInt(req.params.id);
            if (isNaN(id))
                return res.status(400).json({ message: "Invalid ID" });
            const deleted = await storage.deleteProduct(id);
            if (!deleted) return res.status(404).json({ message: "Not found" });
            res.status(204).send();
        } catch (e) {
            next(e);
        }
    });


    // --- Location Routes ---
    app.get(`${apiPrefix}/locations`, async (req, res, next) => {
        try {
            const page = parseInt((req.query.page as string) || "1");
            const pageSize = parseInt((req.query.pageSize as string) || "10");
            const search = (req.query.search as string) || "";
            const country = (req.query.country as string) || "ALL";
            const result = await storage.getLocations({
                search,
                country,
                page,
                pageSize,
            });
            res.json(result);
        } catch (e) {
            next(e);
        }
    });
    app.post(`${apiPrefix}/locations`, async (req, res, next) => {
        try {
            const data = insertLocationSchema.parse(req.body);
            const newLoc = await storage.createLocation(data);
            res.status(201).json(newLoc);
        } catch (e) {
            if (e instanceof ZodError)
                return res
                    .status(400)
                    .json({ message: "Validation failed", errors: e.errors });
            next(e);
        }
    });
    app.put(`${apiPrefix}/locations/:id`, async (req, res, next) => {
        try {
            const id = parseInt(req.params.id);
            if (isNaN(id))
                return res.status(400).json({ message: "Invalid ID" });
            const data = insertLocationSchema
                .partial()
                .omit({ id: true, createdAt: true, updatedAt: true })
                .parse(req.body);
            const updated = await storage.updateLocation(id, data);
            if (!updated) return res.status(404).json({ message: "Not found" });
            res.json(updated);
        } catch (e) {
            if (e instanceof ZodError)
                return res
                    .status(400)
                    .json({ message: "Validation failed", errors: e.errors });
            next(e);
        }
    });
    app.delete(`${apiPrefix}/locations/:id`, async (req, res, next) => {
        try {
            const id = parseInt(req.params.id);
            if (isNaN(id))
                return res.status(400).json({ message: "Invalid ID" });
            const deleted = await storage.deleteLocation(id);
            if (!deleted) return res.status(404).json({ message: "Not found" });
            res.status(204).send();
        } catch (e) {
            next(e);
        }
    });

    // --- Script Routes ---
    app.get(`${apiPrefix}/scripts/current`, async (_req, res, next) => {
        try {
            const script = await storage.getCurrentScript();
            if (!script)
                return res
                    .status(404)
                    .json({ message: "No current script found" });
            res.json({
                id: script.id,
                title: script.title,
                expectedReleaseDate: script.expectedReleaseDate,
                totalBudget: script.totalBudget,
                createdAt: script.createdAt,
                updatedAt: script.updatedAt,
            });
        } catch (e) {
            next(e);
        }
    });

    app.post(
        `${apiPrefix}/scripts/upload`,
        upload.single("script"),
        async (req, res, next) => {
            let script: Script | null = null;
            try {
                if (!req.file) {
                    return res
                        .status(400)
                        .json({ message: "No file uploaded" });
                }

                const parsedScript = await extractScriptFromPdf(
                    req.file.buffer,
                    req.file.mimetype,
                );

                if (parsedScript.content.startsWith("Error:")) {
                    return res.status(400).json({
                        message: `Script extraction failed: ${parsedScript.title}`,
                    });
                }

                const userProvidedProjectName = req.body.projectName as string | undefined;
                const expectedReleaseDate = req.body.expectedReleaseDate as string | undefined;
                const totalBudgetStr = req.body.totalBudget as string | undefined;

                let totalBudget: number | null = null;
                if (totalBudgetStr) {
                    const parsedBudget = parseFloat(totalBudgetStr);
                    if (!isNaN(parsedBudget)) {
                        totalBudget = Math.round(parsedBudget); 
                    } else {
                        console.warn(`[Upload] Invalid totalBudget string received: "${totalBudgetStr}". Storing as null.`);
                    }
                }

                let finalScriptTitle = sanitizeString(parsedScript.title);
                if (userProvidedProjectName && userProvidedProjectName.trim() !== "") {
                    finalScriptTitle = sanitizeString(userProvidedProjectName.trim());
                }

                script = await storage.createScript({
                    title: finalScriptTitle,
                    content: parsedScript.content,
                    expectedReleaseDate: expectedReleaseDate || null,
                    totalBudget: totalBudget,
                });

                const createdScenes: DbScene[] = [];
                for (const sceneData of parsedScript.scenes) {
                    const newScene = await storage.createScene({
                        scriptId: script.id,
                        sceneNumber: sceneData.sceneNumber,
                        heading: sanitizeString(sceneData.heading),
                        content: sceneData.content,
                    });
                    createdScenes.push(newScene);
                }

                let analysisResult: AIAnalysisResponseForRoutes = { brandableScenes: [] };
                if (createdScenes.length > 0) {
                    // Analyze brandable scenes
                    analysisResult = await identifyBrandableScenesWithGemini(createdScenes, 5);
                    const updatePromises = analysisResult.brandableScenes.map(
                        (brandable) =>
                            storage.updateScene(brandable.sceneId, {
                                isBrandable: true,
                                brandableReason: sanitizeString(brandable.reason),
                                suggestedCategories: brandable.suggestedProducts,
                            }).catch((e) =>
                                console.error(`[Upload] Failed updating scene ${brandable.sceneId} with brandable info:`, e)
                            ),
                    );
                    await Promise.all(updatePromises);

                    // Analyze VFX scenes
                    try {
                        await analyzeAndStoreScriptVFX(script.id, parsedScript.content, createdScenes);
                        console.log(`[Upload] VFX analysis completed for script ${script.id}`);
                    } catch (vfxError) {
                        console.error(`[Upload] VFX analysis failed for script ${script.id}:`, vfxError);
                        // Don't fail the upload if VFX analysis fails
                    }
                }

                res.status(201).json({
                    script: { 
                        id: script.id, 
                        title: script.title,
                        expectedReleaseDate: script.expectedReleaseDate,
                        totalBudget: script.totalBudget,
                    },
                    scenesCount: createdScenes.length,
                    brandableScenesCount: analysisResult.brandableScenes.length,
                });
            } catch (e) {
                console.error("[Upload Route Error]", e);
                next(e);
            }
        },
    );

    app.get(`${apiPrefix}/scripts/scenes`, async (_req, res, next) => {
        try {
            const script = await storage.getCurrentScript();
            if (!script)
                return res
                    .status(404)
                    .json({ message: "No current script found" });
            const scenes = await storage.getScenesByScriptId(script.id);
            res.json(scenes);
        } catch (e) {
            next(e);
        }
    });
    app.get(
        `${apiPrefix}/scripts/brandable-scenes`,
        async (_req, res, next) => {
            try {
                const script = await storage.getCurrentScript();
                if (!script)
                    return res
                        .status(404)
                        .json({ message: "No current script found" });
                const scenes = await storage.getBrandableScenes(script.id);
                res.json(scenes);
            } catch (e) {
                next(e);
            }
        },
    );
    app.get(`${apiPrefix}/scripts/scene-variations`, async (req, res, next) => {
        const sceneIdParam = req.query.sceneId as string;
        try {
            const sceneId = parseInt(sceneIdParam);
            if (isNaN(sceneId))
                return res
                    .status(400)
                    .json({ message: "Valid Scene ID is required" });
            let variations = await storage.getSceneVariations(sceneId);
            if (variations.length === 0 && sceneId > 0) {
                variations =
                    await _generateAndSaveSceneVariationsForRoute(sceneId);
            }
            res.json(variations);
        } catch (e: any) {
            next(e);
        }
    });
    app.put(
        `${apiPrefix}/scripts/variations/select`,
        async (req, res, next) => {
            try {
                const id = parseInt(req.body.variationId as string);
                if (isNaN(id))
                    return res
                        .status(400)
                        .json({ message: "Invalid Variation ID" });
                const updated = await storage.selectVariation(id);
                if (!updated)
                    return res
                        .status(404)
                        .json({ message: "Variation not found." });
                res.json(updated);
            } catch (e) {
                next(e);
            }
        },
    );
    app.put(
        `${apiPrefix}/variations/:variationId/update-prompt-and-image`,
        async (req, res, next) => {
            try {
                const id = parseInt(req.params.variationId);
                const { newPrompt } = req.body;
                if (isNaN(id))
                    return res
                        .status(400)
                        .json({ message: "Invalid Variation ID" });
                if (
                    !newPrompt ||
                    typeof newPrompt !== "string" ||
                    newPrompt.trim().length < 10
                )
                    return res.status(400).json({
                        message: "Valid new prompt is required (min 10 chars).",
                    });
                const variation = await storage.getSceneVariationById(id);
                if (!variation)
                    return res.status(404).json({
                        message: `Variation with ID ${id} not found.`,
                    });
                const scene = await storage.getSceneById(variation.sceneId);
                if (!scene)
                    return res.status(404).json({
                        message: `Scene with ID ${variation.sceneId} not found.`,
                    });
                const product = await storage.getProductById(
                    variation.productId,
                );
                if (!product)
                    return res.status(404).json({
                        message: `Product with ID ${variation.productId} not found.`,
                    });
                const genResult = await generateProductPlacement({
                    scene,
                    product,
                    variationNumber: variation.variationNumber,
                    prompt: newPrompt,
                });
                if (!genResult.success)
                    return res.status(500).json({
                        message: "Failed to regenerate image.",
                        details: genResult.description,
                    });
                const updated = await storage.updateSceneVariation(id, {
                    geminiPrompt: newPrompt,
                    imageUrl: genResult.imageUrl,
                    description: `Variation ${variation.variationNumber}: ${product.name} - ${scene.heading}. User Prompt: ${newPrompt.substring(0, 40)}...`,
                });
                if (!updated)
                    return res.status(500).json({
                        message:
                            "Failed to update variation after image regeneration.",
                    });
                res.json(updated);
            } catch (e) {
                next(e);
            }
        },
    );
    app.put(
        `${apiPrefix}/variations/:variationId/change-product`,
        async (req, res, next) => {
            try {
                const id = parseInt(req.params.variationId);
                const { newProductId } = req.body;
                const pNewProdId = parseInt(newProductId as string);
                if (isNaN(id) || isNaN(pNewProdId))
                    return res.status(400).json({
                        message:
                            "Valid Variation ID and New Product ID are required.",
                    });
                const origVar = await storage.getSceneVariationById(id);
                if (!origVar)
                    return res.status(404).json({
                        message: `Variation with ID ${id} not found.`,
                    });
                const scene = await storage.getSceneById(origVar.sceneId);
                if (!scene)
                    return res.status(404).json({
                        message: `Scene with ID ${origVar.sceneId} not found.`,
                    });
                const newProd = await storage.getProductById(pNewProdId);
                if (!newProd)
                    return res.status(404).json({
                        message: `New product with ID ${pNewProdId} not found.`,
                    });
                const newCreativePrompt = await generateCreativePlacementPrompt(
                    scene,
                    newProd,
                );
                if (!newCreativePrompt || newCreativePrompt.includes("Error:"))
                    throw new Error(
                        `Gemini failed to generate prompt: ${newCreativePrompt}`,
                    );
                const genResult = await generateProductPlacement({
                    scene,
                    product: newProd,
                    variationNumber: origVar.variationNumber,
                    prompt: newCreativePrompt,
                });
                if (!genResult.success)
                    return res.status(500).json({
                        message: "Failed to regen image for new product.",
                        details: genResult.description,
                    });
                const updated = await storage.updateSceneVariation(id, {
                    productId: newProd.id,
                    geminiPrompt: newCreativePrompt,
                    imageUrl: genResult.imageUrl,
                    description: `Var ${origVar.variationNumber}: ${newProd.name} - ${scene.heading}. Prompt: ${newCreativePrompt.substring(0, 50)}...`,
                    isSelected: false,
                });
                if (!updated)
                    return res.status(500).json({
                        message:
                            "Failed to update variation after product change.",
                    });
                res.json(updated);
            } catch (e) {
                next(e);
            }
        },
    );
    app.post(
        `${apiPrefix}/variations/:variationId/generate-video`,
        async (req, res, next) => {
            try {
                const id = parseInt(req.params.variationId);
                if (isNaN(id))
                    return res
                        .status(400)
                        .json({ message: "Valid Variation ID is required" });
                const result = await generateVideoFromVariation(id);
                if (result.error)
                    return res.status(500).json({
                        message: result.error,
                        predictionId: result.predictionId,
                    });
                res.status(202).json({
                    message: "Video generation started.",
                    predictionId: result.predictionId,
                    status: result.status,
                });
            } catch (e) {
                next(e);
            }
        },
    );
    app.get(
        `${apiPrefix}/replicate/predictions/:predictionId`,
        async (req, res, next) => {
            try {
                const id = req.params.predictionId;
                if (!id || typeof id !== "string")
                    return res
                        .status(400)
                        .json({ message: "Valid Prediction ID is required" });
                const result = await getPredictionStatus(id);
                res.json(result);
            } catch (e) {
                next(e);
            }
        },
    );
    app.get(`${apiPrefix}/scripts/export`, async (_req, res, next) => {
        res.status(501).json({ message: "Export not implemented yet" });
    });


    // --- BEGIN MODIFICATION (Task 1.3) ---
    app.get(`${apiPrefix}/scripts/:scriptId/financial-analysis`, async (req, res, next) => {
        try {
            const scriptIdParam = req.params.scriptId;
            const scriptId = parseInt(scriptIdParam);

            if (isNaN(scriptId)) {
                return res.status(400).json({ message: "Valid Script ID is required." });
            }

            const financialData = await generateFinancialBreakdown(scriptId);

            if (!financialData) {
                return res.status(404).json({ message: `Script with ID ${scriptId} not found or financial data could not be generated.` });
            }

            res.json(financialData);
        } catch (e) {
            console.error(`[Financial Analysis Endpoint Error for Script ID ${req.params.scriptId}]:`, e);
            next(e); // Pass to global error handler
        }
    });
    // --- END MODIFICATION (Task 1.3) ---

    // --- Script Generation Route ---
    // ...
    app.post(
        `${apiPrefix}/scripts/generate-from-prompt`,
        async (req, res, next) => {
            try {
                const formData = scriptGenerationFormSchema.parse(req.body);
                const generatedScript =
                    await generateScriptWithGemini(formData);
                res.json({ script: generatedScript });
            } catch (error) {
                if (error instanceof ZodError) {
                    return res
                        .status(400)
                        .json({
                            message: "Validation failed",
                            errors: error.errors,
                        });
                }
                console.error("[API /generate-from-prompt] Error:", error);
                next(error);
            }
        },
    );

    // --- PDF Export Route ---
    // ...
    app.post(`${apiPrefix}/scripts/export-pdf`, async (req, res, next) => {
        try {
            const { scriptContent, title } = req.body;
            if (!scriptContent || typeof scriptContent !== "string") {
                return res
                    .status(400)
                    .json({ message: "Script content is required." });
            }
            if (!title || typeof title !== "string" || title.trim() === "") {
                return res
                    .status(400)
                    .json({ message: "Valid script title is required." });
            }

            const pdfBuffer = await generateScriptPdf(scriptContent, title);
            res.setHeader("Content-Type", "application/pdf");
            res.setHeader(
                "Content-Disposition",
                `attachment; filename="${title.replace(/[^a-z0-9]/gi, "_")}.pdf"`,
            );
            res.send(pdfBuffer);
        } catch (error) {
            console.error("[API /export-pdf] Error:", error);
            next(error);
        }
    });

    // --- AI Suggestion Routes ---
    // ... (these routes remain the same)
    app.get(
        `${apiPrefix}/scripts/:scriptId/suggest-locations`,
        async (req, res, next) => {
            const scriptIdParam = req.params.scriptId;
            const budgetParam = req.query.budget as string;
            const countParam = req.query.count as string;
            const logPrefix = `[Route Script Location Suggestion for Script ID:${scriptIdParam}]`;
            try {
                const scriptId = parseInt(scriptIdParam);
                if (isNaN(scriptId))
                    return res
                        .status(400)
                        .json({ message: "Valid Script ID is required" });

                const script = await storage.getScriptById(scriptId);
                if (!script || !script.content) {
                    return res.status(404).json({
                        message: "Script not found or has no content",
                    });
                }

                const projectBudget = budgetParam
                    ? parseInt(budgetParam)
                    : undefined;
                const numberOfSuggestions = countParam
                    ? parseInt(countParam)
                    : 5;

                const allDbLocations =
                    await storage.getAllLocationsForAISuggestion();
                if (allDbLocations.length === 0) {
                    console.log(
                        `${logPrefix} No locations in DB to suggest from.`,
                    );
                    return res.json([]);
                }

                const aiLocationSuggestions: LocationAISuggestion[] =
                    await suggestLocationsForScriptViaGemini(
                        script.content,
                        script.id,
                        allDbLocations,
                        projectBudget,
                        numberOfSuggestions,
                    );

                if (aiLocationSuggestions.length === 0) return res.json([]);

                const finalSuggestedLocations: ClientSuggestedLocation[] = [];
                for (const aiSugg of aiLocationSuggestions) {
                    const locationDetails = await storage.getLocationById(
                        aiSugg.locationId,
                    );
                    if (locationDetails) {
                        finalSuggestedLocations.push({
                            ...locationDetails,
                            matchReason: aiSugg.matchReason,
                            estimatedIncentiveValue:
                                aiSugg.estimatedIncentiveNotes,
                            confidenceScore: aiSugg.confidenceScore,
                        });
                    } else {
                        console.warn(
                            `${logPrefix} Location ID "${aiSugg.locationId}" suggested by AI not found in DB.`,
                        );
                    }
                }
                res.json(finalSuggestedLocations);
            } catch (error) {
                console.error(`${logPrefix} Error:`, error);
                next(error);
            }
        },
    );

    app.get(
        `${apiPrefix}/scripts/:scriptId/characters`,
        async (req, res, next) => {
            const scriptIdParam = req.params.scriptId;
            const logPrefix = `[Characters Route for Script ID:${scriptIdParam}]`;
            try {
                const scriptId = parseInt(scriptIdParam);
                if (isNaN(scriptId))
                    return res
                        .status(400)
                        .json({ message: "Valid Script ID is required" });

                const script = await storage.getScriptById(scriptId);
                if (!script || !script.content)
                    return res.status(404).json({
                        message: "Script not found or has no content",
                    });

                console.log(`${logPrefix} Extracting characters from script content`);
                const characters: ScriptCharacter[] = await extractCharactersWithGemini(script.content);

                try {
                    if (characters.length > 0) {
                        console.log(`${logPrefix} Starting background prefetch for ${Math.min(5, characters.length)} main characters`);
                        // Background prefetching removed during cleanup
                        console.log(`${logPrefix} Character prefetching disabled`);;
                    }
                } catch (prefetchError: any) {
                    console.error(`${logPrefix} Prefetch setup error: ${prefetchError.message}`);
                }

                return res.json(characters);
            } catch (error) {
                console.error(`${logPrefix} Error extracting characters:`, error);
                next(error);
            }
        },
    );

    app.get(
        `${apiPrefix}/characters/:characterName/suggest-actors`,
        async (req, res, next) => {
            const characterName = req.params.characterName;
            const {
                scriptId: queryScriptId,
                filmGenre: filmGenreFromUI,
                roleType: roleTypeFromUI,
                budgetTier: budgetTierFromUI,
                gender: genderFilterFromUI,
            } = req.query as {
                scriptId?: string;
                filmGenre?: string;
                roleType?: string;
                budgetTier?: string;
                gender?: string;
            };
            const logPrefix = `[Route Actor Suggestion for "${characterName}" in Script ${queryScriptId}]`;

            try {
                if (!characterName) {
                    return res.status(400).json({ message: "Character name required" });
                }

                if (!queryScriptId) {
                    return res.status(400).json({ message: "Script ID query parameter is required" });
                }

                const scriptId = parseInt(queryScriptId);
                if (isNaN(scriptId)) {
                    return res.status(400).json({ message: "Valid Script ID is required" });
                }

                const { getActorSuggestionsWithCaching } = await import('./services/character-suggestion-optimizer');
                console.log(`${logPrefix} Using optimized character suggestion service with caching`);

                const aiSuggestions = await getActorSuggestionsWithCaching(
                    scriptId,
                    characterName,
                    filmGenreFromUI,
                    roleTypeFromUI,
                    budgetTierFromUI,
                    genderFilterFromUI
                );

                if (aiSuggestions.length === 0) {
                    console.log(`${logPrefix} No suggestions found for character`);
                    return res.json([]);
                }

                const finalSuggestions: ClientActorSuggestion[] = [];
                for (const aiSugg of aiSuggestions) {
                    const directDbActor = await storage.getActorByName(aiSugg.actorName);
                    if (directDbActor) {
                        finalSuggestions.push({
                            ...directDbActor,
                            matchReason: aiSugg.matchReason,
                            controversyLevel: aiSugg.controversyLevel,
                        });
                    } else {
                        console.warn(`${logPrefix} Actor "${aiSugg.actorName}" not found in DB.`);
                    }
                }
                console.log(`${logPrefix} Returning ${finalSuggestions.length} suggestions`);
                return res.json(finalSuggestions);
            } catch (error) {
                console.error(`${logPrefix} Error processing request:`, error);
                next(error);
            }
        },
    );

    app.post(
        `${apiPrefix}/characters/batch-suggest-actors`,
        async (req, res, next) => {
            try {
                const { scriptId, characters } = req.body as {
                    scriptId: number,
                    characters: {
                        name: string,
                        criteria: {
                            filmGenre?: string;
                            roleType?: string;
                            budgetTier?: string;
                            gender?: string;
                        }
                    }[]
                };

                if (!scriptId) return res.status(400).json({ message: "Script ID is required" });
                if (!characters || !Array.isArray(characters) || characters.length === 0) {
                    return res.status(400).json({ message: "At least one character is required" });
                }

                const response: Record<string, ClientActorSuggestion[]> = {};

                for (const character of characters) {
                    // Use the character-suggestion-optimizer service instead
                    const { getActorSuggestionsWithCaching } = await import('./services/character-suggestion-optimizer');
                    const aiSuggestions = await getActorSuggestionsWithCaching(
                        character,
                        {}
                    );

                    const characterClientSuggestions: ClientActorSuggestion[] = [];
                    if (aiSuggestions.length > 0) {
                        for (const aiSugg of aiSuggestions) {
                            const actorDetails = await storage.getActorByName(aiSugg.actorName);
                            if (actorDetails) {
                                characterClientSuggestions.push({
                                    ...actorDetails,
                                    matchReason: aiSugg.matchReason,
                                    controversyLevel: aiSugg.controversyLevel,
                                });
                            }
                        }
                    }
                    response[character.name] = characterClientSuggestions;
                }

                res.json(response);
            } catch (error) {
                console.error('[Batch Character Suggest] Error:', error);
                next(error);
            }
        }
    );

    app.post(
        `${apiPrefix}/scripts/:scriptId/prefetch-character-suggestions`,
        async (req, res, next) => {
            const scriptIdParam = req.params.scriptId;
            try {
                const scriptId = parseInt(scriptIdParam);
                if (isNaN(scriptId)) return res.status(400).json({ message: "Valid Script ID is required" });

                // Prefetch functionality disabled during cleanup
                console.log(`[Prefetch Route] Prefetch disabled for script ${scriptId}`);

                res.status(202).json({ message: "Character suggestions prefetch started", scriptId });
            } catch (error) {
                next(error);
            }
        }
    );

    // VFX Analysis endpoint - analyze existing script for VFX scenes
    app.post(`${apiPrefix}/scripts/:scriptId/analyze-vfx`, async (req, res, next) => {
        try {
            const scriptId = parseInt(req.params.scriptId);
            if (isNaN(scriptId)) {
                return res.status(400).json({ message: "Valid Script ID is required" });
            }

            const logPrefix = `[VFX Analysis Route for Script ${scriptId}]`;
            console.log(`${logPrefix} Starting VFX analysis`);

            // Get the script
            const script = await storage.getScriptById(scriptId);
            if (!script) {
                return res.status(404).json({ message: "Script not found" });
            }

            // Get all scenes for this script
            const scenes = await storage.getScenesByScriptId(scriptId);
            if (scenes.length === 0) {
                return res.status(400).json({ message: "No scenes found for this script" });
            }

            console.log(`${logPrefix} Found ${scenes.length} scenes to analyze`);

            // Run VFX analysis
            await analyzeAndStoreScriptVFX(scriptId, script.content, scenes);

            // Count VFX scenes after analysis
            const updatedScenes = await storage.getScenesByScriptId(scriptId);
            const vfxScenesCount = updatedScenes.filter(scene => scene.isVfxScene).length;

            console.log(`${logPrefix} VFX analysis completed. ${vfxScenesCount} VFX scenes identified`);

            res.status(200).json({
                message: "VFX analysis completed successfully",
                scriptId,
                totalScenes: scenes.length,
                vfxScenesCount,
            });

        } catch (error) {
            console.error(`[VFX Analysis Route] Error:`, error);
            next(error);
        }
    });

    // Initiate full VFX analysis for script (alternative endpoint)
    app.post(`${apiPrefix}/scripts/:scriptId/initiate-vfx-analysis`, async (req, res, next) => {
        try {
            const scriptId = parseInt(req.params.scriptId);
            if (isNaN(scriptId)) {
                return res.status(400).json({ message: "Valid Script ID is required" });
            }

            const logPrefix = `[VFX Initiate Route for Script ${scriptId}]`;
            console.log(`${logPrefix} Starting full VFX re-analysis`);

            // Get the script
            const script = await storage.getScriptById(scriptId);
            if (!script) {
                return res.status(404).json({ message: "Script not found" });
            }

            // Get all scenes for this script
            const scenes = await storage.getScenesByScriptId(scriptId);
            if (scenes.length === 0) {
                return res.status(400).json({ message: "No scenes found for this script" });
            }

            console.log(`${logPrefix} Found ${scenes.length} scenes to re-analyze`);

            // Run VFX analysis
            await analyzeAndStoreScriptVFX(scriptId, script.content, scenes);

            // Count VFX scenes after analysis
            const updatedScenes = await storage.getScenesByScriptId(scriptId);
            const vfxScenesCount = updatedScenes.filter(scene => scene.isVfxScene).length;

            console.log(`${logPrefix} Full VFX re-analysis completed. ${vfxScenesCount} VFX scenes identified`);

            res.status(200).json({
                message: "Full VFX analysis initiated and completed successfully",
                scriptId,
                totalScenes: scenes.length,
                vfxScenesCount,
            });

        } catch (error) {
            console.error(`[VFX Initiate Route] Error:`, error);
            next(error);
        }
    });

    // Get VFX scenes with tier details (on-demand generation)
    app.get(`${apiPrefix}/scripts/:scriptId/vfx-scenes`, async (req, res, next) => {
        try {
            const scriptId = parseInt(req.params.scriptId);
            if (isNaN(scriptId)) {
                return res.status(400).json({ message: "Valid Script ID is required" });
            }

            const logPrefix = `[VFX Scenes Route for Script ${scriptId}]`;
            console.log(`${logPrefix} Fetching VFX scenes with tier details`);

            // Get all scenes for this script
            const allScenes = await storage.getScenesByScriptId(scriptId);
            if (allScenes.length === 0) {
                return res.status(404).json({ message: "No scenes found for this script" });
            }

            // Filter VFX scenes
            const vfxScenes = allScenes.filter(scene => scene.isVfxScene);
            console.log(`${logPrefix} Found ${vfxScenes.length} VFX scenes out of ${allScenes.length} total scenes`);

            const vfxScenesWithDetails = [];

            for (const scene of vfxScenes) {
                try {
                    // Get existing VFX tier details
                    let vfxDetails = await storage.getVfxSceneDetailsBySceneId(scene.id);

                    // If no tier details exist, generate them on-demand
                    if (vfxDetails.length === 0) {
                        console.log(`${logPrefix} No tier details found for scene ${scene.id}, generating on-demand`);
                        
                        const { generateAndStoreVFXTierDetailsForScene } = await import("./services/vfx-analysis-service");
                        await generateAndStoreVFXTierDetailsForScene(scene);
                        
                        // Re-fetch the newly generated details
                        vfxDetails = await storage.getVfxSceneDetailsBySceneId(scene.id);
                        console.log(`${logPrefix} Generated ${vfxDetails.length} tier details for scene ${scene.id}`);
                    }

                    // Add the scene with its VFX details
                    vfxScenesWithDetails.push({
                        ...scene,
                        vfxDetails: vfxDetails
                    });

                } catch (sceneError) {
                    console.error(`${logPrefix} Error processing scene ${scene.id}:`, sceneError);
                    // Include scene without details if generation fails
                    vfxScenesWithDetails.push({
                        ...scene,
                        vfxDetails: []
                    });
                }
            }

            console.log(`${logPrefix} Returning ${vfxScenesWithDetails.length} VFX scenes with tier details`);

            res.status(200).json(vfxScenesWithDetails);

        } catch (error) {
            console.error(`[VFX Scenes Route] Error:`, error);
            next(error);
        }
    });

    // Select VFX tier for a scene
    app.put(`${apiPrefix}/scenes/:sceneId/select-vfx-tier`, async (req, res, next) => {
        try {
            const sceneId = parseInt(req.params.sceneId);
            if (isNaN(sceneId)) {
                return res.status(400).json({ message: "Valid Scene ID is required" });
            }

            const { qualityTier } = req.body;
            if (!qualityTier || !['LOW', 'MEDIUM', 'HIGH'].includes(qualityTier)) {
                return res.status(400).json({ message: "Valid qualityTier (LOW, MEDIUM, HIGH) is required" });
            }

            const logPrefix = `[VFX Tier Select Scene ${sceneId}]`;
            console.log(`${logPrefix} Selecting ${qualityTier} tier`);

            // Get the scene
            const scene = await storage.getSceneById(sceneId);
            if (!scene) {
                return res.status(404).json({ message: "Scene not found" });
            }

            if (!scene.isVfxScene) {
                return res.status(400).json({ message: "Scene is not marked as a VFX scene" });
            }

            // Get VFX tier details for the selected tier
            const vfxDetails = await storage.getVfxSceneDetailsBySceneId(sceneId);
            const selectedTierDetail = vfxDetails.find(detail => detail.qualityTier === qualityTier);

            if (!selectedTierDetail) {
                return res.status(404).json({ 
                    message: `VFX tier details for ${qualityTier} not found. Please generate tier details first.` 
                });
            }

            // Update scene with selected tier and cost
            const updatedScene = await storage.updateScene(sceneId, {
                selectedVfxTier: qualityTier,
                selectedVfxCost: selectedTierDetail.estimatedVfxCost || 0
            });

            console.log(`${logPrefix} Selected ${qualityTier} tier with cost $${selectedTierDetail.estimatedVfxCost}`);

            res.status(200).json({
                message: "VFX tier selected successfully",
                sceneId,
                selectedTier: qualityTier,
                selectedCost: selectedTierDetail.estimatedVfxCost,
                scene: updatedScene
            });

        } catch (error) {
            console.error(`[VFX Tier Select Route] Error:`, error);
            next(error);
        }
    });

    // VFX Image Generation Route
    app.post(`${apiPrefix}/scenes/:sceneId/generate-vfx-image`, async (req: Request, res: Response, next: NextFunction) => {
        try {
            const sceneId = parseInt(req.params.sceneId);
            if (isNaN(sceneId)) {
                return res.status(400).json({ message: "Valid Scene ID is required" });
            }

            const { qualityTier } = req.body;
            if (!qualityTier || !['LOW', 'MEDIUM', 'HIGH'].includes(qualityTier)) {
                return res.status(400).json({ message: "Valid qualityTier (LOW, MEDIUM, HIGH) is required" });
            }

            const logPrefix = `[VFX IMG Gen Scene ${sceneId}]`;
            console.log(`${logPrefix} Starting VFX image generation for ${qualityTier} tier`);

            // Get the scene
            const scene = await storage.getSceneById(sceneId);
            if (!scene) {
                return res.status(404).json({ message: "Scene not found" });
            }

            if (!scene.isVfxScene) {
                return res.status(400).json({ message: "Scene is not marked as a VFX scene" });
            }

            // Check if scene is also brandable and get selected brand image
            let brandableImageUrl: string | undefined;
            if (scene.isBrandable) {
                const variations = await storage.getSceneVariations(sceneId);
                const selectedVariation = variations.find(v => v.isSelected);
                if (selectedVariation?.imageUrl) {
                    brandableImageUrl = selectedVariation.imageUrl;
                    console.log(`${logPrefix} Scene is also brandable, using reference image for VFX generation`);
                }
            }

            // Import VFX generation service
            const { generateVFXImage } = await import("./services/replicate-service");

            // Generate VFX image using same model as brandable scenes
            const result = await generateVFXImage({
                scene,
                vfxDescription: scene.vfxDescription || "VFX scene",
                vfxKeywords: scene.vfxKeywords || [],
                qualityTier,
                brandableImageUrl
            });

            if (!result.success) {
                console.error(`${logPrefix} VFX image generation failed:`, result.error);
                return res.status(500).json({ 
                    message: "VFX image generation failed", 
                    error: result.error 
                });
            }

            console.log(`${logPrefix} VFX image generated successfully: ${result.imageUrl.substring(0, 50)}...`);

            res.status(200).json({
                message: "VFX image generated successfully",
                imageUrl: result.imageUrl,
                sceneId,
                qualityTier
            });

        } catch (error) {
            console.error(`[VFX Image Generation Route] Error:`, error);
            next(error);
        }
    });

    // VFX Video Generation Route
    app.post(`${apiPrefix}/scenes/:sceneId/generate-vfx-video`, async (req: Request, res: Response, next: NextFunction) => {
        try {
            const sceneId = parseInt(req.params.sceneId);
            if (isNaN(sceneId)) {
                return res.status(400).json({ message: "Valid Scene ID is required" });
            }

            const { qualityTier, imageUrl } = req.body;
            if (!qualityTier || !['LOW', 'MEDIUM', 'HIGH'].includes(qualityTier)) {
                return res.status(400).json({ message: "Valid qualityTier (LOW, MEDIUM, HIGH) is required" });
            }

            if (!imageUrl || typeof imageUrl !== 'string') {
                return res.status(400).json({ message: "Valid imageUrl is required for video generation" });
            }

            const logPrefix = `[VFX VIDEO Gen Scene ${sceneId}]`;
            console.log(`${logPrefix} Starting VFX video generation for ${qualityTier} tier from image`);

            // Get the scene
            const scene = await storage.getSceneById(sceneId);
            if (!scene) {
                return res.status(404).json({ message: "Scene not found" });
            }

            if (!scene.isVfxScene) {
                return res.status(400).json({ message: "Scene is not marked as a VFX scene" });
            }

            // Import VFX video generation service
            const { generateVFXVideoFromImage } = await import("./services/replicate-service");

            // Generate VFX video using same model as brandable scenes
            const result = await generateVFXVideoFromImage(imageUrl, scene, qualityTier);

            if (!result.predictionId) {
                console.error(`${logPrefix} VFX video generation failed:`, result.error);
                return res.status(500).json({ 
                    message: "VFX video generation failed", 
                    error: result.error 
                });
            }

            console.log(`${logPrefix} VFX video generation started. Prediction ID: ${result.predictionId}`);

            res.status(200).json({
                message: "VFX video generation started",
                predictionId: result.predictionId,
                status: result.status,
                sceneId,
                qualityTier
            });

        } catch (error) {
            console.error(`[VFX Video Generation Route] Error:`, error);
            next(error);
        }
    });

    const httpServer = createServer(app);
    return httpServer;
}


================================================
FILE: server/storage.ts
================================================
// server/storage.ts
import { db } from "@db";
import {
  products,
  scripts, // Ensure scripts is imported
  scenes,
  sceneVariations,
  actors,
  locations,
  vfxSceneDetails,
  insertProductSchema,
  insertScriptSchema, // Ensure insertScriptSchema is imported
  insertSceneSchema,
  insertSceneVariationSchema,
  insertActorSchema,
  insertLocationSchema,
  insertVfxSceneDetailSchema,
  Product,
  ProductCategory,
  Script, // Ensure Script type is imported
  Scene,
  SceneVariation, 
  Actor,
  Location,
  VfxSceneDetail,
  VfxQualityTierType,
} from "@shared/schema";
import {
  eq,
  and,
  like,
  desc,
  sql,
  count,
  asc,
  not,
  or,
  gte,
  lte,
  placeholder,
  ilike,
} from "drizzle-orm";
import { ZodError } from "zod";

// --- Utility: Get Product for Scene Variation ---
// ... (getProductForVariation remains the same)
async function getProductForVariation(
  productId: number,
): Promise<Product | null> {
  const result = await db
    .select()
    .from(products)
    .where(eq(products.id, productId))
    .limit(1);
  return result.length > 0 ? result[0] : null;
}


// --- Products ---
// ... (Product functions remain the same)
export async function getProducts(
  options: {
    search?: string;
    category?: string;
    page?: number;
    pageSize?: number;
  } = {},
) {
  const { search = "", category = "ALL", page = 1, pageSize = 12 } = options;
  const offset = (page - 1) * pageSize;
  let query = db.select().from(products).$dynamic();
  const conditions = [];
  if (search) {
    conditions.push(
      or(
        ilike(products.name, `%${search}%`),
        ilike(products.companyName, `%${search}%`),
      ),
    );
  }
  if (category && category !== "ALL") {
    conditions.push(eq(products.category, category as ProductCategory));
  }
  if (conditions.length > 0) {
    query = query.where(and(...conditions));
  }

  let countQuery = db
    .select({ count: sql<number>`count(*)` })
    .from(products)
    .$dynamic();
  if (conditions.length > 0) {
    countQuery = countQuery.where(and(...conditions));
  }

  const countResult = await countQuery;
  const total = Number(countResult[0]?.count || 0);
  const result = await query
    .orderBy(desc(products.createdAt))
    .limit(pageSize)
    .offset(offset);
  return {
    products: result,
    totalCount: total,
    currentPage: page,
    totalPages: Math.ceil(total / pageSize),
    pageSize,
  };
}
export async function getProductById(id: number): Promise<Product | null> {
  const result = await db
    .select()
    .from(products)
    .where(eq(products.id, id))
    .limit(1);
  return result.length > 0 ? result[0] : null;
}
export async function createProduct(
  data: Omit<Product, "id" | "createdAt" | "updatedAt">,
): Promise<Product> {
  try {
    const validatedData = insertProductSchema.parse({ ...data });
    const result = await db.insert(products).values(validatedData).returning();
    return result[0];
  } catch (e) {
    if (e instanceof ZodError) {
      throw new Error(
        `Validation error: ${e.errors.map((err: any) => `${err.path.join(".")}: ${err.message}`).join(", ")}`,
      );
    }
    throw e;
  }
}
export async function updateProduct(
  id: number,
  data: Partial<Omit<Product, "id" | "createdAt">>,
): Promise<Product | null> {
  try {
    const partialSchema = insertProductSchema
      .partial()
      .omit({ id: true, createdAt: true, updatedAt: true });
    const validatedUpdateData = partialSchema.parse(data);
    const result = await db
      .update(products)
      .set({ ...validatedUpdateData, updatedAt: new Date() })
      .where(eq(products.id, id))
      .returning();
    return result.length > 0 ? result[0] : null;
  } catch (e) {
    if (e instanceof ZodError) {
      throw new Error(
        `Validation error: ${e.errors.map((err: any) => `${err.path.join(".")}: ${err.message}`).join(", ")}`,
      );
    }
    throw e;
  }
}
export async function deleteProduct(id: number): Promise<boolean> {
  const result = await db
    .delete(products)
    .where(eq(products.id, id))
    .returning();
  return result.length > 0;
}


// --- Scripts ---
export async function getCurrentScript(): Promise<Script | null> {
  const result = await db
    .select()
    .from(scripts)
    .orderBy(desc(scripts.createdAt))
    .limit(1);
  return result.length > 0 ? result[0] : null;
}

export async function getScriptById(id: number): Promise<Script | null> {
  const result = await db
    .select()
    .from(scripts)
    .where(eq(scripts.id, id))
    .limit(1);
  return result.length > 0 ? result[0] : null;
}

// --- BEGIN MODIFICATION (Task 1.2) ---
export async function createScript(
  data: Omit<Script, "id" | "createdAt" | "updatedAt"> & {
    expectedReleaseDate?: string | null;
    totalBudget?: number | null;
  },
): Promise<Script> {
  try {
    // The insertScriptSchema from shared/schema.ts already includes these new fields as optional
    // So, we can directly parse the data object.
    const validatedData = insertScriptSchema.parse({
      title: data.title,
      content: data.content,
      expectedReleaseDate: data.expectedReleaseDate, // Will be undefined or null if not provided
      totalBudget: data.totalBudget, // Will be undefined or null if not provided
    });

    const result = await db.insert(scripts).values(validatedData).returning();
    return result[0];
  } catch (e) {
    if (e instanceof ZodError) {
      console.error("Zod validation error in createScript:", e.errors);
      throw new Error(
        `Validation error creating script: ${e.errors.map((err) => `${err.path.join(".")}: ${err.message}`).join(", ")}`,
      );
    }
    console.error("Error in createScript:", e);
    throw e;
  }
}
// --- END MODIFICATION (Task 1.2) ---

export async function updateScript(
  id: number,
  data: Partial<Omit<Script, "id" | "createdAt">>,
): Promise<Script | null> {
  try {
    // Ensure the partial schema also considers the new optional fields if they can be updated
    const partialSchema = insertScriptSchema 
      .partial()
      .omit({ id: true, createdAt: true, updatedAt: true });
    const validatedUpdateData = partialSchema.parse(data);

    const result = await db
      .update(scripts)
      .set({ ...validatedUpdateData, updatedAt: new Date() })
      .where(eq(scripts.id, id))
      .returning();
    return result.length > 0 ? result[0] : null;
  } catch (e) {
    if (e instanceof ZodError) {
      throw new Error(
        `Validation error updating script: ${e.errors.map((err) => `${err.path.join(".")}: ${err.message}`).join(", ")}`,
      );
    }
    throw e;
  }
}

export async function deleteScript(id: number): Promise<boolean> {
  const result = await db.delete(scripts).where(eq(scripts.id, id)).returning();
  return result.length > 0;
}

// --- Scenes ---
// ... (Scene functions remain the same)
export async function getScenesByScriptId(scriptId: number): Promise<Scene[]> {
  return await db
    .select()
    .from(scenes)
    .where(eq(scenes.scriptId, scriptId))
    .orderBy(asc(scenes.sceneNumber));
}
export async function getBrandableScenes(scriptId: number): Promise<Scene[]> {
  return await db
    .select()
    .from(scenes)
    .where(and(eq(scenes.scriptId, scriptId), eq(scenes.isBrandable, true)))
    .orderBy(asc(scenes.sceneNumber));
}
export async function getSceneById(id: number): Promise<Scene | null> {
  const result = await db
    .select()
    .from(scenes)
    .where(eq(scenes.id, id))
    .limit(1);
  return result.length > 0 ? result[0] : null;
}
export async function createScene(
  data: Omit<Scene, "id" | "createdAt" | "updatedAt">,
): Promise<Scene> {
  try {
    const validatedData = insertSceneSchema.parse({ ...data });
    const result = await db.insert(scenes).values(validatedData).returning();
    return result[0];
  } catch (e) {
    if (e instanceof ZodError) {
      throw new Error(
        `Validation error: ${e.errors.map((err: any) => `${err.path.join(".")}: ${err.message}`).join(", ")}`,
      );
    }
    throw e;
  }
}
export async function updateScene(
  id: number,
  data: Partial<Omit<Scene, "id" | "createdAt">>,
): Promise<Scene | null> {
  try {
    const partialSchema = insertSceneSchema
      .partial()
      .omit({ id: true, createdAt: true, updatedAt: true });
    const validatedUpdateData = partialSchema.parse(data);
    const result = await db
      .update(scenes)
      .set({ ...validatedUpdateData, updatedAt: new Date() })
      .where(eq(scenes.id, id))
      .returning();
    return result.length > 0 ? result[0] : null;
  } catch (e) {
    if (e instanceof ZodError) {
      throw new Error(
        `Validation error: ${e.errors.map((err: any) => `${err.path.join(".")}: ${err.message}`).join(", ")}`,
      );
    }
    throw e;
  }
}
export async function deleteScene(id: number): Promise<boolean> {
  const result = await db.delete(scenes).where(eq(scenes.id, id)).returning();
  return result.length > 0;
}


// --- Scene Variations ---
// ... (SceneVariation functions remain the same)
export async function getSceneVariations(
  sceneId: number,
): Promise<SceneVariation[]> {
  const result = await db
    .select({
      id: sceneVariations.id,
      sceneId: sceneVariations.sceneId,
      productId: sceneVariations.productId,
      variationNumber: sceneVariations.variationNumber,
      description: sceneVariations.description,
      imageUrl: sceneVariations.imageUrl,
      geminiPrompt: sceneVariations.geminiPrompt,
      isSelected: sceneVariations.isSelected,
      createdAt: sceneVariations.createdAt,
      updatedAt: sceneVariations.updatedAt,
      productName: products.name,
      productCategory: products.category,
      productImageUrl: products.imageUrl,
    })
    .from(sceneVariations)
    .leftJoin(products, eq(sceneVariations.productId, products.id))
    .where(eq(sceneVariations.sceneId, sceneId))
    .orderBy(asc(sceneVariations.variationNumber));
  return result.map((v) => ({
    ...v,
    productCategory: v.productCategory as ProductCategory | undefined,
  }));
}
export async function getSceneVariationById(
  id: number,
): Promise<SceneVariation | null> {
  const result = await db
    .select({
      id: sceneVariations.id,
      sceneId: sceneVariations.sceneId,
      productId: sceneVariations.productId,
      variationNumber: sceneVariations.variationNumber,
      description: sceneVariations.description,
      imageUrl: sceneVariations.imageUrl,
      geminiPrompt: sceneVariations.geminiPrompt,
      isSelected: sceneVariations.isSelected,
      createdAt: sceneVariations.createdAt,
      updatedAt: sceneVariations.updatedAt,
      productName: products.name,
      productCategory: products.category,
      productImageUrl: products.imageUrl,
    })
    .from(sceneVariations)
    .leftJoin(products, eq(sceneVariations.productId, products.id))
    .where(eq(sceneVariations.id, id))
    .limit(1);
  if (result.length === 0) return null;
  const variation = result[0];
  return {
    ...variation,
    productCategory: variation.productCategory as ProductCategory | undefined,
  };
}
export async function createSceneVariation(
  data: Omit<SceneVariation, "id" | "createdAt" | "updatedAt">,
): Promise<SceneVariation> {
  try {
    const validatedData = insertSceneVariationSchema.parse({ ...data });
    if (!validatedData.geminiPrompt) {
      throw new Error("Gemini prompt is missing.");
    }
    const result = await db
      .insert(sceneVariations)
      .values(validatedData)
      .returning();
    const productDetails = await getProductForVariation(result[0].productId);
    return {
      ...result[0],
      productName: productDetails?.name,
      productCategory: productDetails?.category as ProductCategory | undefined,
      productImageUrl: productDetails?.imageUrl,
    };
  } catch (e) {
    if (e instanceof ZodError) {
      throw new Error(
        `Validation error: ${e.errors.map((err: any) => `${err.path.join(".")}: ${err.message}`).join(", ")}`,
      );
    }
    throw e;
  }
}
export async function updateSceneVariation(
  id: number,
  data: Partial<Omit<SceneVariation, "id" | "createdAt">>,
): Promise<SceneVariation | null> {
  try {
    const partialSchema = insertSceneVariationSchema
      .partial()
      .omit({ id: true, createdAt: true, updatedAt: true });
    const validatedUpdateData = partialSchema.parse(data);
    const result = await db
      .update(sceneVariations)
      .set({ ...validatedUpdateData, updatedAt: new Date() })
      .where(eq(sceneVariations.id, id))
      .returning();
    if (result.length === 0) return null;
    const productDetails = await getProductForVariation(result[0].productId);
    return {
      ...result[0],
      productName: productDetails?.name,
      productCategory: productDetails?.category as ProductCategory | undefined,
      productImageUrl: productDetails?.imageUrl,
    };
  } catch (e) {
    if (e instanceof ZodError) {
      throw new Error(
        `Validation error: ${e.errors.map((err: any) => `${err.path.join(".")}: ${err.message}`).join(", ")}`,
      );
    }
    throw e;
  }
}
export async function deleteSceneVariation(id: number): Promise<boolean> {
  const result = await db
    .delete(sceneVariations)
    .where(eq(sceneVariations.id, id))
    .returning();
  return result.length > 0;
}
export async function selectVariation(
  id: number,
): Promise<SceneVariation | null> {
  try {
    return await db.transaction(async (tx) => {
      const variationToSelect = await tx
        .select({ sceneId: sceneVariations.sceneId })
        .from(sceneVariations)
        .where(eq(sceneVariations.id, id))
        .limit(1);
      if (!variationToSelect || variationToSelect.length === 0) return null;
      const { sceneId } = variationToSelect[0];
      await tx
        .update(sceneVariations)
        .set({ isSelected: false, updatedAt: new Date() })
        .where(
          and(
            eq(sceneVariations.sceneId, sceneId),
            not(eq(sceneVariations.id, id)),
          ),
        );
      const result = await tx
        .update(sceneVariations)
        .set({ isSelected: true, updatedAt: new Date() })
        .where(eq(sceneVariations.id, id))
        .returning();
      if (result.length > 0) {
        const productDetails = await getProductForVariation(
          result[0].productId,
        );
        return {
          ...result[0],
          productName: productDetails?.name,
          productCategory: productDetails?.category as
            | ProductCategory
            | undefined,
          productImageUrl: productDetails?.imageUrl,
        };
      }
      return null;
    });
  } catch (e) {
    throw e;
  }
}


// --- Product Matching ---
// ... (getTopMatchingProductsForScene remains the same)
export async function getTopMatchingProductsForScene(
  sceneId: number,
  suggestedCategories: ProductCategory[],
  limit: number = 3,
): Promise<Product[]> {
  try {
    if (!suggestedCategories || suggestedCategories.length === 0) {
      return await db
        .select()
        .from(products)
        .orderBy(desc(products.createdAt))
        .limit(limit);
    }
    const validCategories = suggestedCategories.filter((cat) =>
      Object.values(ProductCategory).includes(cat),
    );
    if (validCategories.length === 0) {
      return await db
        .select()
        .from(products)
        .orderBy(desc(products.createdAt))
        .limit(limit);
    }
    const matchingProducts = await db
      .select()
      .from(products)
      .where(sql`${products.category} IN ${validCategories}`)
      .orderBy(desc(products.createdAt))
      .limit(limit);
    if (matchingProducts.length < limit) {
      const needed = limit - matchingProducts.length;
      const existingIds = matchingProducts.map((p) => p.id);
      const additionalProductsQuery = db
        .select()
        .from(products)
        .orderBy(desc(products.createdAt))
        .limit(needed);
      if (existingIds.length > 0) {
        additionalProductsQuery.where(
          sql`${products.id} NOT IN ${existingIds}`,
        );
      }
      const additionalProducts = await additionalProductsQuery;
      return [...matchingProducts, ...additionalProducts];
    }
    return matchingProducts;
  } catch (e) {
    return await db
      .select()
      .from(products)
      .orderBy(desc(products.createdAt))
      .limit(limit);
  }
}


// --- Actors ---
// ... (Actor functions remain the same, except getActorsForAISuggestionByCriteria if modified for age)
export async function getActors(
  options: {
    search?: string;
    gender?: string;
    nationality?: string;
    page?: number;
    pageSize?: number;
  } = {},
): Promise<{
  actors: Actor[];
  totalCount: number;
  currentPage: number;
  totalPages: number;
  pageSize: number;
}> {
  const {
    search = "",
    gender = "",
    nationality = "",
    page = 1,
    pageSize = 10,
  } = options;
  const offset = (page - 1) * pageSize;

  const conditions = [];
  if (search) {
    conditions.push(ilike(actors.name, `%${search}%`));
  }
  if (gender && gender.toLowerCase() !== "all") {
    conditions.push(sql`lower(${actors.gender}) = ${gender.toLowerCase()}`);
  }
  if (nationality && nationality.toLowerCase() !== "all") {
    conditions.push(ilike(actors.nationality, nationality));
  }

  let query = db.select().from(actors).$dynamic();
  let countQuery = db
    .select({ count: sql<number>`count(*)` })
    .from(actors)
    .$dynamic();

  if (conditions.length > 0) {
    query = query.where(and(...conditions));
    countQuery = countQuery.where(and(...conditions));
  }

  const countResult = await countQuery;
  const total = Number(countResult[0]?.count || 0);
  const result = await query
    .orderBy(asc(actors.name))
    .limit(pageSize)
    .offset(offset);
  return {
    actors: result,
    totalCount: total,
    currentPage: page,
    totalPages: Math.ceil(total / pageSize),
    pageSize,
  };
}
export async function getActorById(id: number): Promise<Actor | null> {
  const result = await db
    .select()
    .from(actors)
    .where(eq(actors.id, id))
    .limit(1);
  return result.length > 0 ? result[0] : null;
}
export async function createActor(
  data: Omit<Actor, "id" | "createdAt" | "updatedAt">,
): Promise<Actor> {
  try {
    const validatedData = insertActorSchema.parse({ ...data });
    const result = await db.insert(actors).values(validatedData).returning();
    return result[0];
  } catch (e) {
    if (e instanceof ZodError) {
      throw new Error(
        `Validation error: ${e.errors.map((err: any) => `${err.path.join(".")}: ${err.message}`).join(", ")}`,
      );
    }
    throw e;
  }
}
export async function updateActor(
  id: number,
  data: Partial<Omit<Actor, "id" | "createdAt">>,
): Promise<Actor | null> {
  try {
    const partialSchema = insertActorSchema
      .partial()
      .omit({ id: true, createdAt: true, updatedAt: true });
    const validatedUpdateData = partialSchema.parse(data);
    const result = await db
      .update(actors)
      .set({ ...validatedUpdateData, updatedAt: new Date() })
      .where(eq(actors.id, id))
      .returning();
    return result.length > 0 ? result[0] : null;
  } catch (e) {
    if (e instanceof ZodError) {
      throw new Error(
        `Validation error: ${e.errors.map((err: any) => `${err.path.join(".")}: ${err.message}`).join(", ")}`,
      );
    }
    throw e;
  }
}
export async function deleteActor(id: number): Promise<boolean> {
  const result = await db.delete(actors).where(eq(actors.id, id)).returning();
  return result.length > 0;
}

export async function getActorByName(name: string): Promise<Actor | null> {
  const result = await db
    .select()
    .from(actors)
    .where(eq(actors.name, name))
    .limit(1);
  return result.length > 0 ? result[0] : null;
}

export async function getActorsForAISuggestionByCriteria(criteria: {
  minBirthYear?: number;
  maxBirthYear?: number;
  gender?: string;
  limit?: number;
  estimatedAgeRange?: string;
}): Promise<Actor[]> {
  const { gender, limit = 60, estimatedAgeRange } = criteria;
  let { minBirthYear, maxBirthYear } = criteria;

  const conditions = [];
  const currentYear = new Date().getFullYear();

  if (!minBirthYear && !maxBirthYear && estimatedAgeRange) {
    const ageParts = estimatedAgeRange.match(/\d+/g);
    if (ageParts && ageParts.length === 1) {
      const age = parseInt(ageParts[0]);
      if (!isNaN(age)) {
        minBirthYear = currentYear - age - 2;
        maxBirthYear = currentYear - age + 2;
      }
    } else if (ageParts && ageParts.length >= 2) {
      const minAge = parseInt(ageParts[0]);
      const maxAge = parseInt(ageParts[ageParts.length - 1]);
      if (!isNaN(minAge) && !isNaN(maxAge)) {
        minBirthYear = currentYear - maxAge - 1;
        maxBirthYear = currentYear - minAge + 1;
      }
    } else if (estimatedAgeRange.toLowerCase().includes("teen")) {
      minBirthYear = currentYear - 19;
      maxBirthYear = currentYear - 13;
    } else if (estimatedAgeRange.toLowerCase().includes("child")) {
      minBirthYear = currentYear - 12;
      maxBirthYear = currentYear - 7;
    }
  }

  if (minBirthYear) {
    conditions.push(
      sql`CAST(SUBSTRING(${actors.dateOfBirth}, 1, 4) AS INTEGER) >= ${minBirthYear}`,
    );
  }
  if (maxBirthYear) {
    conditions.push(
      sql`CAST(SUBSTRING(${actors.dateOfBirth}, 1, 4) AS INTEGER) <= ${maxBirthYear}`,
    );
  }
  if (minBirthYear || maxBirthYear) {
    conditions.push(
      sql`${actors.dateOfBirth} IS NOT NULL AND ${actors.dateOfBirth} != ''`,
    );
  }

  if (
    gender &&
    gender.toLowerCase() !== "any" &&
    gender.toLowerCase() !== "all" &&
    gender.toLowerCase() !== "unknown"
  ) {
    conditions.push(sql`lower(${actors.gender}) = ${gender.toLowerCase()}`);
  }

  let query = db.select().from(actors).$dynamic();
  if (conditions.length > 0) {
    query = query.where(and(...conditions));
  }

  const results = await query.orderBy(asc(actors.name)).limit(limit);
  return results;
}


// --- Locations ---
// ... (Location functions remain the same)
export async function getLocations(
  options: {
    search?: string;
    country?: string;
    page?: number;
    pageSize?: number;
  } = {},
): Promise<{
  locations: Location[];
  totalCount: number;
  currentPage: number;
  totalPages: number;
  pageSize: number;
}> {
  const { search = "", country = "", page = 1, pageSize = 10 } = options;
  const offset = (page - 1) * pageSize;

  const conditions = [];
  if (search) {
    conditions.push(
      or(
        ilike(locations.country, `%${search}%`),
        ilike(locations.region, `%${search}%`),
        ilike(locations.incentiveProgram, `%${search}%`),
      ),
    );
  }
  if (country && country.toLowerCase() !== "all") {
    conditions.push(
      sql`lower(${locations.country}) = ${country.toLowerCase()}`,
    );
  }

  let query = db.select().from(locations).$dynamic();
  let countQuery = db
    .select({ count: sql<number>`count(*)` })
    .from(locations)
    .$dynamic();

  if (conditions.length > 0) {
    query = query.where(and(...conditions));
    countQuery = countQuery.where(and(...conditions));
  }

  const countResult = await countQuery;
  const total = Number(countResult[0]?.count || 0);
  const result = await query
    .orderBy(asc(locations.country), asc(locations.region))
    .limit(pageSize)
    .offset(offset);
  return {
    locations: result,
    totalCount: total,
    currentPage: page,
    totalPages: Math.ceil(total / pageSize),
    pageSize,
  };
}
export async function getLocationById(id: number): Promise<Location | null> {
  const result = await db
    .select()
    .from(locations)
    .where(eq(locations.id, id))
    .limit(1);
  return result.length > 0 ? result[0] : null;
}
export async function createLocation(
  data: Omit<Location, "id" | "createdAt" | "updatedAt">,
): Promise<Location> {
  try {
    const validatedData = insertLocationSchema.parse({ ...data });
    const result = await db.insert(locations).values(validatedData).returning();
    return result[0];
  } catch (e) {
    if (e instanceof ZodError) {
      throw new Error(
        `Validation error: ${e.errors.map((err: any) => `${err.path.join(".")}: ${err.message}`).join(", ")}`,
      );
    }
    throw e;
  }
}
export async function updateLocation(
  id: number,
  data: Partial<Omit<Location, "id" | "createdAt">>,
): Promise<Location | null> {
  try {
    const partialSchema = insertLocationSchema
      .partial()
      .omit({ id: true, createdAt: true, updatedAt: true });
    const validatedUpdateData = partialSchema.parse(data);
    const result = await db
      .update(locations)
      .set({ ...validatedUpdateData, updatedAt: new Date() })
      .where(eq(locations.id, id))
      .returning();
    return result.length > 0 ? result[0] : null;
  } catch (e) {
    if (e instanceof ZodError) {
      throw new Error(
        `Validation error: ${e.errors.map((err: any) => `${err.path.join(".")}: ${err.message}`).join(", ")}`,
      );
    }
    throw e;
  }
}
export async function deleteLocation(id: number): Promise<boolean> {
  const result = await db
    .delete(locations)
    .where(eq(locations.id, id))
    .returning();
  return result.length > 0;
}
export async function getAllLocationsForAISuggestion(): Promise<Location[]> {
  return await db
    .select()
    .from(locations)
    .orderBy(asc(locations.country), asc(locations.region));
}

// --- VFX Scene Details Functions ---
export async function createOrUpdateVfxSceneDetail(
  sceneId: number,
  qualityTier: VfxQualityTierType,
  data: {
    vfxElementsSummaryForTier: string;
    estimatedVfxCost: number;
    costEstimationNotes: string;
    conceptualImageUrl?: string | null;
    conceptualVideoUrl?: string | null;
  }
): Promise<VfxSceneDetail> {
  try {
    // Check if a record already exists for this scene and tier
    const existing = await db
      .select()
      .from(vfxSceneDetails)
      .where(
        and(
          eq(vfxSceneDetails.sceneId, sceneId),
          eq(vfxSceneDetails.qualityTier, qualityTier)
        )
      )
      .limit(1);

    const vfxData = {
      sceneId,
      qualityTier,
      vfxElementsSummaryForTier: data.vfxElementsSummaryForTier,
      estimatedVfxCost: data.estimatedVfxCost,
      costEstimationNotes: data.costEstimationNotes,
      conceptualImageUrl: data.conceptualImageUrl || null,
      conceptualVideoUrl: data.conceptualVideoUrl || null,
    };

    if (existing.length > 0) {
      // Update existing record
      const [updated] = await db
        .update(vfxSceneDetails)
        .set({
          vfxElementsSummaryForTier: vfxData.vfxElementsSummaryForTier,
          estimatedVfxCost: vfxData.estimatedVfxCost,
          costEstimationNotes: vfxData.costEstimationNotes,
          conceptualImageUrl: vfxData.conceptualImageUrl,
          conceptualVideoUrl: vfxData.conceptualVideoUrl,
        })
        .where(eq(vfxSceneDetails.id, existing[0].id))
        .returning();
      return updated;
    } else {
      // Create new record
      const validated = insertVfxSceneDetailSchema.parse(vfxData);
      const [created] = await db
        .insert(vfxSceneDetails)
        .values(validated)
        .returning();
      return created;
    }
  } catch (e) {
    if (e instanceof ZodError) {
      throw new Error(
        `VFX scene detail validation failed: ${e.errors
          .map((err) => `${err.path.join(".")}: ${err.message}`)
          .join(", ")}`
      );
    }
    throw e;
  }
}

export async function getVfxSceneDetailsBySceneId(sceneId: number): Promise<VfxSceneDetail[]> {
  return await db
    .select()
    .from(vfxSceneDetails)
    .where(eq(vfxSceneDetails.sceneId, sceneId))
    .orderBy(asc(vfxSceneDetails.qualityTier));
}


================================================
FILE: server/types.ts
================================================
/**
 * Shared types for the server-side application
 */

export interface ExtractedCharacter {
  name: string;
  estimatedAgeRange?: string;
  gender?: string;
  roleType?: string;
  recommendedBudgetTier?: string;
  description?: string;
}

export interface CharacterSummary {
  name: string;
  description: string;
  keyTraits: string[];
  importanceLevel: number; // 1-10 scale
}

export interface GenrePrediction {
  primaryGenre: string;
  secondaryGenres: string[];
  confidence: number;
}


================================================
FILE: server/vite.ts
================================================
import express, { type Express } from "express";
import fs from "fs";
import path from "path";
import { createServer as createViteServer, createLogger } from "vite";
import { type Server } from "http";
import viteConfig from "../vite.config";
import { nanoid } from "nanoid";

const viteLogger = createLogger();

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

export async function setupVite(app: Express, server: Server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions,
    appType: "custom",
  });

  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html",
      );

      // always reload the index.html file from disk incase it changes
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`,
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}

export function serveStatic(app: Express) {
  const distPath = path.resolve(import.meta.dirname, "public");

  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    );
  }

  app.use(express.static(distPath));

  // fall through to index.html if the file doesn't exist
  app.use("*", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}



================================================
FILE: server/routes/character-casting-routes.ts
================================================
import { Express, Request, Response, NextFunction } from 'express';
import * as storage from '../storage';
import { Actor as DbActor } from '@shared/schema';
import { 
  extractCharacters,
  predictGenre,
  getCharacterDetails,
  findActorsForCharacter,
  clearCharacterSummaryCache
} from '../services/ai-agents/character-casting-pipeline';
import { filterActorsFromDatabase } from '../services/ai-agents/db-filter-service';
import { ExtractedCharacter } from '../services/ai-agents/shared-types';

// Interface for actor suggestions returned to the client
interface ClientActorSuggestion extends DbActor {
  matchReason: string;
  confidenceScore?: number;
  controversyLevel?: string;
}

export function registerCharacterCastingRoutes(app: Express, apiPrefix: string): void {
  // Get all characters from a script
  app.get(
    `${apiPrefix}/scripts/:scriptId/characters`,
    async (req: Request, res: Response, next: NextFunction) => {
      const scriptIdParam = req.params.scriptId;
      const logPrefix = `[Characters Route for Script ID:${scriptIdParam}]`;
      
      try {
        const scriptId = parseInt(scriptIdParam);
        if (isNaN(scriptId)) {
          return res.status(400).json({ message: "Valid Script ID is required" });
        }
        
        const script = await storage.getScriptById(scriptId);
        if (!script || !script.content) {
          return res.status(404).json({
            message: "Script not found or has no content",
          });
        }
        
        // Extract all characters from the script using the extraction agent
        console.log(`${logPrefix} Extracting characters from script content`);
        const characters: ExtractedCharacter[] = await extractCharacters(script.content);
        
        // Start background prefetch of genre prediction
        try {
          if (characters.length > 0) {
            console.log(`${logPrefix} Starting background genre prediction`);
            // Don't await - let this run in the background
            predictGenre(script.content).catch(error => {
              console.error(`${logPrefix} Background genre prediction error:`, error);
            });
          }
        } catch (prefetchError) {
          // Log but don't fail the request if prefetching fails
          console.error(`${logPrefix} Genre prediction setup error:`, prefetchError);
        }
        
        // Return the extracted characters to the client
        return res.json(characters);
      } catch (error) {
        console.error(`${logPrefix} Error extracting characters:`, error);
        next(error);
      }
    }
  );
  
  // Predict genre for a script
  app.get(
    `${apiPrefix}/scripts/:scriptId/predict-genre`,
    async (req: Request, res: Response, next: NextFunction) => {
      const scriptIdParam = req.params.scriptId;
      const logPrefix = `[Genre Prediction for Script ID:${scriptIdParam}]`;
      
      try {
        const scriptId = parseInt(scriptIdParam);
        if (isNaN(scriptId)) {
          return res.status(400).json({ message: "Valid Script ID is required" });
        }
        
        const script = await storage.getScriptById(scriptId);
        if (!script || !script.content) {
          return res.status(404).json({
            message: "Script not found or has no content",
          });
        }
        
        // Predict genre using the genre agent
        console.log(`${logPrefix} Predicting genre for script`);
        const genrePrediction = await predictGenre(script.content);
        
        if (!genrePrediction) {
          return res.status(404).json({
            message: "Could not predict genre for the script",
          });
        }
        
        return res.json(genrePrediction);
      } catch (error) {
        console.error(`${logPrefix} Error predicting genre:`, error);
        next(error);
      }
    }
  );
  
  // Get character details (pre-fill search criteria)
  app.get(
    `${apiPrefix}/scripts/:scriptId/characters/:characterName/details`,
    async (req: Request, res: Response, next: NextFunction) => {
      const { scriptId: scriptIdParam, characterName } = req.params;
      const logPrefix = `[Character Details for "${characterName}" in Script ID:${scriptIdParam}]`;
      
      try {
        const scriptId = parseInt(scriptIdParam);
        if (isNaN(scriptId)) {
          return res.status(400).json({ message: "Valid Script ID is required" });
        }
        
        if (!characterName) {
          return res.status(400).json({ message: "Character name is required" });
        }
        
        const script = await storage.getScriptById(scriptId);
        if (!script || !script.content) {
          return res.status(404).json({
            message: "Script not found or has no content",
          });
        }
        
        // Get character details using the description agent
        console.log(`${logPrefix} Getting details for character`);
        const characterDetails = await getCharacterDetails(script.content, characterName);
        
        if (!characterDetails) {
          return res.status(404).json({
            message: "Could not get details for the character",
          });
        }
        
        return res.json(characterDetails);
      } catch (error) {
        console.error(`${logPrefix} Error getting character details:`, error);
        next(error);
      }
    }
  );
  
  // Get actor suggestions for a character
  app.get(
    `${apiPrefix}/characters/:characterName/suggest-actors`,
    async (req: Request, res: Response, next: NextFunction) => {
      const characterName = req.params.characterName;
      const {
        scriptId: queryScriptId,
        filmGenre: filmGenreFromUI,
        roleType: roleTypeFromUI,
        budgetTier: budgetTierFromUI,
        gender: genderFilterFromUI,
      } = req.query as {
        scriptId?: string;
        filmGenre?: string;
        roleType?: string;
        budgetTier?: string;
        gender?: string;
      };
      
      const logPrefix = `[Actor Suggestion for "${characterName}" in Script ${queryScriptId}]`;
      
      try {
        if (!characterName) {
          return res.status(400).json({ message: "Character name required" });
        }
        
        if (!queryScriptId) {
          return res.status(400).json({
            message: "Script ID query parameter is required",
          });
        }
        
        const scriptId = parseInt(queryScriptId);
        if (isNaN(scriptId)) {
          return res.status(400).json({ message: "Valid Script ID is required" });
        }
        
        // Get the script content
        const script = await storage.getScriptById(scriptId);
        if (!script || !script.content) {
          return res.status(404).json({
            message: "Script not found or has no content",
          });
        }
        
        // Extract characters from script to get the character details
        const characters = await extractCharacters(script.content);
        const characterDetails = characters.find(c => c.name === characterName.toUpperCase());
        
        if (!characterDetails) {
          return res.status(404).json({
            message: `Character "${characterName}" not found in script`,
          });
        }
        
        // Filter actors from database based on search criteria
        const filteredActors = await filterActorsFromDatabase({
          estimatedAgeRange: characterDetails.estimatedAgeRange,
          gender: genderFilterFromUI,
          roleType: roleTypeFromUI,
          budgetTier: budgetTierFromUI,
          limit: 100
        });
        
        if (filteredActors.length === 0) {
          console.log(`${logPrefix} No actors found after database filtering`);
          return res.json([]);
        }
        
        // Use selection agent to rank actors for this character
        const aiSuggestions = await findActorsForCharacter(
          script.content,
          characterName,
          filteredActors,
          {
            filmGenre: filmGenreFromUI,
            roleType: roleTypeFromUI,
            budgetTier: budgetTierFromUI,
            gender: genderFilterFromUI
          }
        );
        
        if (aiSuggestions.length === 0) {
          console.log(`${logPrefix} No suggestions found for character`);
          return res.json([]);
        }
        
        // Transform AI suggestions to client format with actor details
        const finalSuggestions: ClientActorSuggestion[] = [];
        
        for (const aiSugg of aiSuggestions) {
          // Look up actor details from database
          const directDbActor = await storage.getActorByName(aiSugg.actorName);
          
          if (directDbActor) {
            finalSuggestions.push({
              ...directDbActor,
              matchReason: aiSugg.matchReason,
              confidenceScore: aiSugg.confidenceScore,
              controversyLevel: aiSugg.controversyLevel,
            });
          } else {
            console.warn(
              `${logPrefix} Actor "${aiSugg.actorName}" not found in DB.`,
            );
          }
        }
        
        console.log(`${logPrefix} Returning ${finalSuggestions.length} suggestions`);
        return res.json(finalSuggestions);
      } catch (error) {
        console.error(`${logPrefix} Error processing request:`, error);
        next(error);
      }
    }
  );
  
  // Prefetch character suggestions for a script
  app.post(
    `${apiPrefix}/scripts/:scriptId/prefetch-character-suggestions`,
    async (req: Request, res: Response, next: NextFunction) => {
      const scriptIdParam = req.params.scriptId;
      const logPrefix = `[Prefetch for Script ID:${scriptIdParam}]`;
      
      try {
        const scriptId = parseInt(scriptIdParam);
        if (isNaN(scriptId)) {
          return res.status(400).json({ message: "Valid Script ID is required" });
        }
        
        // Start the prefetch process in the background
        console.log(`${logPrefix} Starting background prefetch`);
        
        // Just return success response immediately
        // The actual prefetch will happen asynchronously
        res.json({ message: "Prefetch initiated" });
        
        // Now do the actual work asynchronously (don't await)
        (async () => {
          try {
            const script = await storage.getScriptById(scriptId);
            if (!script?.content) {
              console.error(`${logPrefix} Script not found or has no content`);
              return;
            }
            
            // Extract characters from script
            const characters = await extractCharacters(script.content);
            
            // Get only a few main characters to prefetch
            const mainCharacters = characters
              .filter(c => c.roleType?.toLowerCase() === 'lead' || c.roleType?.toLowerCase() === 'supporting')
              .slice(0, 5);
            
            console.log(`${logPrefix} Prefetching for ${mainCharacters.length} main characters`);
            
            // Prefetch character details for each main character
            for (const character of mainCharacters) {
              try {
                console.log(`${logPrefix} Prefetching details for "${character.name}"`);
                await getCharacterDetails(script.content, character.name);
              } catch (characterError) {
                console.error(`${logPrefix} Error prefetching for "${character.name}":`, characterError);
                // Continue with next character
              }
            }
            
            console.log(`${logPrefix} Prefetch completed successfully`);
          } catch (error) {
            console.error(`${logPrefix} Error during background prefetch:`, error);
          }
        })().catch(error => {
          console.error(`${logPrefix} Uncaught error in background prefetch:`, error);
        });
      } catch (error) {
        console.error(`${logPrefix} Error setting up prefetch:`, error);
        next(error);
      }
    }
  );
  
  // Clear character cache (for debugging/testing)
  app.post(
    `${apiPrefix}/character-cache/clear`,
    async (req: Request, res: Response, next: NextFunction) => {
      const { characterName } = req.body as { characterName?: string };
      
      try {
        clearCharacterSummaryCache(characterName);
        
        return res.json({
          message: characterName
            ? `Cache cleared for "${characterName}"`
            : "All character caches cleared",
        });
      } catch (error) {
        console.error("Error clearing character cache:", error);
        next(error);
      }
    }
  );
  
  // Batch get actor suggestions for multiple characters
  app.post(
    `${apiPrefix}/characters/batch-suggest-actors`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const { scriptId, characters } = req.body as {
          scriptId: number,
          characters: {
            name: string,
            criteria: {
              filmGenre?: string;
              roleType?: string;
              budgetTier?: string;
              gender?: string;
            }
          }[]
        };
        
        const logPrefix = `[Batch Actor Suggestion for Script ${scriptId}]`;
        
        if (!scriptId) {
          return res.status(400).json({ 
            message: "Script ID is required" 
          });
        }
        
        if (!characters || !Array.isArray(characters) || characters.length === 0) {
          return res.status(400).json({ 
            message: "At least one character is required" 
          });
        }
        
        // Get the script content
        const script = await storage.getScriptById(scriptId);
        if (!script || !script.content) {
          return res.status(404).json({
            message: "Script not found or has no content",
          });
        }
        
        // Process each character
        const response: Record<string, ClientActorSuggestion[]> = {};
        
        for (const char of characters) {
          const { name: characterName, criteria } = char;
          
          if (!characterName) {
            continue;
          }
          
          console.log(`${logPrefix} Processing character "${characterName}"`);
          
          try {
            // Get character details from script
            const allCharacters = await extractCharacters(script.content);
            const characterDetails = allCharacters.find(c => c.name === characterName.toUpperCase());
            
            if (!characterDetails) {
              console.warn(`${logPrefix} Character "${characterName}" not found in script`);
              response[characterName] = [];
              continue;
            }
            
            // Filter actors from database based on search criteria
            const filteredActors = await filterActorsFromDatabase({
              estimatedAgeRange: characterDetails.estimatedAgeRange,
              gender: criteria.gender,
              roleType: criteria.roleType,
              budgetTier: criteria.budgetTier,
              limit: 100
            });
            
            if (filteredActors.length === 0) {
              console.log(`${logPrefix} No actors found after database filtering for "${characterName}"`);
              response[characterName] = [];
              continue;
            }
            
            // Find actors for this character using the selection agent
            const aiSuggestions = await findActorsForCharacter(
              script.content,
              characterName,
              filteredActors,
              {
                filmGenre: criteria.filmGenre,
                roleType: criteria.roleType,
                budgetTier: criteria.budgetTier,
                gender: criteria.gender
              }
            );
            
            if (aiSuggestions.length === 0) {
              console.log(`${logPrefix} No suggestions found for character "${characterName}"`);
              response[characterName] = [];
              continue;
            }
            
            // Transform AI suggestions to client format with actor details
            const characterSuggestions: ClientActorSuggestion[] = [];
            
            for (const aiSugg of aiSuggestions) {
              // Look up actor details from database
              const actorDetails = await storage.getActorByName(aiSugg.actorName);
              
              if (actorDetails) {
                characterSuggestions.push({
                  ...actorDetails,
                  matchReason: aiSugg.matchReason,
                  confidenceScore: aiSugg.confidenceScore,
                  controversyLevel: aiSugg.controversyLevel,
                });
              } else {
                console.warn(
                  `${logPrefix} Actor "${aiSugg.actorName}" not found in DB for character "${characterName}".`
                );
              }
            }
            
            console.log(`${logPrefix} Found ${characterSuggestions.length} suggestions for "${characterName}"`);
            response[characterName] = characterSuggestions;
          } catch (charError) {
            console.error(`${logPrefix} Error processing character "${characterName}":`, charError);
            response[characterName] = [];
          }
        }
        
        console.log(`${logPrefix} Returning batch results for ${Object.keys(response).length} characters`);
        res.json(response);
      } catch (error) {
        console.error('[Batch Character Suggest] Error:', error);
        next(error);
      }
    }
  );
}


================================================
FILE: server/services/ai-suggestion-service.tsx
================================================
// server/services/ai-suggestion-service.tsx
import {
    GoogleGenAI,
    HarmCategory,
    HarmBlockThreshold,
    type GenerateContentRequest,
    type GenerateContentResult,
    type GenerationConfig as SDKGenerationConfig,
    type Content as SDKContent,
    type Tool as SDKTool,
    type SafetySetting as SDKSafetySetting,
    FinishReason,
} from "@google/genai";
import { Actor as DbActor, Location as DbLocation } from "@shared/schema";
import {
    sanitizeForSafetyFilter,
    ExtractedCharacter, // This is the BackendExtractedCharacter
} from "./file-upload-service";

// --- Gemini Client Initialization ---
let genAIClientInstance: GoogleGenAI | null = null;
const MODEL_NAME = "gemini-1.5-flash-8b";

function initializeGenAIClient(): GoogleGenAI {
    if (genAIClientInstance) {
        return genAIClientInstance;
    }
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
        console.error(
            "CRITICAL: GEMINI_API_KEY environment variable is not set for AI Suggestion Service",
        );
        throw new Error("GEMINI_API_KEY environment variable is not set");
    }
    genAIClientInstance = new GoogleGenAI({ apiKey: apiKey });
    return genAIClientInstance;
}

const defaultSafetySettings: SDKSafetySetting[] = [
    {
        category: HarmCategory.HARM_CATEGORY_HARASSMENT,
        threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
        threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
        threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
        threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
    },
];

const defaultTools: SDKTool[] = [{ googleSearch: {} }];

// --- Helper function to retry API calls with exponential backoff ---
async function retryWithBackoff<T>(
    fn: () => Promise<T>,
    maxRetries: number = 3,
    baseDelay: number = 1000
): Promise<T> {
    let lastError: Error | null = null;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
            return await fn();
        } catch (error: any) {
            lastError = error;
            
            // Check if it's a 503 Service Unavailable (model overloaded)
            if (error.message?.includes('503') || error.message?.includes('overloaded')) {
                if (attempt < maxRetries) {
                    const delay = baseDelay * Math.pow(2, attempt); // Exponential backoff
                    console.log(`[Gemini API] Retry attempt ${attempt + 1}/${maxRetries + 1} after ${delay}ms delay due to overload`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    continue;
                }
            }
            
            // For non-503 errors, don't retry
            throw error;
        }
    }
    
    throw lastError;
}

// --- Helper function to extract JSON from a potentially dirty string ---
function extractJsonFromString(str: string): string | null {
    if (!str || typeof str !== "string") return null;
    let cleanedStr = str.trim();
    const markdownMatch = cleanedStr.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
    if (markdownMatch && markdownMatch[1]) {
        cleanedStr = markdownMatch[1].trim();
    }
    const coreJsonMatch = cleanedStr.match(
        /^[^\{\[]*([\{\[][\s\S]*[\}\]])[^\]\}]*$/,
    );
    if (coreJsonMatch && coreJsonMatch[1]) {
        cleanedStr = coreJsonMatch[1];
    } else {
        const firstBrace = cleanedStr.indexOf("{");
        const lastBrace = cleanedStr.lastIndexOf("}");
        if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
            cleanedStr = cleanedStr.substring(firstBrace, lastBrace + 1);
        } else {
            console.warn(
                "[extractJsonFromString] Could not find valid JSON structure markers ({...} or [...]). Original string:",
                str,
            );
            return null;
        }
    }
    if (
        (cleanedStr.startsWith("{") && cleanedStr.endsWith("}")) ||
        (cleanedStr.startsWith("[") && cleanedStr.endsWith("]"))
    ) {
        return cleanedStr;
    }
    console.warn(
        "[extractJsonFromString] Final cleaned string does not appear to be valid JSON. Original:",
        str,
        "Cleaned attempt:",
        cleanedStr,
    );
    return null;
}

// --- Actor Suggestions ---
export type ControversyLevel = "none" | "low" | "medium" | "high";
export interface ActorAISuggestion {
    actorName: string;
    matchReason: string;
    confidenceScore?: number;
    controversyLevel?: ControversyLevel;
}
interface GeminiActorSuggestionResponse {
    suggestedActors: ActorAISuggestion[];
}

function formatActorsForPrompt(actorsToFormat: DbActor[]): string {
    return actorsToFormat
        .map((actor) => {
            const notableRolesSummary =
                (Array.isArray(actor.notableRoles)
                    ? actor.notableRoles.slice(0, 3)
                    : []
                ).join(", ") +
                (actor.notableRoles && actor.notableRoles.length > 3
                    ? "..."
                    : "");
            const genresSummary =
                (Array.isArray(actor.genres)
                    ? actor.genres.slice(0, 3)
                    : []
                ).join(", ") +
                (actor.genres && actor.genres.length > 3 ? "..." : "");
            const typicalRolesSummary =
                (Array.isArray(actor.typicalRoles)
                    ? actor.typicalRoles.slice(0, 2)
                    : []
                ).join(", ") +
                (actor.typicalRoles && actor.typicalRoles.length > 2
                    ? "..."
                    : "");
            const strategicFitSummary =
                sanitizeForSafetyFilter(
                    (actor.bestSuitedRolesStrategic || "").substring(0, 100),
                ) +
                (actor.bestSuitedRolesStrategic &&
                actor.bestSuitedRolesStrategic.length > 100
                    ? "..."
                    : "");

            return `Actor Name: ${actor.name}, Gender: ${actor.gender}, Nationality: ${actor.nationality}, DOB: ${actor.dateOfBirth || "N/A"}, Popularity: ${actor.recentPopularity}, Salary: ${actor.estSalaryRange}, Notable Roles: ${notableRolesSummary}, Genres: ${genresSummary}, Typical Roles: ${typicalRolesSummary}, Strategic Fit: ${strategicFitSummary} ---`;
        })
        .join("\n");
}

export async function suggestActorsForCharacterViaGemini(
    scriptContent: string,
    characterToCast: ExtractedCharacter, // BackendExtractedCharacter
    availableActorsFromDb: DbActor[], // This is the pre-filtered list
    criteria: {
        filmGenre?: string;
        roleType?: string;
        budgetTier?: string;
        gender?: string;
    }, // gender here is finalGenderForAIPrompt
    numberOfSuggestions: number = 3,
): Promise<ActorAISuggestion[]> {
    const characterNameToCast = characterToCast.name;
    const characterEstimatedAge =
        characterToCast.estimatedAgeRange || "Not Specified";
    const characterProfiledGender = characterToCast.gender || "Unknown"; // Gender from script analysis

    // The 'criteria.gender' is the TARGET GENDER for casting, potentially from UI or refined logic
    const targetCastingGender =
        criteria.gender &&
        criteria.gender.toLowerCase() !== "any" &&
        criteria.gender.toLowerCase() !== "all" &&
        criteria.gender.toLowerCase() !== "unknown"
            ? criteria.gender
            : "Any"; // If UI/logic says 'any', AI can use broader artistic fit

    const logPrefix = `[Gemini Actor Suggest for "${characterNameToCast}" (Age: ${characterEstimatedAge}, TargetCastingGender: ${targetCastingGender})]`;

    if (availableActorsFromDb.length === 0) {
        console.warn(`${logPrefix} No actors in the pre-filtered DB list.`);
        return [];
    }

    const formattedActorsString = formatActorsForPrompt(availableActorsFromDb);
    const safeCharacterName = sanitizeForSafetyFilter(characterNameToCast);
    const safeCharacterDescription = sanitizeForSafetyFilter(
        characterToCast.description ||
            `A character named ${characterNameToCast}.`,
    );

    try {
        const aiClient = initializeGenAIClient();
        const generationConfigForRequest: SDKGenerationConfig = {
            responseMimeType: "application/json",
            temperature: 0.2,
            maxOutputTokens: 4096,
        };
        const prompt = `
You are an expert Casting Director AI. Your task is to select the ${numberOfSuggestions} most suitable actors from the PROVIDED_ACTOR_LIST for the given CHARACTER_PROFILE.
The PROVIDED_ACTOR_LIST has ALREADY been pre-filtered by the system for basic age and, if specified by the user, gender compatibility.
Your primary focus should be on artistic fit, role interpretation, and strategic considerations *within this pre-filtered list*.

CHARACTER_PROFILE:
- Name: "${safeCharacterName}"
- Estimated Age Range: "${characterEstimatedAge}"
- Profiled Gender (from script analysis, for context): "${characterProfiledGender}"
- **TARGET_CASTING_GENDER (primary gender to match from list): "${targetCastingGender}"**
- Description/Key Traits: "${safeCharacterDescription}"
- Inferred Role Type (from script analysis): "${characterToCast.roleType || "Not Specified"}"
- Recommended Budget Tier (from script analysis): "${characterToCast.recommendedBudgetTier || "Not Specified"}"

USER_CRITERIA_FOR_FILM (use as tie-breakers or further refinement):
- Film Genre: "${criteria.filmGenre || "Not Specified"}"
- Desired Role Type (UI override): "${criteria.roleType || "Use Profiled Role Type"}"
- Desired Budget Tier (UI override): "${criteria.budgetTier || "Use Profiled Budget Tier"}"

PROVIDED_ACTOR_LIST (Only select from this list. Actors here generally meet age/gender basics):
${formattedActorsString}

INSTRUCTIONS:
1.  **MANDATORY**: Select actors ONLY from the PROVIDED_ACTOR_LIST. Do NOT suggest actors outside this list.
2.  **MANDATORY GENDER MATCH**: If TARGET_CASTING_GENDER is specific (e.g., "Female", "Male"), you MUST select actors whose gender in the PROVIDED_ACTOR_LIST matches it. If TARGET_CASTING_GENDER is "Any", you have more flexibility but should still consider the Profiled Gender for artistic fit.
3.  **AGE ALIGNMENT**: Prioritize actors whose actual age (derived from their DOB in the list) closely matches the character's ESTIMATED_AGE_RANGE.
4.  **ARTISTIC & STRATEGIC FIT**: Evaluate how well the actor's typical roles, strategic fit notes, and perceived persona (from the list) match the CHARACTER_PROFILE and USER_CRITERIA.
5.  For each chosen actor, provide:
    - "actorName": (EXACTLY as it appears in the PROVIDED_ACTOR_LIST).
    - "matchReason": (1-2 concise sentences. Explain the fit, explicitly mentioning age and gender alignment. If TARGET_CASTING_GENDER was "Any" and you picked based on Profiled Gender or artistic choice, state that. If there's a slight age variance within the pre-filtered actors, justify if other factors compensate).
    - "controversyLevel": ("none", "low", "medium", "high" - based on general knowledge or a quick simulated search if needed for actors in the list. Default to "none" if unsure).
    - "confidenceScore": (0.0-1.0, your confidence in this actor being a top choice *from the given list* for this specific role, considering all factors).
6.  Return up to ${numberOfSuggestions} suggestions. If fewer than ${numberOfSuggestions} actors from the list are a strong match (especially for gender), return only those strong matches. It's better to have fewer, highly relevant suggestions than to force poor fits.

OUTPUT FORMAT: Return ONLY a valid JSON object: { "suggestedActors": [ { "actorName": "...", "matchReason": "...", "controversyLevel": "low", "confidenceScore": 0.85 }, ... ] }
Ensure the output is a single, clean JSON object without any surrounding text or markdown.`;

        const contentsForRequest: SDKContent[] = [
            { role: "user", parts: [{ text: prompt }] },
        ];
        const request: GenerateContentRequest = {
            model: MODEL_NAME,
            contents: contentsForRequest,
            tools: defaultTools,
            generationConfig: generationConfigForRequest,
            safetySettings: defaultSafetySettings,
        };

        console.log(
            `${logPrefix} Sending request to Gemini with ${availableActorsFromDb.length} pre-filtered actors. Target Casting Gender for AI: ${targetCastingGender}`,
        );
        const result: GenerateContentResult = await retryWithBackoff(
            () => aiClient.models.generateContent(request),
            3, // max retries
            2000 // base delay in ms
        );

        if (!result) {
            console.error(
                `${logPrefix} Gemini SDK returned a null or undefined result.`,
            );
            throw new Error("Gemini SDK returned a null or undefined result.");
        }

        if (result.promptFeedback?.blockReason) {
            console.error(
                `${logPrefix} Request blocked. Reason: ${result.promptFeedback.blockReason}`,
                result.promptFeedback,
            );
            throw new Error(
                `Request blocked by API: ${result.promptFeedback.blockReason}`,
            );
        }
        if (!result.candidates || result.candidates.length === 0) {
            const safetyRatings = result.candidates?.[0]?.safetyRatings;
            const finishReason = result.candidates?.[0]?.finishReason;
            console.error(
                `${logPrefix} No valid candidates. Finish Reason: ${finishReason}, Safety Ratings:`,
                JSON.stringify(safetyRatings, null, 2),
            );
            throw new Error(
                `No valid candidates or blocked. Finish Reason: ${finishReason}. Safety: ${JSON.stringify(safetyRatings)}`,
            );
        }

        let rawResponseText = "";
        if (result.candidates[0]?.content?.parts) {
            const textPart = result.candidates[0].content.parts.find(
                (part) => "text" in part,
            );
            if (textPart && "text" in textPart) {
                rawResponseText = textPart.text;
            }
        }
        if (
            !rawResponseText &&
            typeof (result.candidates[0].content as any).text === "string"
        ) {
            rawResponseText = (result.candidates[0].content as any).text;
        } // Fallback

        if (!rawResponseText) {
            console.error(
                `${logPrefix} Empty response text from Gemini. Full result object:`,
                JSON.stringify(result, null, 2),
            );
            throw new Error("Empty response text from Gemini.");
        }

        const cleanJsonText = extractJsonFromString(rawResponseText);
        if (!cleanJsonText) {
            console.error(
                `${logPrefix} Could not extract valid JSON from Gemini response. Raw:`,
                rawResponseText,
            );
            return [];
        }

        try {
            const parsedResponse: GeminiActorSuggestionResponse =
                JSON.parse(cleanJsonText);
            if (
                !parsedResponse.suggestedActors ||
                !Array.isArray(parsedResponse.suggestedActors)
            ) {
                console.error(
                    `${logPrefix} Format error after cleaning. Cleaned JSON:`,
                    cleanJsonText,
                    "Original Raw:",
                    rawResponseText,
                );
                return [];
            }
            const validActorNamesFromPreFiltered = new Set(
                availableActorsFromDb.map((a) => a.name.toUpperCase()),
            );
            const validControversyLevels: ControversyLevel[] = [
                "none",
                "low",
                "medium",
                "high",
            ];
            const validatedSuggestions = parsedResponse.suggestedActors
                .filter((sugg) => {
                    if (
                        !sugg.actorName ||
                        typeof sugg.actorName !== "string" ||
                        !sugg.matchReason ||
                        typeof sugg.matchReason !== "string"
                    )
                        return false;
                    if (
                        !validActorNamesFromPreFiltered.has(
                            sugg.actorName.toUpperCase(),
                        )
                    ) {
                        console.warn(
                            `${logPrefix} AI suggested actor "${sugg.actorName}" who was NOT in the pre-filtered list. Discarding.`,
                        );
                        return false;
                    }
                    if (
                        sugg.controversyLevel &&
                        !validControversyLevels.includes(sugg.controversyLevel)
                    ) {
                        sugg.controversyLevel = "none";
                    }
                    if (!sugg.controversyLevel) sugg.controversyLevel = "none";
                    const originalActor = availableActorsFromDb.find(
                        (a) =>
                            a.name.toUpperCase() ===
                            sugg.actorName.toUpperCase(),
                    );
                    if (originalActor) sugg.actorName = originalActor.name;
                    else {
                        return false;
                    }
                    return true;
                })
                .slice(0, numberOfSuggestions);
            console.log(
                `${logPrefix} Received ${validatedSuggestions.length} valid suggestions.`,
            );
            return validatedSuggestions;
        } catch (parseError) {
            console.error(
                `${logPrefix} Parse JSON error after cleaning. Cleaned JSON:`,
                cleanJsonText,
                "Original Raw:",
                rawResponseText,
                "Parse Error:",
                parseError,
            );
            return [];
        }
    } catch (error: any) {
        console.error(`${logPrefix} Error:`, error.message || error);
        if (error.response && typeof error.response !== "undefined") {
            console.error(
                "Error has a 'response' property (likely API error details):",
                JSON.stringify(error.response, null, 2),
            );
        } else {
            console.error("Caught error object. Full error:", error);
        }
        return [];
    }
}

// --- Location Suggestions (Modified for Script-wide analysis) ---
export interface LocationAISuggestion {
    locationId: number;
    matchReason: string;
    estimatedIncentiveNotes: string;
    confidenceScore?: number;
}
interface GeminiLocationSuggestionResponse {
    suggestedLocations: LocationAISuggestion[];
}

function formatLocationsForPrompt(locationsToFormat: DbLocation[]): string {
    return locationsToFormat
        .map((loc) => {
            return `Location ID: ${loc.id} Country: ${loc.country} Region: ${loc.region || "N/A"} Incentive Program: ${loc.incentiveProgram || "N/A"} Incentive Details (Summary): ${sanitizeForSafetyFilter((loc.incentiveDetails || "N/A").substring(0, 200))}... Minimum Spend: ${loc.minimumSpend || "N/A"} Eligible Production Types: ${sanitizeForSafetyFilter(loc.eligibleProductionTypes || "N/A")} Application Deadlines: ${loc.applicationDeadlines || "N/A"} ---`;
        })
        .join("\n");
}

export async function suggestLocationsForScriptViaGemini(
    scriptContent: string,
    scriptIdForLog: number,
    availableLocationsFromDb: DbLocation[],
    projectBudget: number | undefined,
    numberOfSuggestions: number = 5,
): Promise<LocationAISuggestion[]> {
    const logPrefix = `[Gemini Script Location Suggestion for Script ID:${scriptIdForLog} with ${MODEL_NAME}]`;
    if (availableLocationsFromDb.length === 0) {
        console.warn(
            `${logPrefix} No locations provided in the database list.`,
        );
        return [];
    }
    if (!scriptContent || scriptContent.trim().length < 100) {
        console.warn(
            `${logPrefix} Script content is too short for meaningful location suggestions.`,
        );
        return [];
    }

    const formattedLocationsString = formatLocationsForPrompt(
        availableLocationsFromDb,
    );
    const safeScriptContent = sanitizeForSafetyFilter(
        scriptContent.substring(0, 1000000),
    );

    try {
        const aiClient = initializeGenAIClient();
        const generationConfigForRequest: SDKGenerationConfig = {
            responseMimeType: "application/json",
            temperature: 0.5,
            maxOutputTokens: 4096,
        };

        const prompt = `
You are an expert Location Scout AI. Based on the ENTIRE SCRIPT provided, recommend ${numberOfSuggestions} diverse types of real-world filming locations from the AVAILABLE_LOCATIONS_DATABASE that would be suitable for various scenes or the overall production.
INPUTS:
1.  SCRIPT_CONTENT (full script or substantial portion provided in context block).
2.  PROJECT_BUDGET: "${projectBudget !== undefined ? `$${projectBudget.toLocaleString()}` : "Not Specified"}"
3.  AVAILABLE_LOCATIONS_DATABASE (full list provided in context block).
INSTRUCTIONS:
-   Read the SCRIPT_CONTENT to understand the primary settings, themes, moods, and recurring location types required throughout the script.
-   From the AVAILABLE_LOCATIONS_DATABASE, select up to ${numberOfSuggestions} locations that offer good general utility or match key settings described in the script. Aim for a diverse set of location *types* if possible.
-   For each suggested location: "locationId" (EXACT DB_ID_AS_NUMBER), "matchReason" (1-2 sentences explaining fit for script's needs), "estimatedIncentiveNotes" (relevance of incentive to budget/production type, use search if needed), "confidenceScore" (optional 0.0-1.0).
OUTPUT FORMAT: Return ONLY a valid JSON object: { "suggestedLocations": [ { "locationId": DB_ID_AS_NUMBER, "matchReason": "...", "estimatedIncentiveNotes": "...", "confidenceScore": 0.9 }, ... ] }
Ensure "locationId" is a number. Only use IDs from AVAILABLE_LOCATIONS_DATABASE. Ensure the output is a single, clean JSON object without any surrounding text or markdown.
CONTEXT_BLOCK_LOCATIONS_DATABASE: ${formattedLocationsString}
CONTEXT_BLOCK_SCRIPT: ${safeScriptContent}`;

        const contentsForRequest: SDKContent[] = [
            { role: "user", parts: [{ text: prompt }] },
        ];
        const request: GenerateContentRequest = {
            model: MODEL_NAME,
            contents: contentsForRequest,
            tools: defaultTools,
            generationConfig: generationConfigForRequest,
            safetySettings: defaultSafetySettings,
        };

        const result: GenerateContentResult =
            await aiClient.models.generateContent(request);

        if (!result) {
            console.error(
                `${logPrefix} Gemini SDK returned a null or undefined result.`,
            );
            throw new Error("Gemini SDK returned a null or undefined result.");
        }

        if (result.promptFeedback?.blockReason) {
            console.error(
                `${logPrefix} Request blocked. Reason: ${result.promptFeedback.blockReason}`,
                result.promptFeedback,
            );
            throw new Error(
                `Request blocked by API: ${result.promptFeedback.blockReason}`,
            );
        }
        if (!result.candidates || result.candidates.length === 0) {
            const safetyRatings = result.candidates?.[0]?.safetyRatings;
            const finishReason = result.candidates?.[0]?.finishReason;
            console.error(
                `${logPrefix} No valid candidates. Finish Reason: ${finishReason}, Safety Ratings:`,
                JSON.stringify(safetyRatings, null, 2),
            );
            throw new Error(
                `No valid candidates or blocked. Finish Reason: ${finishReason}. Safety: ${JSON.stringify(safetyRatings)}`,
            );
        }

        let rawResponseText = "";
        if (result.candidates[0]?.content?.parts) {
            const textPart = result.candidates[0].content.parts.find(
                (part) => "text" in part,
            );
            if (textPart && "text" in textPart) {
                rawResponseText = textPart.text;
            }
        }
        if (
            !rawResponseText &&
            typeof (result.candidates[0].content as any).text === "string"
        ) {
            rawResponseText = (result.candidates[0].content as any).text;
        }

        if (!rawResponseText) {
            console.error(
                `${logPrefix} Empty response text from Gemini. Full result object:`,
                JSON.stringify(result, null, 2),
            );
            throw new Error("Empty response text from Gemini.");
        }

        const cleanJsonText = extractJsonFromString(rawResponseText);
        if (!cleanJsonText) {
            console.error(
                `${logPrefix} Could not extract valid JSON from Gemini response. Raw:`,
                rawResponseText,
            );
            return [];
        }

        try {
            const parsedResponse: GeminiLocationSuggestionResponse =
                JSON.parse(cleanJsonText);
            if (
                !parsedResponse.suggestedLocations ||
                !Array.isArray(parsedResponse.suggestedLocations)
            ) {
                console.error(
                    `${logPrefix} Format error after cleaning. Cleaned JSON:`,
                    cleanJsonText,
                    "Original Raw:",
                    rawResponseText,
                );
                return [];
            }
            const validLocationIds = new Set(
                availableLocationsFromDb.map((loc) => loc.id),
            );
            const validatedSuggestions = parsedResponse.suggestedLocations
                .filter((sugg) => {
                    const locId =
                        typeof sugg.locationId === "string"
                            ? parseInt(sugg.locationId, 10)
                            : sugg.locationId;
                    if (isNaN(locId) || !validLocationIds.has(locId)) {
                        console.warn(
                            `${logPrefix} Invalid or unknown locationId "${sugg.locationId}".`,
                        );
                        return false;
                    }
                    if (
                        !sugg.matchReason ||
                        typeof sugg.matchReason !== "string" ||
                        !sugg.estimatedIncentiveNotes ||
                        typeof sugg.estimatedIncentiveNotes !== "string"
                    ) {
                        console.warn(
                            `${logPrefix} Suggestion for locId ${locId} missing required fields.`,
                        );
                        return false;
                    }
                    sugg.locationId = locId; // Ensure it's a number
                    return true;
                })
                .slice(0, numberOfSuggestions);
            console.log(
                `${logPrefix} Received ${validatedSuggestions.length} valid location suggestions.`,
            );
            return validatedSuggestions;
        } catch (parseError) {
            console.error(
                `${logPrefix} Parse JSON error after cleaning. Cleaned JSON:`,
                cleanJsonText,
                "Original Raw:",
                rawResponseText,
                "Parse Error:",
                parseError,
            );
            return [];
        }
    } catch (error: any) {
        console.error(
            `${logPrefix} Error in suggestLocationsForScriptViaGemini:`,
            error.message || error,
        );
        if (error.response && typeof error.response !== "undefined") {
            console.error(
                "Error has a 'response' property (likely API error details):",
                JSON.stringify(error.response, null, 2),
            );
        } else {
            console.error("Caught error object. Full error:", error);
        }
        return [];
    }
}




================================================
FILE: server/services/character-suggestion-optimizer.ts
================================================
/**
 * Character Suggestion Optimizer
 * 
 * This service improves performance of the character casting suggestions
 * by adding caching and prefetching capabilities.
 */
import { extractCharactersWithGemini, ExtractedCharacter } from './file-upload-service';
import { suggestActorsForCharacterViaGemini, ActorAISuggestion } from './ai-suggestion-service';
import * as storage from '../storage';

// Cache structure
interface CacheEntry {
  timestamp: number;
  suggestions: ActorAISuggestion[];
}

// In-memory cache for suggestions (cleared on server restart)
const suggestionCache = new Map<string, CacheEntry>();
const CACHE_TTL = 30 * 60 * 1000; // 30 minutes

/**
 * Creates a cache key based on character and search parameters
 */
function createCacheKey(
  scriptId: number,
  characterName: string,
  filmGenre?: string,
  roleType?: string,
  budgetTier?: string,
  gender?: string
): string {
  return `${scriptId}:${characterName}:${filmGenre || ''}:${roleType || ''}:${budgetTier || ''}:${gender || ''}`;
}

/**
 * Retrieves actor suggestions for a character with caching
 */
export async function getActorSuggestionsWithCaching(
  scriptId: number,
  characterName: string,
  filmGenre?: string,
  roleType?: string,
  budgetTier?: string,
  gender?: string
): Promise<ActorAISuggestion[]> {
  const cacheKey = createCacheKey(scriptId, characterName, filmGenre, roleType, budgetTier, gender);
  
  // Check cache first
  const cached = suggestionCache.get(cacheKey);
  if (cached && (Date.now() - cached.timestamp) < CACHE_TTL) {
    console.log(`[Cache Hit] Using cached actor suggestions for "${characterName}"`);
    return cached.suggestions;
  }
  
  console.log(`[Cache Miss] Generating new actor suggestions for "${characterName}"`);
  
  // Get script content
  const script = await storage.getScriptById(scriptId);
  if (!script?.content) {
    throw new Error(`Script with ID ${scriptId} not found or has no content`);
  }
  
  // Extract characters from script
  const characters = await extractCharactersWithGemini(script.content);
  const characterDetails = characters.find(c => c.name === characterName.toUpperCase());
  
  if (!characterDetails) {
    throw new Error(`Character "${characterName}" not found in script`);
  }
  
  // Process gender filter for database query
  let genderForDbFilter: string | undefined = undefined;
  if (gender && gender.toLowerCase() !== "any" && gender.toLowerCase() !== "all" && gender.toLowerCase() !== "unknown") {
    genderForDbFilter = gender;
  }
  
  // Pre-filter actors from database
  const preFilteredActors = await storage.getActorsForAISuggestionByCriteria({
    estimatedAgeRange: characterDetails.estimatedAgeRange,
    gender: genderForDbFilter,
    limit: 100,
  });
  
  if (preFilteredActors.length === 0) {
    return [];
  }
  
  // Generate suggestions using AI
  const suggestions = await suggestActorsForCharacterViaGemini(
    script.content,
    characterDetails,
    preFilteredActors,
    {
      filmGenre: filmGenre || "Any",
      roleType: roleType || "Unknown",
      budgetTier: budgetTier || "Any",
      gender: gender || "Any",
    },
    5
  );
  
  // Cache the results
  suggestionCache.set(cacheKey, {
    timestamp: Date.now(),
    suggestions,
  });
  
  return suggestions;
}

/**
 * Prefetches character suggestions for the most important characters in a script
 * This runs in the background to speed up future user interactions
 */
export async function prefetchMainCharacterSuggestions(scriptId: number): Promise<void> {
  try {
    console.log(`[Prefetch] Starting prefetching for script ${scriptId}`);
    
    // Get script
    const script = await storage.getScriptById(scriptId);
    if (!script?.content) {
      console.error(`[Prefetch] Script with ID ${scriptId} not found or has empty content`);
      return;
    }
    
    // Extract characters
    const characters = await extractCharactersWithGemini(script.content);
    if (characters.length === 0) {
      console.log(`[Prefetch] No characters found in script ${scriptId}`);
      return;
    }
    
    // Take only top 5 characters to avoid too many API calls
    const mainCharacters = characters.slice(0, 5);
    console.log(`[Prefetch] Found ${characters.length} characters, prefetching top ${mainCharacters.length}`);
    
    // Process characters in sequence to avoid overwhelming API
    for (const character of mainCharacters) {
      try {
        // Use default parameters for prefetching
        await getActorSuggestionsWithCaching(
          scriptId,
          character.name,
          undefined, // filmGenre
          "lead",    // roleType
          "medium",  // budgetTier
          "any"      // gender
        );
        console.log(`[Prefetch] Successfully prefetched suggestions for "${character.name}"`);
        
        // Small delay between requests
        await new Promise(resolve => setTimeout(resolve, 500));
      } catch (error) {
        console.error(`[Prefetch] Error prefetching suggestions for "${character.name}":`, error);
      }
    }
    
    console.log(`[Prefetch] Completed prefetching for script ${scriptId}`);
  } catch (error) {
    console.error(`[Prefetch] Error during prefetch process:`, error);
  }
}


================================================
FILE: server/services/file-upload-service.ts
================================================
// server/services/file-upload-service.ts
import {
  GoogleGenerativeAI,
  HarmCategory,
  HarmBlockThreshold,
  GenerationConfig,
  Part,
} from "@google/generative-ai";
import * as fs from "fs";
import path from "path";
import os from "os";
import { v4 as uuidv4 } from "uuid";
import pdfParse from "./pdf-parse-wrapper";
import { ProductCategory, Scene, Product } from "@shared/schema";

// --- Utility to Sanitize Text for Safety Filters ---
export function sanitizeForSafetyFilter(text: string): string {
  if (!text) return "";
  const profanityMap: Record<string, string> = {
    shit: "stuff",
    damn: "darn",
    "fuckin'": "really",
    fucking: "really",
    hell: "heck",
  };
  let sanitized = text;
  for (const word in profanityMap) {
    const regex = new RegExp(`\\b${word}\\b`, "gi");
    sanitized = sanitized.replace(regex, profanityMap[word]);
  }
  sanitized = sanitized.replace(/\u0000/g, "");
  return sanitized;
}

// --- Gemini Client Initialization ---
let genAIInstance: GoogleGenerativeAI | null = null;
let geminiSafetySettings: any[] | null = null;

function initializeGeminiClient() {
  if (genAIInstance && geminiSafetySettings) {
    return { genAI: genAIInstance, safetySettings: geminiSafetySettings };
  }
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) {
    console.error("CRITICAL: GEMINI_API_KEY environment variable is not set");
    throw new Error("GEMINI_API_KEY environment variable is not set");
  }
  genAIInstance = new GoogleGenerativeAI(apiKey);
  geminiSafetySettings = [
    {
      category: HarmCategory.HARM_CATEGORY_HARASSMENT,
      threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
    },
    {
      category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
      threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
    },
    {
      category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
      threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
    },
    {
      category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
      threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
    },
  ];
  return { genAI: genAIInstance, safetySettings: geminiSafetySettings };
}

// --- File Handling Utilities ---
async function bufferToTempFile(
  buffer: Buffer,
  extension: string,
): Promise<string> {
  const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "vadis-"));
  const tempFileName = `${uuidv4()}${extension}`;
  const tempFilePath = path.join(tempDir, tempFileName);
  try {
    await fs.promises.writeFile(tempFilePath, buffer);
    return tempFilePath;
  } catch (err) {
    console.error(`Error writing temp file ${tempFilePath}:`, err);
    try {
      await fs.promises.rm(tempDir, { recursive: true, force: true });
    } catch {}
    throw err;
  }
}

function fileToGenerativePart(filePath: string, mimeType: string): Part {
  try {
    const fileData = fs.readFileSync(filePath);
    return { inlineData: { data: fileData.toString("base64"), mimeType } };
  } catch (error) {
    console.error(`Error reading file ${filePath} for generative part:`, error);
    throw new Error(`Could not read file: ${filePath}`);
  }
}

async function cleanupTempFile(filePath: string) {
  try {
    const dirPath = path.dirname(filePath);
    await fs.promises.unlink(filePath);
    await fs.promises.rmdir(dirPath).catch(() => {});
  } catch (cleanupErr) {
    console.warn(`Failed to clean up temp file ${filePath}:`, cleanupErr);
  }
}

// --- Text Extraction ---
export async function extractTextFromImage(
  imageBuffer: Buffer,
  mimeType: string,
): Promise<string> {
  let imagePath: string | null = null;
  try {
    const extension =
      mimeType.includes("jpeg") || mimeType.includes("jpg") ? ".jpg" : ".png";
    imagePath = await bufferToTempFile(imageBuffer, extension);
    const { genAI, safetySettings } = initializeGeminiClient();
    const model = genAI.getGenerativeModel({
      model: "gemini-1.5-flash",
      safetySettings,
    });
    const imagePart = fileToGenerativePart(imagePath, mimeType);
    const prompt =
      "Extract all text content from this image. If it appears to be a film script or screenplay, format it properly with scene headings, action, and dialogue. If no text is visible, describe the image.";
    const result = await model.generateContent([prompt, imagePart]);
    const response = await result.response;
    console.log("Successfully extracted text from image via Gemini.");
    return response.text();
  } catch (error) {
    console.error("Error extracting text from image with Gemini:", error);
    return `Error: Failed to extract text from image. ${error instanceof Error ? error.message : "Unknown Gemini error"}`;
  } finally {
    if (imagePath) await cleanupTempFile(imagePath);
  }
}

export async function extractTextFromPdf(pdfBuffer: Buffer): Promise<string> {
  try {
    const pdfData = await pdfParse(pdfBuffer);
    const extractedText = pdfData?.text || "";
    if (extractedText.length > 100) {
      console.log("Successfully extracted text from PDF using pdf-parse.");
      return extractedText;
    }
    console.log(
      "pdf-parse extraction insufficient, trying Gemini AI for enhancement...",
    );
    const { genAI, safetySettings } = initializeGeminiClient();
    const model = genAI.getGenerativeModel({
      model: "gemini-1.5-flash",
      safetySettings,
    });
    const prompt = `The following text was extracted from a PDF, but might be incomplete or badly formatted. Please analyze it. If it appears to be a film script or screenplay, reformat it accurately with scene headings (INT./EXT.), action lines, character names (centered), and dialogue. If it's not a script, simply clean up the formatting for readability. Preserve as much original content as possible. Extracted Text: --- ${extractedText.substring(0, 25000)} --- Formatted Output:`;
    const result = await model.generateContent(prompt);
    console.log("Successfully enhanced/extracted PDF text using Gemini AI.");
    return result.response.text();
  } catch (error) {
    console.error("Error processing PDF with pdf-parse and/or Gemini:", error);
    return `Error: Failed to process PDF. ${error instanceof Error ? error.message : "Unknown processing error"}`;
  }
}

// --- Brandable Scene Analysis ---
interface BrandableSceneAnalysis {
  sceneId: number;
  reason: string;
  suggestedProducts: ProductCategory[];
}
export interface AIAnalysisResponseForRoutes {
  brandableScenes: BrandableSceneAnalysis[];
}

export async function identifyBrandableScenesWithGemini(
  scenes: Scene[],
  targetBrandableSceneCount: number = 5,
): Promise<AIAnalysisResponseForRoutes> {
  if (!scenes || scenes.length === 0) {
    console.log("[Gemini Analysis] No scenes provided for analysis.");
    return { brandableScenes: [] };
  }
  console.log(
    `[Gemini Analysis] Analyzing ${scenes.length} scenes for ${targetBrandableSceneCount} brandable candidates...`,
  );
  try {
    const { genAI, safetySettings } = initializeGeminiClient();
    const model = genAI.getGenerativeModel({
      model: "gemini-1.5-flash",
      safetySettings,
      generationConfig: {
        responseMimeType: "application/json",
        temperature: 0.3,
        maxOutputTokens: 4096,
      } as GenerationConfig,
    });
    const scenesTextForPrompt = scenes
      .map((scene) => {
        const safeHeading = sanitizeForSafetyFilter(scene.heading);
        const safeContent = sanitizeForSafetyFilter(
          scene.content.substring(0, 500),
        );
        return `SCENE_ID: ${scene.id}\nHEADING: ${safeHeading}\nCONTENT_SNIPPET: ${safeContent}...\n---`;
      })
      .join("\n");
    const prompt = `You are an expert film production assistant specializing in identifying product placement opportunities. TASK: Analyze the following screenplay scene summaries. Identify exactly ${targetBrandableSceneCount} scenes that offer the MOST promising and natural opportunities for integrating branded products. SELECTION CRITERIA: Visual Clarity, Natural Integration, Context Relevance, Sufficient Detail, Safety. RESPONSE FORMAT: Return ONLY a valid JSON object. The JSON object must have a single key "brandableScenes". The value of "brandableScenes" must be an array of objects. Each object MUST contain keys: "sceneId" (number), "reason" (string), "suggestedProducts" (array of 1-3 categories from: ${Object.values(ProductCategory).join(", ")}). Example: { "sceneId": 123, "reason": "Characters eating breakfast.", "suggestedProducts": ["FOOD", "BEVERAGE"] }. Do NOT include any text before or after the JSON object. SCREENPLAY SCENES: --- ${scenesTextForPrompt} ---`;
    console.log("[Gemini Analysis] Sending request to Gemini...");
    const result = await model.generateContent(prompt);
    const responseText = result.response.text();
    try {
      const parsedResponse: { brandableScenes?: BrandableSceneAnalysis[] } =
        JSON.parse(responseText);
      if (
        !parsedResponse.brandableScenes ||
        !Array.isArray(parsedResponse.brandableScenes)
      ) {
        console.error(
          "[Gemini Analysis] Response not in expected format. Raw:",
          responseText,
        );
        return { brandableScenes: [] };
      }
      const sceneIdMap = new Map(scenes.map((s) => [s.id, true]));
      const validCategories = new Set(Object.values(ProductCategory));
      const validatedBrandableScenes = parsedResponse.brandableScenes
        .filter((bs, index) => {
          const sceneId =
            typeof bs.sceneId === "string"
              ? parseInt(bs.sceneId, 10)
              : bs.sceneId;
          if (isNaN(sceneId) || !sceneIdMap.has(sceneId)) {
            console.warn(
              `[Gemini Val] Invalid sceneId ${bs.sceneId} at ${index}.`,
            );
            return false;
          }
          if (typeof bs.reason !== "string" || bs.reason.length < 10) {
            console.warn(
              `[Gemini Val] Invalid reason for ${sceneId} at ${index}.`,
            );
            return false;
          }
          if (
            !Array.isArray(bs.suggestedProducts) ||
            bs.suggestedProducts.length === 0 ||
            bs.suggestedProducts.length > 3
          ) {
            console.warn(
              `[Gemini Val] Invalid suggestedProducts for ${sceneId} at ${index}.`,
            );
            return false;
          }
          if (
            !bs.suggestedProducts.every((p) =>
              validCategories.has(p as ProductCategory),
            )
          ) {
            console.warn(
              `[Gemini Val] Invalid category in suggestedProducts for ${sceneId} at ${index}.`,
            );
            return false;
          }
          bs.sceneId = sceneId;
          bs.suggestedProducts = bs.suggestedProducts.filter((p) =>
            validCategories.has(p as ProductCategory),
          );
          return true;
        })
        .slice(0, targetBrandableSceneCount);
      console.log(
        `[Gemini Analysis] Identified ${validatedBrandableScenes.length} valid brandable scenes.`,
      );
      return { brandableScenes: validatedBrandableScenes };
    } catch (parseError) {
      console.error(
        "[Gemini Analysis] Failed to parse JSON:",
        parseError,
        "\nRaw:",
        responseText,
      );
      return { brandableScenes: [] };
    }
  } catch (error: any) {
    console.error(
      "[Gemini Analysis] Error analyzing scenes:",
      error.message || error,
    );
    return { brandableScenes: [] };
  }
}

// --- Creative Prompt Generation ---
export async function generateCreativePlacementPrompt(
  scene: Scene,
  product: Product,
): Promise<string> {
  const logPrefix = `[Gemini Creative S:${scene.sceneNumber}/P:${product.id}]`;
  console.log(`${logPrefix} Generating prompt...`);
  const safeHeadingFallback = sanitizeForSafetyFilter(scene.heading);
  const fallbackPrompt = `Cinematic film still, ${safeHeadingFallback}. A ${product.name} is naturally integrated into the scene. Photorealistic, high detail.`;
  try {
    const { genAI, safetySettings } = initializeGeminiClient();
    const model = genAI.getGenerativeModel({
      model: "gemini-1.5-flash",
      safetySettings,
      generationConfig: {
        responseMimeType: "text/plain",
        temperature: 0.7,
        maxOutputTokens: 150,
        stopSequences: ["\n\n", "---"],
      } as GenerationConfig,
    });
    const safeSceneContextSummary = sanitizeForSafetyFilter(
      scene.content?.substring(0, 500) || "No scene content provided.",
    );
    const safeHeading = sanitizeForSafetyFilter(scene.heading);
    const safeReason = sanitizeForSafetyFilter(scene.brandableReason || "N/A");
    const promptToGemini = `Act as a creative director for film product placement. Generate a single, descriptive, visually rich prompt (max 100 tokens) for an AI image generator. The prompt must depict the SCENE CONTEXT (Heading: ${safeHeading}, Summary: ${safeSceneContextSummary}..., Brandable Reason: ${safeReason}) and naturally incorporate the PRODUCT (${product.name}, Category: ${product.category}, Brand: ${product.companyName}). Emphasize photorealism, cinematic lighting, high detail. Ensure natural integration. Adhere to ~100 token limit. IMPORTANT: Maintain a neutral, professional tone. Avoid violence, explicit language, or controversial elements. Focus on visual composition. OUTPUT: Respond ONLY with the generated prompt text. No introductions, explanations, or formatting. Start directly with the prompt.`;
    // console.log(`${logPrefix} Prompting Gemini...`); // Less verbose
    const result = await model.generateContent(promptToGemini);
    let generatedPrompt = result.response
      .text()
      .trim()
      .replace(/^["']|["']$/g, "")
      .replace(/^Prompt:\s*/i, "")
      .split("\n")[0];
    if (!generatedPrompt) {
      console.warn(`${logPrefix} Empty prompt. Using fallback.`);
      return fallbackPrompt;
    }
    const approxTokens = generatedPrompt.split(/\s+/).filter(Boolean).length;
    if (approxTokens > 110) {
      console.warn(
        `${logPrefix} Prompt too long (${approxTokens} words), truncating.`,
      );
      generatedPrompt =
        generatedPrompt.split(/\s+/).slice(0, 100).join(" ") + "...";
    }
    console.log(
      `${logPrefix} Received prompt: ${generatedPrompt.substring(0, 100)}...`,
    );
    return generatedPrompt;
  } catch (error: any) {
    console.error(`${logPrefix} Failed to generate creative prompt:`, error);
    console.warn(`${logPrefix} Using fallback due to error.`);
    return fallbackPrompt;
  }
}

// --- Character Extraction with Gemini (includes age estimation) ---
export interface ExtractedCharacter {
  name: string;
  estimatedAgeRange?: string; // New field for estimated age
}

interface GeminiCharacterResponse {
  characters: ExtractedCharacter[];
}

export async function extractCharactersWithGemini(
  scriptContent: string,
): Promise<ExtractedCharacter[]> {
  if (!scriptContent || scriptContent.trim().length < 50) {
    console.log(
      "[Gemini Characters] Script content is too short or empty. Skipping character extraction.",
    );
    return [];
  }

  const logPrefix = "[Gemini Characters]";
  console.log(
    `${logPrefix} Starting character extraction and age estimation from script (length: ${scriptContent.length}).`,
  );

  try {
    const { genAI, safetySettings } = initializeGeminiClient();
    const model = genAI.getGenerativeModel({
      model: "gemini-1.5-flash",
      safetySettings,
      generationConfig: {
        responseMimeType: "application/json",
        temperature: 0.1,
        maxOutputTokens: 8192,
      } as GenerationConfig,
    });

    const maxScriptCharsForPrompt = 650000;
    const scriptContentForPrompt =
      scriptContent.length > maxScriptCharsForPrompt
        ? scriptContent.substring(0, maxScriptCharsForPrompt) +
          "\n...[TRUNCATED FOR PROMPT]..."
        : scriptContent;

    const prompt = `
    You are an expert script analyst. Your task is to analyze the provided screenplay content and extract all unique speaking character names, along with an estimated age or age range for each character.

    Instructions:
    1.  Carefully read the screenplay. Identify names that are clearly designated as characters (typically ALL CAPS before dialogue or described in action lines).
    2.  For each identified character, estimate their age or an age range (e.g., "25-30", "teenager", "early 40s", "senior", "around 50"). Base this estimation on their dialogue, actions, relationships, and context within the script. If age is explicitly stated, use that. If it's ambiguous, provide a reasonable estimate or state "Adult" or "Unclear".
    3.  The list of characters must be unique. Do not repeat names.
    4.  Exclude common non-character, all-caps elements (V.O., O.S., CONT'D, scene headings, parentheticals, sound effects).
    5.  Focus on names that would appear in a cast list. Character names are typically short (1-3 words).
    6.  Return the result STRICTLY as a single JSON object. This JSON object must have a single key "characters".
    7.  The value of "characters" must be an array of objects. Each object MUST have "name" (string, ALL CAPS) and "estimatedAgeRange" (string).
    8.  If no distinct characters are found, return an empty array for "characters".
    9.  Do NOT include any explanatory text, markdown formatting, or anything else before or after the JSON object.

    Example of desired JSON output:
    {
      "characters": [
        {"name": "JOHN", "estimatedAgeRange": "30-35"},
        {"name": "MARY", "estimatedAgeRange": "late 20s"},
        {"name": "DR. SMITH", "estimatedAgeRange": "around 50"}
      ]
    }

    Screenplay Content to Analyze:
    ---
    ${scriptContentForPrompt}
    ---
    JSON Output:
    `;

    // console.log(`${logPrefix} Sending request to Gemini for character extraction & age estimation...`); // Less verbose
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const responseText = response.text();

    try {
      const parsedResponse: GeminiCharacterResponse = JSON.parse(responseText);

      if (
        !parsedResponse.characters ||
        !Array.isArray(parsedResponse.characters)
      ) {
        console.error(
          `${logPrefix} Gemini response is not in the expected format. Raw text:`,
          responseText,
        );
        return [];
      }

      const extractedCharacters = parsedResponse.characters
        .map((charObj) => ({
          name: (charObj.name || "").toString().trim().toUpperCase(),
          estimatedAgeRange: (charObj.estimatedAgeRange || "Unclear")
            .toString()
            .trim(),
        }))
        .filter(
          (charObj) =>
            charObj.name && charObj.name.length > 1 && charObj.name.length < 50,
        )
        .filter(
          (charObj, index, self) =>
            self.findIndex((c) => c.name === charObj.name) === index,
        );

      console.log(
        `${logPrefix} Successfully extracted ${extractedCharacters.length} unique characters with age estimates.`,
      );
      return extractedCharacters;
    } catch (parseError) {
      console.error(
        `${logPrefix} Failed to parse Gemini JSON response for characters:`,
        parseError,
        "\nRaw Response Text:",
        responseText,
      );
      if (!responseText.trim().startsWith("{")) {
        const lines = responseText.split("\n").map((l) =>
          l
            .trim()
            .toUpperCase()
            .replace(/[^A-Z0-9\s'-]/g, ""),
        );
        const potentialChars = lines.filter(
          (l) =>
            l &&
            l.length > 1 &&
            l.length < 50 &&
            !l.startsWith("SCENE") &&
            !l.startsWith("INT") &&
            !l.startsWith("EXT"),
        );
        if (potentialChars.length > 0) {
          console.warn(
            `${logPrefix} Attempting fallback text parsing for characters (no age).`,
          );
          return potentialChars
            .map((name) => ({ name, estimatedAgeRange: "Unclear" }))
            .filter(
              (charObj, index, self) =>
                self.findIndex((c) => c.name === charObj.name) === index,
            );
        }
      }
      return [];
    }
  } catch (error: any) {
    console.error(
      `${logPrefix} Error extracting characters with Gemini:`,
      error.message || error,
    );
    if (error.response && error.response.data) {
      console.error(
        `${logPrefix} Gemini API error details:`,
        error.response.data,
      );
    }
    return [];
  }
}





================================================
FILE: server/services/financial-analysis-service.ts
================================================
// server/services/financial-analysis-service.ts
import * as storage from "../storage";
import { Script } from "@shared/schema";
import { FinancialBreakdown, FinancialLineItem } from "../types/financials"; // Adjust path if needed

function createLineItem(account: string, description: string, total: number | null = 0): FinancialLineItem {
    return { account, description, total };
}

export async function generateFinancialBreakdown(scriptId: number): Promise<FinancialBreakdown | null> {
    const script = await storage.getScriptById(scriptId);

    if (!script) {
        console.warn(`[FinancialAnalysis] Script with ID ${scriptId} not found.`);
        return null;
    }

    const totalBudgetInput = script.totalBudget ?? 0; // Use 0 if null

    // Initialize with placeholder values, mirroring "THE BEAST" structure
    // For now, all line item totals are 0 or null, except for the main budget.
    // In future tasks, these would be calculated or fetched.
    const breakdown: FinancialBreakdown = {
        projectName: script.title,
        expectedReleaseDate: script.expectedReleaseDate ?? null,
        location: "ATHENS, GREECE", // Placeholder
        prepWeeks: 12, // Placeholder
        shootDays: "30 DAYS (15 ACTION UNIT, 15 LED STAGE)", // Placeholder
        unions: "DGA, WGA, SAG", // Placeholder

        aboveTheLine: {
            storyRights: createLineItem("1100", "STORY & RIGHTS"),
            producer: createLineItem("1300", "PRODUCER"),
            director: createLineItem("1400", "DIRECTOR"),
            castAndStunts: createLineItem("1500", "CAST & STUNTS"),
            fringes: createLineItem("1999", "Total Fringes"),
            total: 0,
        },
        belowTheLineProduction: {
            productionStaff: createLineItem("2000", "PRODUCTION STAFF"),
            extrasStandins: createLineItem("2100", "EXTRAS & STANDINS"),
            setDesign: createLineItem("2200", "SET DESIGN"),
            setConstruction: createLineItem("2300", "SET CONSTRUCTION"),
            setOperations: createLineItem("2500", "SET OPERATIONS"),
            specialEffects: createLineItem("2600", "SPECIAL EFFECTS"),
            setDressing: createLineItem("2700", "SET DRESSING"),
            props: createLineItem("2800", "PROPS"),
            wardrobe: createLineItem("2900", "WARDROBE"),
            ledVirtual: createLineItem("3000", "LED VIRTUAL"),
            makeupHairdressing: createLineItem("3100", "MAKEUP & HAIRDRESSING"),
            setLighting: createLineItem("3200", "SET LIGHTING"),
            camera: createLineItem("3300", "CAMERA"),
            productionSound: createLineItem("3400", "PRODUCTION SOUND"),
            transportation: createLineItem("3500", "TRANSPORTATION"),
            locationExpenses: createLineItem("3600", "LOCATION EXPENSES"),
            pictureVehiclesAnimals: createLineItem("3700", "PICTURE VEHICLES/ANIMALS"),
            productionFilmLab: createLineItem("3800", "PRODUCTION FILM AND LAB"),
            miscProduction: createLineItem("3900", "MISC"),
            healthSafety: createLineItem("3950", "HEALTH AND SAFETY PROTOCOLS"),
            overtime: createLineItem("4100", "OVERTIME"),
            studioEquipmentFacilities: createLineItem("4200", "STUDIO/EQUIPMENT/FACILITIES"),
            tests: createLineItem("4300", "TESTS"),
            btlTravelLiving: createLineItem("4450", "BTL T&L"),
            serviceCompany: createLineItem("4455", "SERVICE COMPANY"),
            fringes: createLineItem("4499", "Total Fringes"),
            total: 0,
        },
        postProduction: {
            filmEditing: createLineItem("4500", "FILM EDITING"),
            music: createLineItem("4600", "MUSIC"),
            sound: createLineItem("4700", "SOUND"),
            filmLabPost: createLineItem("4800", "FILM&LAB"),
            titles: createLineItem("5000", "TITLES"),
            vfx: createLineItem("5100", "VFX"),
            fringes: createLineItem("", "Total Fringes"), // Account missing in template for this fringe
            total: 0,
        },
        otherBelowTheLine: {
            publicity: createLineItem("6500", "PUBLICITY"),
            insurance: createLineItem("6700", "INSURANCE"),
            miscExpenses: createLineItem("6800", "MISC EXPENSES"),
            legalAccounting: createLineItem("7500", "LEGAL & ACCOUNTING"),
            fringes: createLineItem("7699", "Total Fringes"),
            total: 0,
        },
        bondFee: createLineItem("9000", "BOND FEE"),
        contingency: createLineItem("9100", "CONTINGENCY", totalBudgetInput * 0.10), // Example: 10% of total budget input

        // Summary totals - these would normally be calculated from the line items.
        // For now, they are placeholders or simple copies.
        summaryTotalAboveTheLine: 0, // Placeholder
        summaryTotalBelowTheLine: 0,  // Placeholder (sum of BTL Prod + Post + Other BTL)
        summaryTotalAboveAndBelowTheLine: 0, // Placeholder
        summaryGrandTotal: totalBudgetInput, // For now, this is the main figure we have

        // Vadis-specific fields
        totalBudgetInput: totalBudgetInput,
        estimatedBrandSponsorshipValue: 0, // Placeholder
        estimatedLocationIncentiveValue: 0, // Placeholder
        netExternalCapitalRequired: totalBudgetInput, // Initially, all of it
    };

    // Basic summation for section totals (currently summing up mostly zeros)
    breakdown.aboveTheLine.total = Object.values(breakdown.aboveTheLine)
        .filter(item => typeof item === 'object' && item && typeof item.total === 'number' && item.description !== 'Total Fringes') // Exclude fringes from direct sum into ATL total for now if they are separate
        .reduce((sum, item) => sum + (item as FinancialLineItem).total!, 0) + (breakdown.aboveTheLine.fringes.total || 0);

    breakdown.belowTheLineProduction.total = Object.values(breakdown.belowTheLineProduction)
        .filter(item => typeof item === 'object' && item && typeof item.total === 'number' && item.description !== 'Total Fringes')
        .reduce((sum, item) => sum + (item as FinancialLineItem).total!, 0) + (breakdown.belowTheLineProduction.fringes.total || 0);

    breakdown.postProduction.total = Object.values(breakdown.postProduction)
        .filter(item => typeof item === 'object' && item && typeof item.total === 'number' && item.description !== 'Total Fringes')
        .reduce((sum, item) => sum + (item as FinancialLineItem).total!, 0) + (breakdown.postProduction.fringes.total || 0);

    breakdown.otherBelowTheLine.total = Object.values(breakdown.otherBelowTheLine)
        .filter(item => typeof item === 'object' && item && typeof item.total === 'number' && item.description !== 'Total Fringes')
        .reduce((sum, item) => sum + (item as FinancialLineItem).total!, 0) + (breakdown.otherBelowTheLine.fringes.total || 0);

    // Summary Totals from template:
    breakdown.summaryTotalAboveTheLine = breakdown.aboveTheLine.total;
    breakdown.summaryTotalBelowTheLine = (breakdown.belowTheLineProduction.total || 0) + 
                                       (breakdown.postProduction.total || 0) + 
                                       (breakdown.otherBelowTheLine.total || 0);
    breakdown.summaryTotalAboveAndBelowTheLine = (breakdown.summaryTotalAboveTheLine || 0) + 
                                               (breakdown.summaryTotalBelowTheLine || 0);
    // Grand Total based on the template structure should ideally be summaryTotalAboveAndBelowTheLine + contingency + bondFee.
    // However, since we only have totalBudgetInput reliably, we'll adjust.
    // If these were real numbers, this sum would ideally match totalBudgetInput.
    // For now, let's keep grandTotal aligned with what user input, and contingency can be part of that.
    breakdown.summaryGrandTotal = (breakdown.summaryTotalAboveAndBelowTheLine || 0) + 
                                  (breakdown.contingency.total || 0) + 
                                  (breakdown.bondFee.total || 0);

    // If the summaryGrandTotal is 0 because all line items are 0, but we have a totalBudgetInput,
    // set summaryGrandTotal to totalBudgetInput. This makes more sense for the initial placeholder state.
    if (breakdown.summaryGrandTotal === 0 && totalBudgetInput > 0) {
        breakdown.summaryGrandTotal = totalBudgetInput;
        // If contingency wasn't specifically set based on totalBudgetInput, we might set it here if not done above.
        if (!breakdown.contingency.total && totalBudgetInput > 0) {
             breakdown.contingency.total = totalBudgetInput * 0.10; // Recalculate if it was 0
             // Re-update grand total if contingency changed
             breakdown.summaryGrandTotal = (breakdown.summaryTotalAboveAndBelowTheLine || 0) + 
                                           (breakdown.contingency.total || 0) + 
                                           (breakdown.bondFee.total || 0);
             if (breakdown.summaryGrandTotal === (breakdown.contingency.total || 0) + (breakdown.bondFee.total || 0) && totalBudgetInput > 0) {
                breakdown.summaryGrandTotal = totalBudgetInput; // If ATL/BTL are zero, Grand Total is just budget.
             }
        }
    }


    // Vadis Specific Calculations (will be more meaningful later)
    breakdown.netExternalCapitalRequired = 
        (breakdown.summaryGrandTotal || 0) - 
        (breakdown.estimatedBrandSponsorshipValue || 0) - 
        (breakdown.estimatedLocationIncentiveValue || 0);


    return breakdown;
}


================================================
FILE: server/services/pdf-generation-service.ts
================================================
// server/services/pdf-generation-service.ts
import { PDFDocument, StandardFonts, rgb, PDFFont, PageSizes } from 'pdf-lib';
import fontkit from '@pdf-lib/fontkit';

// Screenplay Formatting Constants (inches to PDF points: 1 inch = 72 points)
const INCH = 72;

const PAGE_WIDTH = 8.5 * INCH;
const PAGE_HEIGHT = 11 * INCH;

const MARGIN_TOP = 1 * INCH;
const MARGIN_BOTTOM = 1 * INCH;
const MARGIN_LEFT = 1.5 * INCH; // Standard left margin
const MARGIN_RIGHT = 1 * INCH;  // Standard right margin

const FONT_SIZE = 12;
const LINE_HEIGHT = FONT_SIZE; // Courier is monospaced, leading handled by lines.

// Element-specific X positions (from left margin of page)
const SCENE_HEADING_X_ABS = 1.5 * INCH;
const ACTION_X_ABS = 1.5 * INCH;
const CHARACTER_NAME_X_ABS = 3.7 * INCH; // Roughly
const PARENTHETICAL_X_ABS = 3.1 * INCH;  // Roughly
const DIALOGUE_X_ABS = 2.5 * INCH;       // Roughly
const TRANSITION_X_ABS = 6.0 * INCH;     // Roughly (often right aligned)

// Max widths for elements (from their X position)
const SCENE_HEADING_MAX_WIDTH_CHARS = 60;
const ACTION_MAX_WIDTH_CHARS = 60;
const CHARACTER_NAME_MAX_WIDTH_CHARS = 30; // Usually short
const PARENTHETICAL_MAX_WIDTH_CHARS = 25;
const DIALOGUE_MAX_WIDTH_CHARS = 35;
const TRANSITION_MAX_WIDTH_CHARS = 25;


enum ElementType {
  SCENE_HEADING,
  ACTION,
  CHARACTER_NAME,
  PARENTHETICAL,
  DIALOGUE,
  TRANSITION,
  EMPTY_LINE,
  PAGE_BREAK, // For (MORE) and (CONT'D) type logic if ever implemented
  UNKNOWN
}

function determineElementType(line: string, nextLine?: string): ElementType {
    const trimmedLine = line.trim();
    if (trimmedLine === '') return ElementType.EMPTY_LINE;

    // Scene Headings (INT. LOCATION - TIME or EXT. LOCATION - DAY)
    if (/^(INT\.?\/EXT\.?|EXT\.?\/INT\.?|I\.?\/E\.?|INT\.?|EXT\.)\s*.*?(?:-\s*(DAY|NIGHT|MORNING|EVENING|AFTERNOON|LATER|CONTINUOUS|SAME)\b.*)?$/i.test(trimmedLine) && trimmedLine === trimmedLine.toUpperCase()) {
        return ElementType.SCENE_HEADING;
    }
    // Transitions (FADE IN:, CUT TO:, etc.)
    if (/^(FADE\s+(IN|OUT|TO BLACK)|CUT\s+TO|DISSOLVE\s+TO|MATCH\s+CUT\s+TO|CONTINUED):?$/i.test(trimmedLine) && trimmedLine === trimmedLine.toUpperCase() && trimmedLine.endsWith(':')) {
        return ElementType.TRANSITION;
    }
    // Parentheticals ((whispering), (beat), etc.)
    if (trimmedLine.startsWith('(') && trimmedLine.endsWith(')')) {
        return ElementType.PARENTHETICAL;
    }
    // Character Names (ALL CAPS, usually followed by dialogue or parenthetical)
    // Heuristic: ALL CAPS, less than ~35 chars, not a scene heading, and next line might be dialogue/parenthetical
    if (trimmedLine === trimmedLine.toUpperCase() &&
        trimmedLine.length > 0 &&
        trimmedLine.length < 35 &&
        !trimmedLine.includes(' EXT.') && !trimmedLine.includes(' INT.') &&
        !trimmedLine.endsWith(':') && // Transitions usually end with :
        (nextLine === undefined || nextLine.trim().startsWith('(') || (nextLine.trim() && !/^(INT|EXT)/.test(nextLine.trim().toUpperCase())) )
       ) {
        return ElementType.CHARACTER_NAME;
    }
    // Dialogue (typically follows a Character Name or Parenthetical)
    // This is the hardest to detect without context; for now, if it's not anything else and has some indentation (from AI)
    if (line.startsWith('  ') && !trimmedLine.startsWith('(')) { // Crude check for indentation
        return ElementType.DIALOGUE;
    }
    // Default to Action
    return ElementType.ACTION;
}


async function addTextToPage(
    page: any,
    text: string,
    x: number,
    y: number,
    font: PDFFont,
    size: number,
    maxWidthChars: number,
    lineHeight: number
): Promise<number> {
    let currentY = y;
    const words = text.split(' ');
    let currentLine = '';

    for (const word of words) {
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        if (testLine.length > maxWidthChars && currentLine) {
            page.drawText(currentLine, { x, y: currentY, font, size, color: rgb(0, 0, 0) });
            currentLine = word;
            currentY -= lineHeight;
            if (currentY < MARGIN_BOTTOM) return currentY; // Signal page break needed
        } else {
            currentLine = testLine;
        }
    }
    if (currentLine) {
        page.drawText(currentLine, { x, y: currentY, font, size, color: rgb(0, 0, 0) });
        currentY -= lineHeight;
    }
    return currentY;
}


export async function generateScriptPdf(scriptContent: string, title: string): Promise<Buffer> {
  const pdfDoc = await PDFDocument.create();
  pdfDoc.registerFontkit(fontkit);

  let courierFont: PDFFont;
  try {
    // For a production environment, you would bundle the font file (e.g., CourierPrime-Regular.ttf)
    // For this example, we'll stick to the standard Courier to avoid file path issues.
    // If you have Courier Prime or another screenplay font:
    // const fontBytes = fs.readFileSync(path.resolve(__dirname, './fonts/CourierPrime-Regular.ttf'));
    // courierFont = await pdfDoc.embedFont(fontBytes);
    courierFont = await pdfDoc.embedFont(StandardFonts.Courier);
  } catch (e) {
    console.warn("Failed to embed custom Courier font, using standard Courier.", e);
    courierFont = await pdfDoc.embedFont(StandardFonts.Courier);
  }

  let currentPage = pdfDoc.addPage(PageSizes.Letter);
  let currentY = PAGE_HEIGHT - MARGIN_TOP;
  let pageNumber = 0; // Title page is not numbered

  // --- Title Page ---
  const titleFontSize = 18;
  const authorFontSize = 14;
  const titleWidth = courierFont.widthOfTextAtSize(title.toUpperCase(), titleFontSize);
  currentPage.drawText(title.toUpperCase(), {
    x: PAGE_WIDTH / 2 - titleWidth / 2,
    y: PAGE_HEIGHT / 2 + INCH, // Centered vertically a bit
    font: courierFont,
    size: titleFontSize,
    color: rgb(0, 0, 0),
  });
  const byLine = "by";
  const byLineWidth = courierFont.widthOfTextAtSize(byLine, FONT_SIZE);
  currentPage.drawText(byLine, {
    x: PAGE_WIDTH / 2 - byLineWidth / 2,
    y: PAGE_HEIGHT / 2 + INCH - titleFontSize - (0.5 * INCH),
    font: courierFont,
    size: FONT_SIZE,
    color: rgb(0,0,0)
  });
  const authorName = "Vadis AI Script Writer";
  const authorNameWidth = courierFont.widthOfTextAtSize(authorName, authorFontSize);
   currentPage.drawText(authorName, {
    x: PAGE_WIDTH / 2 - authorNameWidth / 2,
    y: PAGE_HEIGHT / 2 + INCH - titleFontSize - (0.5 * INCH) - authorFontSize - (0.2 * INCH),
    font: courierFont,
    size: authorFontSize,
    color: rgb(0, 0, 0),
  });


  // --- Script Content ---
  const lines = scriptContent.split('\n');
  let firstPageOfScript = true;

  const newPage = () => {
    currentPage = pdfDoc.addPage(PageSizes.Letter);
    currentY = PAGE_HEIGHT - MARGIN_TOP;
    pageNumber++;
    if (!firstPageOfScript && pageNumber > 1) { // Don't number page 1 of script
        const pageNumStr = String(pageNumber -1) + "."; // Page numbers are usually X.
        currentPage.drawText(pageNumStr, {
            x: PAGE_WIDTH - MARGIN_RIGHT - courierFont.widthOfTextAtSize(pageNumStr, FONT_SIZE),
            y: PAGE_HEIGHT - (0.5 * INCH), // Approx 0.5" from top edge
            font: courierFont,
            size: FONT_SIZE,
            color: rgb(0, 0, 0)
        });
    }
    if (firstPageOfScript) firstPageOfScript = false;
  };

  newPage(); // Start with the first page of the script content

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const nextLine = lines[i+1];
    const elementType = determineElementType(line, nextLine);

    if (currentY < MARGIN_BOTTOM + LINE_HEIGHT) {
      newPage();
    }

    let xPos, maxWidthChars;
    let textToDraw = line.trimEnd(); // Keep leading spaces for AI-formatted indentation

    switch (elementType) {
      case ElementType.SCENE_HEADING:
        xPos = SCENE_HEADING_X_ABS;
        maxWidthChars = SCENE_HEADING_MAX_WIDTH_CHARS;
        textToDraw = line.trim().toUpperCase(); // Scene headings always uppercase and trimmed
        currentY -= LINE_HEIGHT; // Extra space before scene heading
        if (currentY < MARGIN_BOTTOM + LINE_HEIGHT) newPage();
        break;
      case ElementType.ACTION:
        xPos = ACTION_X_ABS;
        maxWidthChars = ACTION_MAX_WIDTH_CHARS;
        break;
      case ElementType.CHARACTER_NAME:
        xPos = CHARACTER_NAME_X_ABS;
        maxWidthChars = CHARACTER_NAME_MAX_WIDTH_CHARS;
        textToDraw = line.trim().toUpperCase();
        currentY -= LINE_HEIGHT; // Space before character name
        if (currentY < MARGIN_BOTTOM + LINE_HEIGHT) newPage();
        break;
      case ElementType.PARENTHETICAL:
        xPos = PARENTHETICAL_X_ABS;
        maxWidthChars = PARENTHETICAL_MAX_WIDTH_CHARS;
        break;
      case ElementType.DIALOGUE:
        xPos = DIALOGUE_X_ABS;
        maxWidthChars = DIALOGUE_MAX_WIDTH_CHARS;
        break;
      case ElementType.TRANSITION:
        xPos = TRANSITION_X_ABS;
        maxWidthChars = TRANSITION_MAX_WIDTH_CHARS;
        textToDraw = line.trim().toUpperCase();
        currentY -= LINE_HEIGHT;
        if (currentY < MARGIN_BOTTOM + LINE_HEIGHT) newPage();
        break;
      case ElementType.EMPTY_LINE:
        currentY -= LINE_HEIGHT;
        continue;
      default: // UNKNOWN
        xPos = ACTION_X_ABS;
        maxWidthChars = ACTION_MAX_WIDTH_CHARS;
        break;
    }

    // Handle wrapping (simplified)
    const words = textToDraw.split(' ');
    let currentLineText = '';
    for (const word of words) {
        const testLine = currentLineText + (currentLineText ? ' ' : '') + word;
        if (testLine.length > maxWidthChars && currentLineText) {
            if (currentY < MARGIN_BOTTOM + LINE_HEIGHT) newPage();
            currentPage.drawText(currentLineText, { x: xPos, y: currentY, font: courierFont, size: FONT_SIZE, color: rgb(0, 0, 0) });
            currentY -= LINE_HEIGHT;
            currentLineText = word;
        } else {
            currentLineText = testLine;
        }
    }
    if (currentLineText) {
        if (currentY < MARGIN_BOTTOM + LINE_HEIGHT) newPage();
        currentPage.drawText(currentLineText, { x: xPos, y: currentY, font: courierFont, size: FONT_SIZE, color: rgb(0, 0, 0) });
        currentY -= LINE_HEIGHT;
    }
  }

  const pdfBytes = await pdfDoc.save();
  return Buffer.from(pdfBytes);
}


================================================
FILE: server/services/pdf-parse-wrapper.ts
================================================
import fs from 'fs';
import path from 'path';
import originalPdfParse from 'pdf-parse';

// Create a wrapper around pdf-parse to handle PDF parsing safely
const pdfParse = async (dataBuffer: Buffer, options?: any): Promise<any> => {
  try {
    // Call the original pdf-parse function directly
    return await originalPdfParse(dataBuffer, options);
  } catch (error) {
    console.error('Error in pdf-parse wrapper:', error);
    
    // If we encounter an error, attempt to return a minimal result structure
    // This ensures the application doesn't crash completely on PDF parsing issues
    return {
      text: "Failed to parse PDF content. The file may be corrupted or in an unsupported format.",
      numpages: 1,
      info: {},
      metadata: {},
      version: "1.0",
    };
  }
};

export default pdfParse;


================================================
FILE: server/services/pdf-service.ts
================================================
// Simple interface for scene data
interface ExtractedScene {
  sceneNumber: number;
  heading: string;
  content: string;
}

interface ScriptParsingResult {
  title: string;
  content: string;
  scenes: ExtractedScene[];
}

import { extractTextFromImage, extractTextFromPdf } from './file-upload-service';

// Implementation for extracting text from files (PDF or images)
export async function extractScriptFromPdf(fileBuffer: Buffer, mimeType?: string): Promise<ScriptParsingResult> {
  try {
    // Check if the file is an image or PDF based on mime type
    const isImage = mimeType && mimeType.startsWith('image/');
    
    let extractedText = '';
    
    if (isImage && mimeType) {
      console.log(`Processing uploaded image file with MIME type: ${mimeType}`);
      
      // Use Gemini AI to extract text from image
      extractedText = await extractTextFromImage(fileBuffer, mimeType);
      console.log('Successfully extracted text from image using Gemini AI');
      
      // Log a sample of the extraction
      const truncatedText = extractedText.length > 100 
        ? extractedText.substring(0, 100) + '...' 
        : extractedText;
      console.log('Sample text extracted from image:', truncatedText);
    } else {
      // PDF processing
      console.log('Processing uploaded PDF file with Gemini AI...');
      
      // Use Gemini AI to extract text from PDF
      extractedText = await extractTextFromPdf(fileBuffer);
      console.log('Successfully extracted text from PDF using Gemini AI');
      
      // Log a sample of the extraction
      const truncatedText = extractedText.length > 100 
        ? extractedText.substring(0, 100) + '...' 
        : extractedText;
      console.log('Sample text extracted from PDF:', truncatedText);
    }
    
    // Extract a title from the first few lines
    const lines = extractedText.split('\n').filter((line: string) => line.trim() !== '');
    let title = "Untitled Script";
    
    // Look for a line that might be a title (all caps, early in document)
    for (let i = 0; i < Math.min(10, lines.length); i++) {
      const line: string = lines[i].trim();
      if (line.toUpperCase() === line && line.length > 3 && !line.includes('EXT.') && !line.includes('INT.')) {
        title = line;
        break;
      }
    }
    
    // Extract scenes from the document
    const scenes = extractScenes(extractedText);
    console.log(`Extracted ${scenes.length} scenes from the uploaded file`);
    
    // If no scenes were found, create some basic ones
    const finalScenes = scenes.length > 0 ? scenes : createFallbackScenes(extractedText);
    
    return {
      title,
      content: extractedText,
      scenes: finalScenes
    };
  } catch (error) {
    console.error('Script processing error:', error);
    
    // Create a fallback response if everything fails
    const fallbackText = "Failed to process the uploaded file. The file may be corrupted or in an unsupported format.";
    
    return {
      title: "Untitled Script",
      content: fallbackText,
      scenes: [{
        sceneNumber: 1,
        heading: "UNTITLED SCENE",
        content: fallbackText
      }]
    };
  }
}

// Fallback method to create scenes if regular scene detection fails
function createFallbackScenes(scriptText: string): ExtractedScene[] {
  const scenes: ExtractedScene[] = [];
  const paragraphs = scriptText.split(/\n\s*\n/);
  
  // Create some scenes based on paragraphs or page breaks
  let sceneNumber = 1;
  let currentContent = '';
  
  // Group paragraphs into scenes (roughly 4-6 paragraphs per scene)
  const paragraphsPerScene = 5;
  
  for (let i = 0; i < paragraphs.length; i++) {
    currentContent += paragraphs[i] + '\n\n';
    
    // Create a new scene every few paragraphs
    if ((i + 1) % paragraphsPerScene === 0 || i === paragraphs.length - 1) {
      scenes.push({
        sceneNumber,
        heading: `SCENE ${sceneNumber}`,
        content: currentContent.trim()
      });
      
      sceneNumber++;
      currentContent = '';
    }
  }
  
  return scenes;
}

// function extractScenes(scriptText: string): ExtractedScene[] {
//   // Regular expression to find scene headings (INT./EXT. patterns)
//   // This pattern better captures standard screenplay format scene headings:
//   // They are usually all caps, start with INT/EXT, and sometimes include time of day
//   const sceneHeadingRegex = /\b(INT\.?|EXT\.?|INT\.?\/EXT\.?|I\/E\.?)[\s\.\-]+(.*?)(?:\s*-\s*|\s+)(DAY|NIGHT|MORNING|EVENING|AFTERNOON|DAWN|DUSK|LATER|CONTINUOUS|MOMENTS LATER|SAME TIME)(?:\b|$)/gi;
  
//   // For PDFs that don't have standard formatting, also look for numbered scenes
//   const numberedSceneRegex = /\bSCENE\s+(\d+)[:\.\s]+(.+?)$/gim;
  
//   const scenes: ExtractedScene[] = [];
  
//   // Find potential scene headings
//   let match;
//   let lastIndex = 0;
//   let sceneNumber = 1;
//   let allMatches: {index: number, heading: string}[] = [];
  
//   // Collect all matches from both regexes
//   while ((match = sceneHeadingRegex.exec(scriptText)) !== null) {
//     const fullMatch = match[0].trim();
//     allMatches.push({
//       index: match.index,
//       heading: fullMatch
//     });
//   }
  
//   // Reset regex lastIndex
//   sceneHeadingRegex.lastIndex = 0;
  
//   // Check for numbered scenes as well
//   while ((match = numberedSceneRegex.exec(scriptText)) !== null) {
//     const fullMatch = match[0].trim();
//     allMatches.push({
//       index: match.index,
//       heading: fullMatch
//     });
//   }
  
//   // Sort matches by their position in the text
//   allMatches.sort((a, b) => a.index - b.index);
  
//   // Now process matches in order
//   for (const matchInfo of allMatches) {
//     const heading = matchInfo.heading;
//     const headingIndex = matchInfo.index;
    
//     // If not the first scene, extract content of previous scene
//     if (scenes.length > 0) {
//       const previousScene = scenes[scenes.length - 1];
//       previousScene.content = scriptText
//         .substring(lastIndex, headingIndex)
//         .trim();
//     }
    
//     // Add the new scene
//     scenes.push({
//       sceneNumber,
//       heading,
//       content: '' // Will be filled in the next iteration
//     });
    
//     lastIndex = headingIndex + heading.length;
//     sceneNumber++;
//   }
  
//   // Handle the last scene's content
//   if (scenes.length > 0) {
//     const lastScene = scenes[scenes.length - 1];
//     lastScene.content = scriptText
//       .substring(lastIndex)
//       .trim();
//   }
  
//   // If no scenes were found using the regex, create at least one scene with the entire content
//   if (scenes.length === 0) {
//     scenes.push({
//       sceneNumber: 1,
//       heading: "UNTITLED SCENE",
//       content: scriptText.trim()
//     });
//   }
  
//   return scenes;
// }

type ExtractedScene = {
  sceneNumber: number;
  heading: string;
  content: string;
};

function extractScenes(scriptText: string): ExtractedScene[] {
  const sceneHeadingRegex = /\b(?:\d+\.\s*)?(INT\.?|EXT\.?|I\/E\.?|INT\/EXT\.?)[\s\.\-]+(.*?)(?:\s*[-\s]+\s*)(DAY|NIGHT|EVENING|MORNING|AFTERNOON|DUSK|DAWN|LATER|CONTINUOUS|MOMENTS LATER|SAME TIME)?\b/gi;
  const looseNumberedSceneRegex = /^\s*(\d+)[\.\)]\s+(?!INT\.?|EXT\.?|I\/E\.?|INT\/EXT\.?)([^\n]+)$/gim;

  type MatchInfo = { index: number; heading: string };
  const allMatches: MatchInfo[] = [];
  let match: RegExpExecArray | null;

  const seenIndices = new Set<number>();

  // Match standard and semi-standard scene headings
  while ((match = sceneHeadingRegex.exec(scriptText)) !== null) {
    if (!seenIndices.has(match.index)) {
      allMatches.push({
        index: match.index,
        heading: match[0].trim()
      });
      seenIndices.add(match.index);
    }
  }

  // Match scenes that are only numbered like: "1. SOME SCENE LABEL"
  while ((match = looseNumberedSceneRegex.exec(scriptText)) !== null) {
    const fullMatch = match[0].trim();
    if (!/\b(INT\.?|EXT\.?|I\/E\.?)\b/i.test(fullMatch) && !seenIndices.has(match.index)) {
      allMatches.push({
        index: match.index,
        heading: fullMatch
      });
      seenIndices.add(match.index);
    }
  }

  allMatches.sort((a, b) => a.index - b.index);

  const scenes: ExtractedScene[] = [];
  let sceneNumber = 1;
  let lastIndex = 0;

  for (const matchInfo of allMatches) {
    const headingIndex = matchInfo.index;

    if (scenes.length > 0) {
      scenes[scenes.length - 1].content = scriptText.substring(lastIndex, headingIndex).trim();
    }

    scenes.push({
      sceneNumber,
      heading: matchInfo.heading,
      content: ''
    });

    lastIndex = headingIndex + matchInfo.heading.length;
    sceneNumber++;
  }

  // Add final scene content
  if (scenes.length > 0) {
    scenes[scenes.length - 1].content = scriptText.substring(lastIndex).trim();
  } else {
    scenes.push({
      sceneNumber: 1,
      heading: 'UNTITLED SCENE',
      content: scriptText.trim()
    });
  }

  return scenes;
}



================================================
FILE: server/services/replicate-service.ts
================================================
// server/services/replicate-service.ts
import Replicate from "replicate";
import {
  Scene,
  Product,
  SceneVariation,
  ProductCategory,
} from "@shared/schema";
import * as storage from "../storage";
import { Buffer } from "buffer";

// --- Interfaces ---
interface GenerationRequest {
  scene: Scene;
  product: Product;
  variationNumber: number;
  prompt: string;
}

interface GenerationResult {
  imageUrl: string;
  description: string;
  success: boolean;
}

interface VideoGenerationResult {
  predictionId: string | null;
  error?: string;
  status?: string;
}

interface PredictionStatusResult {
  status:
    | "starting"
    | "processing"
    | "succeeded"
    | "failed"
    | "canceled"
    | "unknown";
  outputUrl?: string | null;
  error?: string | null;
  logs?: string | null;
}

// --- Constants ---
const FALLBACK_IMAGE_URL =
  "https://placehold.co/1024x576/grey/white?text=Image+Gen+Failed";

const REPLICATE_IMAGE_MODEL = "black-forest-labs/flux-dev-lora";
const REPLICATE_IMAGE_VERSION =
  "6cfd3a89f8a165f6055e013abac527519689b74e3a48851a7c374e113e7ce697";

// UPDATED VIDEO MODEL CONSTANTS
const REPLICATE_VIDEO_MODEL = "wavespeedai/wan-2.1-i2v-480p";
const REPLICATE_VIDEO_VERSION =
  "ea681d183d59e636a8514d08c46a6736f26468c0b583609064e750c94157e8e4"; // Example version

const MAX_PROMPT_LENGTH = 950; // Max length for image prompts, video prompts might have different limits

// --- Utilities ---
function isValidHttpUrl(urlString: string): boolean {
  if (!urlString || typeof urlString !== "string") return false;
  try {
    const url = new URL(urlString);
    return url.protocol === "http:" || url.protocol === "https:";
  } catch {
    return false;
  }
}

const getSanitizedImageUrl = (url: string | undefined | null): string => {
  if (!url || typeof url !== "string") return FALLBACK_IMAGE_URL;
  const trimmedUrl = url.trim();
  if (trimmedUrl.startsWith("data:image/")) return trimmedUrl;
  if (isValidHttpUrl(trimmedUrl)) return trimmedUrl;
  console.warn(
    `[Sanitize] URL is not HTTP/HTTPS or Data URI, using fallback: ${trimmedUrl.substring(0, 50)}...`,
  );
  return FALLBACK_IMAGE_URL;
};

function getReplicateClient(): Replicate {
  const apiToken = process.env.REPLICATE_API_TOKEN;
  if (!apiToken) {
    console.error(
      "CRITICAL: REPLICATE_API_TOKEN environment variable is not set.",
    );
    throw new Error("Replicate API token is not configured.");
  }
  return new Replicate({ auth: apiToken });
}

async function safeReplicateCall<T>(
  operation: () => Promise<T>,
  context: string,
): Promise<T> {
  try {
    return await operation();
  } catch (error: any) {
    const replicateErrorDetail =
      error.response?.data?.detail ||
      error.message ||
      "Unknown Replicate error";
    const statusCode = error.response?.status;
    console.error(
      `Replicate API error during [${context}] (Status: ${statusCode || "N/A"}):`,
      replicateErrorDetail,
    );
    throw new Error(`Replicate failed [${context}]: ${replicateErrorDetail}`);
  }
}

// --- Image Generation ---
export async function generateProductPlacement(
  request: GenerationRequest,
): Promise<GenerationResult> {
  const { scene, product, variationNumber, prompt } = request;
  const logPrefix = `[ImgGen S${scene.sceneNumber} V${variationNumber} P:${product.id}]`;
  const description = createPlacementDescription(request);

  if (!prompt || typeof prompt !== "string" || prompt.trim().length < 10) {
    console.error(`${logPrefix} Invalid or empty prompt received: "${prompt}"`);
    return {
      imageUrl: FALLBACK_IMAGE_URL,
      description: "Error: Invalid generation prompt.",
      success: false,
    };
  }

  const finalPrompt =
    prompt.length > MAX_PROMPT_LENGTH
      ? prompt.substring(0, MAX_PROMPT_LENGTH) + "..."
      : prompt;
  if (prompt.length > MAX_PROMPT_LENGTH) {
    console.warn(
      `${logPrefix} Prompt truncated to ${MAX_PROMPT_LENGTH} characters.`,
    );
  }

  try {
    const replicate = getReplicateClient();
    console.log(
      `${logPrefix} Using Gemini Prompt (len ${finalPrompt.length}): ${finalPrompt.substring(0, 100)}...`,
    );

    const input = {
      prompt: finalPrompt,
      negative_prompt:
        "nsfw, nude, naked, offensive, violence, gore, explicit language, text, words, letters, watermark, signature, blurry, low quality, distorted, deformed, bad anatomy, extra limbs, disfigured, multiple views",
      width: 1024,
      height: 576,
      num_outputs: 1,
      scheduler: "euler_a",
      num_inference_steps: 8,
      guidance_scale: 2.5,
      input_image: product.imageUrl,
    };

    console.log(
      `${logPrefix} Calling Replicate run (${REPLICATE_IMAGE_MODEL}:${REPLICATE_IMAGE_VERSION})...`,
    );

    // Corrected Replicate run call:
    const output: any = await safeReplicateCall(
      () =>
        replicate.run(`${REPLICATE_IMAGE_MODEL}`, {
          input,
        }),
      `Run Image Model Var ${variationNumber}`,
    );

    let imageUrl: string | undefined;
    let failureReason = "Unexpected output format";

    if (
      output &&
      typeof output === "object" &&
      !Array.isArray(output) &&
      output.error
    ) {
      failureReason = String(output.error);
      console.error(
        `${logPrefix} Replicate run returned an error object:`,
        failureReason,
      );
    } else if (Array.isArray(output) && output.length > 0) {
      const firstItem = output[0];
      if (typeof firstItem === "string" && isValidHttpUrl(firstItem)) {
        imageUrl = firstItem;
      } else if (firstItem instanceof ReadableStream) {
        console.log(
          `${logPrefix} Replicate output is a ReadableStream. Reading data...`,
        );
        try {
          const reader = firstItem.getReader();
          const chunks: Uint8Array[] = [];
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            if (value) {
              chunks.push(value);
            }
          }
          const imageBuffer = Buffer.concat(chunks);
          imageUrl = `data:image/png;base64,${imageBuffer.toString("base64")}`;
          console.log(
            `${logPrefix} Successfully read stream and created base64 data URI.`,
          );
        } catch (streamError: any) {
          console.error(
            `${logPrefix} Error reading Replicate stream:`,
            streamError,
          );
          failureReason = `Error reading output stream: ${streamError.message}`;
          imageUrl = undefined;
        }
      } else if (
        firstItem &&
        typeof firstItem === "object" &&
        firstItem.error
      ) {
        failureReason = String(firstItem.error);
        console.error(
          `${logPrefix} Replicate run returned an array containing an error object:`,
          failureReason,
        );
      } else {
        console.error(
          `${logPrefix} Replicate run returned array with unexpected content type:`,
          typeof firstItem,
        );
      }
    } else {
      console.error(
        `${logPrefix} Replicate run returned unexpected or empty output:`,
        output,
      );
    }

    if (!imageUrl) {
      if (
        failureReason.toLowerCase().includes("safety_checker") ||
        failureReason.toLowerCase().includes("safety filter")
      ) {
        console.warn(`${logPrefix} SAFETY FILTER likely triggered.`);
        return {
          imageUrl: FALLBACK_IMAGE_URL,
          description: "Generation failed due to safety filter.",
          success: false,
        };
      }
      return {
        imageUrl: FALLBACK_IMAGE_URL,
        description: `Generation failed: ${failureReason}`,
        success: false,
      };
    }

    const sanitizedUrl = getSanitizedImageUrl(imageUrl);
    const success = sanitizedUrl !== FALLBACK_IMAGE_URL;
    console.log(
      `${logPrefix} Image generation completed. Success: ${success}. Type: ${imageUrl.startsWith("data:") ? "Data URI" : "URL"}`,
    );

    return { imageUrl: imageUrl, description, success };
  } catch (error: any) {
    console.error(
      `${logPrefix} Overall error during image generation process:`,
      error.message || error,
    );
    return {
      imageUrl: FALLBACK_IMAGE_URL,
      description: `Generation failed: ${error.message}`,
      success: false,
    };
  }
}

// --- Video Generation (UPDATED for wavespeedai/wan-2.1-i2v-480p) ---
export async function generateVideoFromVariation(
  variationId: number,
): Promise<VideoGenerationResult> {
  const logPrefix = `[VidGen Var ${variationId}]`;
  try {
    const replicate = getReplicateClient();
    const variation = await storage.getSceneVariationById(variationId);

    if (!variation) throw new Error(`Variation ${variationId} not found.`);
    if (
      !variation.imageUrl ||
      variation.imageUrl === FALLBACK_IMAGE_URL ||
      (!isValidHttpUrl(variation.imageUrl) &&
        !variation.imageUrl.startsWith("data:image/"))
    ) {
      console.error(
        `${logPrefix} Cannot generate video. Invalid, missing, or fallback start image URL: ${variation.imageUrl}`,
      );
      throw new Error(
        `Cannot generate video for Variation ${variationId} due to invalid or missing source image.`,
      );
    }
    if (!variation.geminiPrompt) {
      console.warn(`${logPrefix} Missing Gemini prompt for variation ${variationId}. Using a generic motion prompt.`);
      // Fallback to a generic motion prompt if geminiPrompt is missing, or decide how to handle.
      // For wan-2.1-i2v-480p, the text prompt is optional but can guide motion.
      // If no specific textual guidance, the model will try to animate based on image content.
    }

    const videoPrompt = variation.geminiPrompt || "subtle cinematic motion"; // Use Gemini prompt or a fallback

    // Input parameters for wavespeedai/wan-2.1-i2v-480p
    const input = {
      image: variation.imageUrl,
      prompt: videoPrompt.substring(0, MAX_PROMPT_LENGTH), // Video model might have different prompt length needs
      // negative_prompt: "low quality, blurry, text, watermark, worst quality, lowres", // Optional
      motion_scale: 1.0,      // Default: 1. Adjust for more/less motion.
      cfg_scale: 7.0,         // Default: 7. Guidance scale.
      num_inference_steps: 20,// Default: 20
      fps: 12,                // Default: 12
      num_frames: 81,         // Default: 24 (results in 2s video at 12fps)
      resolution: "480p",     // Default and matches model name
      seed: Math.floor(Math.random() * 4294967295),
    };

    if (videoPrompt.length > MAX_PROMPT_LENGTH) {
      console.warn(
        `${logPrefix} Video prompt truncated to ${MAX_PROMPT_LENGTH} characters.`,
      );
    }

    console.log(
      `${logPrefix} Calling Replicate create prediction for video (${REPLICATE_VIDEO_MODEL}:${REPLICATE_VIDEO_VERSION})...`,
    );
    console.log(`${logPrefix} Input Image URL for video: ${variation.imageUrl.substring(0,100)}...`)

    const prediction = await safeReplicateCall(
      () =>
        replicate.predictions.create({
          version: REPLICATE_VIDEO_MODEL, // Pass only the version hash here
          input: input,
          // webhook: process.env.REPLICATE_WEBHOOK_URL, // Optional webhook
          // webhook_events_filter: ["completed", "failed"], // Optional
        }),
      `Create WAN-2.1 Video Prediction Var ${variationId}`,
    );

    console.log(
      `${logPrefix} Video prediction started. ID: ${prediction.id}, Status: ${prediction.status}`,
    );

    if (prediction.status === "failed" || prediction.status === "canceled") {
      const errMsg = prediction.error
        ? String(prediction.error)
        : `Prediction immediately ${prediction.status}`;
      console.error(
        `${logPrefix} Video prediction failed or canceled on start: ${errMsg}`,
      );
      return {
        predictionId: prediction.id,
        error: errMsg,
        status: prediction.status,
      };
    }

    return {
      predictionId: prediction.id,
      status: prediction.status as VideoGenerationResult["status"],
    };
  } catch (error: any) {
    console.error(
      `${logPrefix} Error starting video generation process:`,
      error.message || error,
    );
    return {
      predictionId: null,
      error: error.message || "Failed to start video generation",
    };
  }
}


// --- Prediction Status ---
export async function getPredictionStatus(
  predictionId: string,
): Promise<PredictionStatusResult> {
  const logPrefix = `[Poll Status ID ${predictionId}]`;
  try {
    const replicate = getReplicateClient();
    const prediction = await safeReplicateCall(
      () => replicate.predictions.get(predictionId),
      `Get Prediction Status ${predictionId}`,
    );

    let status: PredictionStatusResult["status"] = "unknown";
    if (
      ["starting", "processing", "succeeded", "failed", "canceled"].includes(
        prediction.status,
      )
    ) {
      status = prediction.status as PredictionStatusResult["status"];
    } else {
      console.warn(
        `${logPrefix} Received unexpected status from Replicate: ${prediction.status}`,
      );
    }

    let outputUrl: string | null = null;
    if (prediction.output) {
      if (
        Array.isArray(prediction.output) &&
        prediction.output.length > 0 &&
        typeof prediction.output[0] === "string" &&
        isValidHttpUrl(prediction.output[0])
      ) {
        outputUrl = prediction.output[0];
      } else if (
        typeof prediction.output === "string" &&
        isValidHttpUrl(prediction.output)
      ) {
        outputUrl = prediction.output;
      } else {
        console.warn(
          `${logPrefix} Prediction output is present but not a valid URL string or array containing one. Output:`,
          prediction.output,
        );
      }
    }

    if (status === "succeeded" && !outputUrl) {
      console.warn(
        `${logPrefix} Prediction succeeded but valid output URL could not be extracted. Output received:`,
        prediction.output,
      );
    }

    const errorString = prediction.error ? String(prediction.error) : null;

    return {
      status: status,
      outputUrl: outputUrl,
      error: errorString,
      logs: prediction.logs,
    };
  } catch (error: any) {
    console.error(`${logPrefix} Failed to fetch prediction status overall:`, error);
    return {
      status: "failed",
      error: `Failed to fetch prediction status: ${error.message || "Unknown error"}`,
    };
  }
}

// --- Helper to create basic description ---
function createPlacementDescription(request: GenerationRequest): string {
  const { scene, product, variationNumber } = request;
  return `Variation ${variationNumber}: ${product.name} in scene ${scene.sceneNumber} (${scene.heading}).`;
}

// --- VFX Concept Image Generation ---
interface VFXGenerationRequest {
  vfxDescription: string;
  vfxKeywords: string[];
  qualityTier: string;
  vfxElementsSummary: string;
}

interface VFXGenerationResult {
  imageUrl: string;
  success: boolean;
  error?: string;
}

// --- VFX Image Generation (uses same model as brandable scenes) ---
interface VFXImageGenerationRequest {
  scene: Scene;
  vfxDescription: string;
  vfxKeywords: string[];
  qualityTier: string;
  brandableImageUrl?: string; // If scene is also brandable, use this image
}

interface VFXImageGenerationResult {
  imageUrl: string;
  success: boolean;
  error?: string;
}

export async function generateVFXImage(
  request: VFXImageGenerationRequest
): Promise<VFXImageGenerationResult> {
  const { scene, vfxDescription, vfxKeywords, qualityTier, brandableImageUrl } = request;
  const logPrefix = `[VFX IMG S${scene.sceneNumber} ${qualityTier}]`;
  
  try {
    console.log(`${logPrefix} Starting VFX image generation`);
    
    const replicate = getReplicateClient();
    
    // Build VFX prompt
    let prompt = `Cinematic VFX scene: ${vfxDescription}. VFX elements: ${vfxKeywords.join(', ')}. ${qualityTier} quality visual effects, professional film production, detailed, realistic lighting`;
    
    // If scene is also brandable and has a brand image, include it in the prompt
    if (brandableImageUrl) {
      prompt += `. Incorporate branded elements from reference image`;
      console.log(`${logPrefix} Using brandable scene reference image: ${brandableImageUrl.substring(0, 50)}...`);
    }
    
    const finalPrompt = prompt.length > MAX_PROMPT_LENGTH 
      ? prompt.substring(0, MAX_PROMPT_LENGTH) + "..." 
      : prompt;
    
    console.log(`${logPrefix} Prompt (${finalPrompt.length} chars): ${finalPrompt.substring(0, 100)}...`);
    
    // Use same model and settings as brandable scenes
    const input = {
      prompt: finalPrompt,
      negative_prompt: "nsfw, nude, naked, offensive, violence, gore, explicit language, text, words, letters, watermark, signature, blurry, low quality, distorted, deformed, bad anatomy, extra limbs, disfigured, multiple views",
      width: 1024,
      height: 576,
      num_outputs: 1,
      scheduler: "euler_a",
      num_inference_steps: 8,
      guidance_scale: 2.5,
    };
    
    console.log(`${logPrefix} Calling Replicate with exact same model as brandable scenes...`);
    
    const output: any = await safeReplicateCall(
      () => replicate.run(`${REPLICATE_IMAGE_MODEL}:${REPLICATE_IMAGE_VERSION}`, { input }),
      `VFX Image Generation ${qualityTier}`
    );
    
    if (!output || !Array.isArray(output) || output.length === 0) {
      throw new Error("No image generated from Replicate");
    }
    
    const imageUrl = output[0];
    if (!imageUrl || typeof imageUrl !== "string") {
      throw new Error("Invalid image URL received from Replicate");
    }
    
    const sanitizedUrl = getSanitizedImageUrl(imageUrl);
    const success = sanitizedUrl !== FALLBACK_IMAGE_URL;
    
    console.log(`${logPrefix} VFX image generation completed. Success: ${success}, URL: ${sanitizedUrl.substring(0, 50)}...`);
    
    return {
      imageUrl: sanitizedUrl,
      success,
    };
    
  } catch (error: any) {
    console.error(`${logPrefix} Error generating VFX image:`, error.message || error);
    return {
      imageUrl: FALLBACK_IMAGE_URL,
      success: false,
      error: error.message || "Unknown error",
    };
  }
}

// --- VFX Video Generation (uses VFX image as input, same model as brandable scenes) ---
export async function generateVFXVideoFromImage(
  imageUrl: string,
  scene: Scene,
  qualityTier: string
): Promise<VideoGenerationResult> {
  const logPrefix = `[VFX VIDEO S${scene.sceneNumber} ${qualityTier}]`;
  
  try {
    console.log(`${logPrefix} Starting VFX video generation from image: ${imageUrl.substring(0, 50)}...`);
    
    const replicate = getReplicateClient();
    
    // Use same video model and settings as brandable scenes
    const input = {
      image: imageUrl,
      motion_amount: 6, // Medium motion for VFX scenes
      fps: 24,
      duration: 3,
      aspect_ratio: "16:9"
    };
    
    console.log(`${logPrefix} Using same video model as brandable scenes: ${REPLICATE_VIDEO_MODEL}:${REPLICATE_VIDEO_VERSION}`);
    
    const prediction: any = await safeReplicateCall(
      () => replicate.predictions.create({
        version: REPLICATE_VIDEO_VERSION,
        input: input,
      }),
      `VFX Video Generation ${qualityTier}`
    );
    
    if (!prediction || !prediction.id) {
      throw new Error("Failed to create VFX video prediction");
    }
    
    console.log(`${logPrefix} VFX video generation started. Prediction ID: ${prediction.id}`);
    
    return {
      predictionId: prediction.id,
      status: prediction.status || "starting",
    };
    
  } catch (error: any) {
    console.error(`${logPrefix} Error generating VFX video:`, error.message || error);
    return {
      predictionId: null,
      error: error.message || "Unknown error",
      status: "failed",
    };
  }
}


================================================
FILE: server/services/script-generation-service.ts
================================================
// server/services/script-generation-service.ts
import {
  GoogleGenAI,
  HarmCategory,
  HarmBlockThreshold,
  type GenerateContentRequest,
  type GenerateContentResult,
  type GenerationConfig as SDKGenerationConfig,
  type Content as SDKContent,
  type Tool as SDKTool,
  type SafetySetting as SDKSafetySetting,
  FinishReason,
} from "@google/genai";
import {
  ScriptGenerationFormData,
  FilmRatingEnum,
  FilmRatingType,
} from "@shared/schema";

let genAIClientInstance: GoogleGenAI | null = null;
const MODEL_NAME = "gemini-1.5-flash-8b";

function initializeGenAIClient(): GoogleGenAI {
  if (genAIClientInstance) {
    return genAIClientInstance;
  }
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) {
    console.error(
      "CRITICAL: GEMINI_API_KEY environment variable is not set for Script Generation Service",
    );
    throw new Error("GEMINI_API_KEY environment variable is not set");
  }
  genAIClientInstance = new GoogleGenAI({ apiKey: apiKey });
  return genAIClientInstance;
}

const defaultSafetySettings: SDKSafetySetting[] = [
  {
    category: HarmCategory.HARM_CATEGORY_HARASSMENT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
];

// defaultTools might not be needed for pure text generation but kept for consistency
const defaultTools: SDKTool[] = [];

function getRatingDescription(ratingKey: FilmRatingType): string {
  const ratingValue = FilmRatingEnum[ratingKey as keyof typeof FilmRatingEnum];
  switch (ratingValue) {
    case "G":
      return "General Audiences. All ages admitted. No content that would be offensive to parents for viewing by children.";
    case "PG":
      return "Parental Guidance Suggested. Some material may not be suitable for children. Parents urged to give 'parental guidance'. May contain some material parents might not like for their young children.";
    case "PG-13":
      return "Parents Strongly Cautioned. Some material may be inappropriate for children under 13. Parents are urged to be cautious. Some material may be inappropriate for pre-teenagers.";
    case "R":
      return "Restricted. Children Under 17 Require Accompanying Parent or Adult Guardian. Contains some adult material. Parents are urged to learn more about the film before taking their young children with them.";
    case "NC-17":
      return "Adults Only. No One 17 and Under Admitted. Clearly adult. Children are not admitted.";
    default:
      return "General content guidelines apply.";
  }
}

// Constants for token estimation and generation targets
const APPROX_TOKENS_PER_CHAR = 0.25; // Rough estimate of tokens per character
const MIN_TOTAL_TOKENS = 32000;
const MAX_TOTAL_TOKENS = 48000;
const MAX_ITERATION_TOKENS = 8000; // Maximum tokens per API call
const CONTEXT_LINES = 20; // Number of lines to provide as context from previous generation

export async function generateScriptWithGemini(
  formData: ScriptGenerationFormData,
): Promise<string> {
  const logPrefix = `[Gemini Script Gen - Title: ${formData.projectTitle}]`;
  console.log(`${logPrefix} Starting single-agent looped script generation.`);

  const genAI = initializeGenAIClient();
  let fullScriptText = "";
  let estimatedTokensGenerated = 0;
  let iterationCount = 0;
  const ratingDescription = getRatingDescription(formData.targetedRating);

  while (estimatedTokensGenerated < MIN_TOTAL_TOKENS) {
    iterationCount++;
    console.log(
      `${logPrefix} Starting iteration ${iterationCount}. Current token estimate: ${estimatedTokensGenerated}`,
    );

    let iterationInstructions = "";
    let previousContext = "";

    if (iterationCount === 1) {
      // First iteration - start the screenplay
      iterationInstructions = `This is the beginning of the screenplay. Start with "FADE IN:". Establish the beginning of the story.`;
      previousContext = `Project Details:
- Project Title: "${formData.projectTitle}"
- Logline: "${formData.logline}"
- Description/Synopsis: "${formData.description}"
- Genre: "${formData.genre}"
- Core Concept/Idea: "${formData.concept}"
- Targeted Rating: ${formData.targetedRating} (${ratingDescription})
- Primary Story Location: "${formData.storyLocation}"
- Special Requests (if any): "${formData.specialRequest || "None"}"

Begin with "FADE IN:".`;
    } else {
      // Subsequent iterations - continue from previous content
      const previousLines = fullScriptText
        .split("\n")
        .slice(-CONTEXT_LINES)
        .join("\n");

      previousContext = `PREVIOUS SCRIPT EXCERPT (for continuation):
${previousLines}`;

      // If we're close to the target token count, instruct to wrap up
      if (estimatedTokensGenerated > MIN_TOTAL_TOKENS * 0.8) {
        iterationInstructions = `Continue the screenplay from the previous excerpt. You're approaching the end of the story, so begin wrapping up plot points and moving toward a conclusion.`;
      } else {
        iterationInstructions = `Continue the screenplay from the previous excerpt. Develop the story further, adding new scenes and advancing the plot.`;
      }

      // If we're very close to or exceeding the minimum, instruct to conclude
      if (estimatedTokensGenerated > MIN_TOTAL_TOKENS * 0.95) {
        iterationInstructions = `This should be the final segment of the screenplay. Bring the story to a satisfying conclusion. Ensure all major plot points are resolved. End with "FADE OUT." or "THE END".`;
      }
    }

    const prompt = `
You are an expert Hollywood screenwriter creating an original feature film screenplay.

Overall Project Details:
Project Title: "${formData.projectTitle}"
Logline: "${formData.logline}"
Genre: "${formData.genre}"
Targeted Rating: ${formData.targetedRating} (${ratingDescription})
Primary Story Location: "${formData.storyLocation}"

${previousContext}

Segment-Specific Instructions:
${iterationInstructions}

Formatting Requirements (Strictly Adhere):
- Scene Headings: ALL CAPS (e.g., INT. COFFEE SHOP - DAY).
- Action/Description: Standard sentence case.
- Character Names (before dialogue): ALL CAPS, indented.
- Dialogue: Standard sentence case, indented under the character name.
- Parentheticals: (e.g., (to herself)), indented.
- Transitions: (e.g., CUT TO:), ALL CAPS.
- Do NOT include page numbers.
- Do NOT repeat "FADE IN:" unless this is the first segment.
- Do NOT include any pre-amble, notes, or text other than the screenplay segment itself.

CONTINUE SCRIPT SEGMENT HERE:
`;

    const generationConfigForRequest: SDKGenerationConfig = {
      temperature: 0.7,
      topK: 40,
      topP: 0.95,
      maxOutputTokens: MAX_ITERATION_TOKENS,
      responseMimeType: "text/plain",
    };

    const contentsForRequest: SDKContent[] = [
      { role: "user", parts: [{ text: prompt }] },
    ];
    const request: GenerateContentRequest = {
      model: MODEL_NAME,
      contents: contentsForRequest,
      tools: defaultTools,
      generationConfig: generationConfigForRequest,
      safetySettings: defaultSafetySettings,
    };

    try {
      console.log(
        `${logPrefix} Iteration ${iterationCount}: Sending request to Gemini.`,
      );
      const result: GenerateContentResult =
        await genAI.models.generateContent(request);

      if (result.promptFeedback?.blockReason) {
        throw new Error(
          `Request blocked by API (Iteration ${iterationCount}): ${result.promptFeedback.blockReason}`,
        );
      }

      if (
        !result.candidates ||
        result.candidates.length === 0 ||
        result.candidates[0].finishReason === FinishReason.SAFETY
      ) {
        const safetyRatings = result.candidates?.[0]?.safetyRatings;
        console.error(
          `${logPrefix} Iteration ${iterationCount}: No valid candidates or blocked due to safety. Finish Reason: ${result.candidates?.[0]?.finishReason}. Safety: ${JSON.stringify(safetyRatings)}`,
        );
        throw new Error(
          `No valid candidates or blocked by safety filter (Iteration ${iterationCount}). Finish Reason: ${result.candidates?.[0]?.finishReason}`,
        );
      }

      let segmentText = "";
      if (result.candidates[0]?.content?.parts) {
        const textPart = result.candidates[0].content.parts.find(
          (part) => "text" in part,
        );
        if (textPart && "text" in textPart) {
          segmentText = textPart.text;
        }
      }

      if (
        !segmentText &&
        typeof (result.candidates[0].content as any).text === "string"
      ) {
        segmentText = (result.candidates[0].content as any).text;
      }

      if (!segmentText) {
        throw new Error(
          `Iteration ${iterationCount}: Empty response text from Gemini.`,
        );
      }

      // Add the segment to full script
      fullScriptText += (fullScriptText ? "\n\n" : "") + segmentText.trim();

      // Estimate tokens generated (rough approximation)
      const segmentTokens = Math.ceil(
        segmentText.length * APPROX_TOKENS_PER_CHAR,
      );
      estimatedTokensGenerated += segmentTokens;

      console.log(
        `${logPrefix} Iteration ${iterationCount}: Generated ~${segmentTokens} tokens. Total estimate: ${estimatedTokensGenerated}.`,
      );

      // Check if we've reached our target token count
      if (estimatedTokensGenerated >= MIN_TOTAL_TOKENS) {
        // If we don't have an ending yet and we're in range, let's add one more segment to wrap up
        if (
          !fullScriptText.includes("FADE OUT") &&
          !fullScriptText.includes("THE END") &&
          estimatedTokensGenerated < MAX_TOTAL_TOKENS
        ) {
          console.log(
            `${logPrefix} Reached minimum token count. Adding final segment to wrap up.`,
          );
          continue; // One more iteration with conclusion instructions
        } else {
          console.log(
            `${logPrefix} Script generation complete. Token estimate: ${estimatedTokensGenerated}.`,
          );
          break; // We're done!
        }
      }

      // Add a small delay between iterations to avoid rate limits
      if (estimatedTokensGenerated < MIN_TOTAL_TOKENS) {
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
    } catch (error: any) {
      console.error(
        `${logPrefix} Error during iteration ${iterationCount}:`,
        error.message || error,
      );

      // If we have some content already, we can try to continue despite the error
      if (fullScriptText && estimatedTokensGenerated > MIN_TOTAL_TOKENS * 0.5) {
        console.warn(
          `${logPrefix} Error occurred, but we have generated ${estimatedTokensGenerated} tokens. Attempting to continue.`,
        );
        // Add a note about the error (will be visible in the output)
        fullScriptText += `\n\n[AI_NOTE: Generation encountered an issue here. The story may be disjointed.]\n\n`;
        continue;
      } else {
        // Not enough content to salvage, rethrow the error
        throw new Error(
          `Failed during iteration ${iterationCount}: ${error.message}`,
        );
      }
    }
  }

  // Final validation check
  if (
    fullScriptText.trim().length <
    MIN_TOTAL_TOKENS * APPROX_TOKENS_PER_CHAR * 0.5
  ) {
    console.warn(
      `${logPrefix} Final generated script is very short. Length: ${fullScriptText.length}. Target tokens: ${MIN_TOTAL_TOKENS}`,
    );
    throw new Error(
      "AI failed to generate a substantial script. The combined output was too short.",
    );
  }

  // Ensure we have a proper ending
  if (
    !fullScriptText.includes("FADE OUT") &&
    !fullScriptText.includes("THE END")
  ) {
    fullScriptText += "\n\nFADE OUT.\n\nTHE END";
  }

  console.log(
    `${logPrefix} Successfully generated complete script in ${iterationCount} iterations. Total script length: ${fullScriptText.length} chars, ~${estimatedTokensGenerated} tokens.`,
  );
  return fullScriptText.trim();
}



================================================
FILE: server/services/vfx-analysis-service.ts
================================================
// server/services/vfx-analysis-service.ts
import { GoogleGenerativeAI, GenerateContentRequest, GenerateContentResult } from "@google/generative-ai";
import type { Scene } from "@shared/schema";
import { updateScene } from "../storage";

// Initialize Gemini AI client
function initializeGenAIClient(): GoogleGenerativeAI {
  const apiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_API_KEY;
  if (!apiKey) {
    throw new Error("GEMINI_API_KEY or GOOGLE_API_KEY environment variable is required");
  }
  return new GoogleGenerativeAI(apiKey);
}

// Extract and clean JSON from AI response string
function extractJsonFromString(str: string): string | null {
  try {
    // Remove markdown code blocks and extra formatting
    let cleanStr = str.replace(/```json\s*/g, '').replace(/```\s*/g, '');
    
    // Look for JSON array pattern
    const jsonMatch = cleanStr.match(/\[[\s\S]*\]/);
    if (jsonMatch) {
      let jsonStr = jsonMatch[0];
      
      // Fix various array formatting issues in vfxKeywords
      jsonStr = jsonStr.replace(/"vfxKeywords":\s*"?\[([^\]]*)\]"?/g, (match, content) => {
        try {
          // Extract individual items from the array content
          const items = [];
          let current = '';
          let inQuotes = false;
          let escapeNext = false;
          
          for (let i = 0; i < content.length; i++) {
            const char = content[i];
            
            if (escapeNext) {
              current += char;
              escapeNext = false;
              continue;
            }
            
            if (char === '\\') {
              escapeNext = true;
              continue;
            }
            
            if (char === '"') {
              inQuotes = !inQuotes;
              continue;
            }
            
            if (char === ',' && !inQuotes) {
              if (current.trim()) {
                items.push(current.trim());
              }
              current = '';
              continue;
            }
            
            current += char;
          }
          
          // Add the last item
          if (current.trim()) {
            items.push(current.trim());
          }
          
          // Clean and quote the items
          const cleanItems = items.map(item => {
            const cleaned = item.replace(/^["']+|["']+$/g, '').trim();
            return `"${cleaned}"`;
          });
          
          return `"vfxKeywords": [${cleanItems.join(', ')}]`;
        } catch (error) {
          // Fallback to empty array if parsing fails
          return `"vfxKeywords": []`;
        }
      });
      
      // Clean up common JSON formatting issues
      jsonStr = jsonStr
        .replace(/,\s*}/g, '}')  // Remove trailing commas before }
        .replace(/,\s*]/g, ']')  // Remove trailing commas before ]
        .replace(/([{,]\s*)(\w+):/g, '$1"$2":')  // Quote unquoted keys
        .replace(/:\s*([^"\d\[\{][^,\]\}]*)/g, (match, value) => {
          // Quote unquoted string values
          const trimmed = value.trim();
          if (trimmed !== 'true' && trimmed !== 'false' && trimmed !== 'null') {
            return `: "${trimmed.replace(/"/g, '\\"')}"`;
          }
          return match;
        });
      
      return jsonStr;
    }
    
    // Try to find JSON starting with array bracket
    const startIndex = cleanStr.indexOf('[');
    const endIndex = cleanStr.lastIndexOf(']');
    
    if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
      return cleanStr.substring(startIndex, endIndex + 1);
    }
    
    return null;
  } catch (error) {
    console.error("Error extracting JSON from string:", error);
    return null;
  }
}

// Interface for AI response
interface VfxSceneAnalysis {
  sceneId: number;
  sceneNumber: number;
  isVfxScene: boolean;
  vfxDescription?: string;
  vfxKeywords?: string[];
}

interface GeminiVfxAnalysisResponse {
  scenes: VfxSceneAnalysis[];
}

// Format scenes for the AI prompt
function formatScenesForPrompt(scenes: Scene[]): string {
  return scenes.map(scene => `
Scene ID: ${scene.id}
Scene Number: ${scene.sceneNumber}
Scene Heading: ${scene.heading}
Scene Content: ${scene.content.substring(0, 1000)}${scene.content.length > 1000 ? '...' : ''}
---`).join('\n');
}

/**
 * Analyze script scenes for VFX requirements using Gemini AI
 */
export async function generateAndStoreVFXTierDetailsForScene(scene: Scene): Promise<void> {
  const logPrefix = `[VFX Tier Gen Scene ${scene.id}]`;
  
  try {
    // Check if scene has VFX description
    if (!scene.vfxDescription || scene.vfxDescription.trim() === '') {
      console.warn(`${logPrefix} Scene has no VFX description, skipping tier generation`);
      return;
    }

    console.log(`${logPrefix} Starting VFX tier detail generation`);
    
    const genAI = initializeGenAIClient();
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash-8b" });
    
    // Import VFX quality tiers and services
    const { VfxQualityTierEnum } = await import("@shared/schema");
    const { generateVFXImage } = await import("./replicate-service");
    const { createOrUpdateVfxSceneDetail } = await import("../storage");
    
    const vfxKeywords = scene.vfxKeywords || [];
    const qualityTiers = Object.keys(VfxQualityTierEnum) as Array<keyof typeof VfxQualityTierEnum>;
    
    console.log(`${logPrefix} Processing ${qualityTiers.length} quality tiers: ${qualityTiers.join(', ')}`);
    
    // Process each quality tier
    for (const tier of qualityTiers) {
      try {
        console.log(`${logPrefix} Processing ${tier} tier`);
        
        // Generate tier-specific details with Gemini
        const prompt = `You are a VFX supervisor creating detailed cost estimates and element breakdowns.

TASK: Analyze this VFX scene and provide specific details for ${tier} quality tier production.

SCENE DESCRIPTION: ${scene.vfxDescription}
VFX KEYWORDS: ${vfxKeywords.join(', ')}
QUALITY TIER: ${tier}

COST ESTIMATION GUIDELINES:
- LOW tier: Basic VFX, simple compositing (5k-15k USD for short sequence)
- MEDIUM tier: Professional VFX, detailed simulations (20k-75k USD for short sequence) 
- HIGH tier: Photorealistic, complex VFX (100k-500k USD for short sequence)

Please provide a JSON response with this exact structure:
{
  "vfxElementsSummary": "Brief description of VFX elements for this tier",
  "estimatedVfxCost": 25000,
  "costEstimationNotes": "Brief justification for the cost estimate"
}

INSTRUCTIONS:
1. vfxElementsSummary: 1-2 sentences describing what VFX elements would be created for this tier
2. estimatedVfxCost: Specific dollar amount within the tier range
3. costEstimationNotes: Brief explanation of cost factors

Return ONLY the JSON object, no additional text.`;

        const request: GenerateContentRequest = {
          contents: [{
            role: "user",
            parts: [{ text: prompt }]
          }]
        };

        const result: GenerateContentResult = await model.generateContent(request);
        
        if (!result.response?.text) {
          throw new Error(`No response from Gemini for ${tier} tier`);
        }

        const responseText = result.response.text();
        console.log(`${logPrefix} Received ${tier} tier response (${responseText.length} chars)`);
        
        // Extract and parse JSON
        const jsonStr = extractJsonFromString(responseText) || responseText.trim();
        const tierDetails = JSON.parse(jsonStr);
        
        if (!tierDetails.vfxElementsSummary || !tierDetails.estimatedVfxCost || !tierDetails.costEstimationNotes) {
          throw new Error(`Invalid tier details structure for ${tier}`);
        }

        console.log(`${logPrefix} ${tier} tier: ${tierDetails.vfxElementsSummary} (Cost: $${tierDetails.estimatedVfxCost})`);
        
        // Generate concept image
        let conceptualImageUrl = null;
        try {
          console.log(`${logPrefix} Generating concept image for ${tier} tier`);
          const imageResult = await generateVFXConceptualImage({
            vfxDescription: scene.vfxDescription,
            vfxKeywords: vfxKeywords,
            qualityTier: tier,
            vfxElementsSummary: tierDetails.vfxElementsSummary
          });
          
          if (imageResult.success) {
            conceptualImageUrl = imageResult.imageUrl;
            console.log(`${logPrefix} ${tier} tier concept image generated successfully`);
          } else {
            console.warn(`${logPrefix} ${tier} tier concept image generation failed: ${imageResult.error}`);
          }
        } catch (imageError) {
          console.error(`${logPrefix} Error generating ${tier} tier concept image:`, imageError);
        }
        
        // Store tier details in database
        await createOrUpdateVfxSceneDetail(scene.id, tier, {
          vfxElementsSummaryForTier: tierDetails.vfxElementsSummary,
          estimatedVfxCost: parseInt(tierDetails.estimatedVfxCost),
          costEstimationNotes: tierDetails.costEstimationNotes,
          conceptualImageUrl: conceptualImageUrl,
          conceptualVideoUrl: null, // Future enhancement
        });
        
        console.log(`${logPrefix} ${tier} tier details stored successfully`);
        
      } catch (tierError) {
        console.error(`${logPrefix} Error processing ${tier} tier:`, tierError);
        // Continue with other tiers even if one fails
      }
    }
    
    console.log(`${logPrefix} VFX tier detail generation completed`);
    
  } catch (error) {
    console.error(`${logPrefix} Error during VFX tier generation:`, error);
    throw error;
  }
}

export async function analyzeAndStoreScriptVFX(
  scriptId: number,
  scriptContent: string,
  allScenes: Scene[]
): Promise<void> {
  const logPrefix = `[VFX Analysis for Script ${scriptId}]`;
  
  try {
    console.log(`${logPrefix} Starting VFX analysis for ${allScenes.length} scenes`);
    
    const genAI = initializeGenAIClient();
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    
    const scenesFormatted = formatScenesForPrompt(allScenes);
    
    const prompt = `Analyze these script scenes to identify which ones require VFX work.

VFX scenes include: explosions, supernatural elements, impossible physics, weather effects, sci-fi technology, green screen needs, digital environments, superhuman abilities.

NON-VFX scenes include: regular dialogue, normal human actions, real vehicles, natural outdoor scenes, interior scenes with practical props.

${scenesFormatted}

For each scene, respond with exactly this format (one line per scene):
sceneId|isVfxScene|description|keywords

Examples:
123|true|Explosion destroys building|explosion,destruction,debris
124|false||
125|true|Character flies through air|flying,supernatural,gravity

Use this exact format - one line per scene, separated by | characters. For non-VFX scenes, use "false" and leave description and keywords empty but keep the | separators.`;

    const request: GenerateContentRequest = {
      contents: [{
        role: "user",
        parts: [{ text: prompt }]
      }]
    };

    console.log(`${logPrefix} Sending VFX analysis request to Gemini`);
    const result: GenerateContentResult = await model.generateContent(request);
    
    if (!result.response?.text) {
      throw new Error("No response text from Gemini");
    }

    const responseText = result.response.text();
    console.log(`${logPrefix} Received response from Gemini (${responseText.length} chars)`);
    
    // Parse the simple text format: sceneId|isVfxScene|description|keywords
    const lines = responseText.trim().split('\n');
    const analysisResults: VfxSceneAnalysis[] = [];
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (!trimmedLine || !trimmedLine.includes('|')) continue;
      
      const parts = trimmedLine.split('|');
      if (parts.length < 2) continue;
      
      const sceneId = parseInt(parts[0]);
      const isVfxScene = parts[1].toLowerCase() === 'true';
      const vfxDescription = parts[2] || null;
      const vfxKeywords = parts[3] ? parts[3].split(',').map(k => k.trim()) : [];
      
      if (!isNaN(sceneId)) {
        // Find scene number from the scenes array
        const scene = allScenes.find(s => s.id === sceneId);
        const sceneNumber = scene ? scene.sceneNumber : 0;
        
        analysisResults.push({
          sceneId,
          sceneNumber,
          isVfxScene,
          vfxDescription,
          vfxKeywords
        });
      }
    }
    
    console.log(`${logPrefix} Successfully parsed ${analysisResults.length} scene analyses`);

    // Update scenes in database
    let updatedCount = 0;
    let vfxScenesCount = 0;

    for (const analysis of analysisResults) {
      try {
        // Find the corresponding scene
        const scene = allScenes.find(s => s.id === analysis.sceneId || s.sceneNumber === analysis.sceneNumber);
        
        if (!scene) {
          console.warn(`${logPrefix} Could not find scene with ID ${analysis.sceneId} or number ${analysis.sceneNumber}`);
          continue;
        }

        // Prepare update data
        const updateData = {
          isVfxScene: analysis.isVfxScene,
          vfxDescription: analysis.isVfxScene ? analysis.vfxDescription || null : null,
          vfxKeywords: analysis.isVfxScene && analysis.vfxKeywords ? analysis.vfxKeywords : null,
        };

        // Update the scene in database
        await updateScene(scene.id, updateData);
        updatedCount++;
        
        if (analysis.isVfxScene) {
          vfxScenesCount++;
          console.log(`${logPrefix} Scene ${scene.sceneNumber} marked as VFX: ${analysis.vfxDescription}`);
        }

      } catch (updateError) {
        console.error(`${logPrefix} Error updating scene ${analysis.sceneId}:`, updateError);
      }
    }

    console.log(`${logPrefix} VFX analysis complete. Updated ${updatedCount} scenes, ${vfxScenesCount} identified as VFX scenes`);

  } catch (error) {
    console.error(`${logPrefix} Error during VFX analysis:`, error);
    throw error;
  }
}


================================================
FILE: server/services/ai-agents/ai-client.ts
================================================
/**
 * Shared AI Client for all agents
 * 
 * This module provides a consistent way to initialize and access
 * the Google Generative AI client across all specialized agents.
 */

import {
  GoogleGenerativeAI,
  HarmCategory,
  HarmBlockThreshold,
  type GenerationConfig,
  type SafetySetting
} from "@google/generative-ai";

// --- Client Singleton ---
let genAIInstance: GoogleGenerativeAI | null = null;
const MODEL_NAME = "gemini-1.5-flash-8b"; // Use consistent model version

// Standard safety settings to use across all agents
const safetySettings: SafetySetting[] = [
  {
    category: HarmCategory.HARM_CATEGORY_HARASSMENT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
];

/**
 * Initialize and get the Google Generative AI client
 */
export function getAIClient() {
  if (genAIInstance) {
    return { client: genAIInstance, safetySettings, modelName: MODEL_NAME };
  }
  
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) {
    console.error("[AI Client] CRITICAL: GEMINI_API_KEY environment variable is not set");
    throw new Error("GEMINI_API_KEY environment variable is not set");
  }
  
  genAIInstance = new GoogleGenerativeAI(apiKey);
  
  return { client: genAIInstance, safetySettings, modelName: MODEL_NAME };
}

/**
 * Sanitize text to avoid safety filter issues
 */
export function sanitizeText(text: string): string {
  if (!text) return "";
  
  const profanityMap: Record<string, string> = {
    shit: "stuff",
    damn: "darn",
    "fuckin'": "really",
    fucking: "really",
    hell: "heck",
  };
  
  let sanitized = text;
  for (const word in profanityMap) {
    const regex = new RegExp(`\\b${word}\\b`, "gi");
    sanitized = sanitized.replace(regex, profanityMap[word]);
  }
  
  // Remove null characters
  sanitized = sanitized.replace(/\u0000/g, "");
  
  return sanitized;
}

/**
 * Extract valid JSON from potentially messy AI response text
 */
export function extractJsonFromText(text: string): any {
  try {
    // Try to extract just the JSON part using regex
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    const jsonStr = jsonMatch ? jsonMatch[0] : text;
    
    return JSON.parse(jsonStr);
  } catch (error) {
    console.error("[AI Client] Error parsing JSON response:", error);
    console.error("[AI Client] Raw text:", text);
    return null;
  }
}


================================================
FILE: server/services/ai-agents/character-casting-pipeline.ts
================================================
import { extractCharactersFromScript } from './extraction-agent';
import { predictScriptGenre } from './genre-agent';
import { estimateCharacterDetails } from './description-agent';
import { generateCharacterSummary } from './summary-agent';
import { rankActorsForCharacter, ActorRanking } from './selection-agent';
import { ExtractedCharacter, CharacterSummary, GenrePrediction } from './shared-types';
import { Actor as DbActor } from '@shared/schema';

// Cache for character summaries to avoid redundant calls
const characterSummaryCache = new Map<string, CharacterSummary>();

/**
 * Extract all characters from a script using the extraction agent
 */
export async function extractCharacters(scriptContent: string): Promise<ExtractedCharacter[]> {
  console.log("[Casting Pipeline] Extracting characters from script");
  return extractCharactersFromScript(scriptContent);
}

/**
 * Predict the genre of a script using the genre agent
 */
export async function predictGenre(scriptContent: string): Promise<GenrePrediction | null> {
  console.log("[Casting Pipeline] Predicting script genre");
  return predictScriptGenre(scriptContent);
}

/**
 * Get character details for pre-filling search criteria
 * This runs when a user selects a character
 */
export async function getCharacterDetails(
  scriptContent: string, 
  characterName: string
): Promise<any> {
  console.log(`[Casting Pipeline] Getting details for character "${characterName}"`);
  
  // Run description agent
  const details = await estimateCharacterDetails(scriptContent, characterName);
  
  // In parallel, generate a character summary for later use in actor ranking
  generateAndCacheCharacterSummary(scriptContent, characterName);
  
  return details;
}

/**
 * Generate and cache a character summary in the background
 * This runs in parallel with getting character details
 */
async function generateAndCacheCharacterSummary(
  scriptContent: string,
  characterName: string
): Promise<void> {
  const cacheKey = `${characterName}`;
  
  // Check if we already have this character summary cached
  if (characterSummaryCache.has(cacheKey)) {
    console.log(`[Casting Pipeline] Using cached summary for "${characterName}"`);
    return;
  }
  
  console.log(`[Casting Pipeline] Generating summary for "${characterName}" in background`);
  
  try {
    const summary = await generateCharacterSummary(scriptContent, characterName);
    
    if (summary) {
      characterSummaryCache.set(cacheKey, summary);
      console.log(`[Casting Pipeline] Successfully cached summary for "${characterName}"`);
    }
  } catch (error) {
    console.error(`[Casting Pipeline] Error generating character summary:`, error);
    // Non-critical error, can continue without summary
  }
}

/**
 * Get character summary from cache or generate it if not available
 */
async function getCharacterSummary(
  scriptContent: string,
  characterName: string
): Promise<CharacterSummary | null> {
  const cacheKey = `${characterName}`;
  
  // Check if we have this character summary cached
  if (characterSummaryCache.has(cacheKey)) {
    return characterSummaryCache.get(cacheKey)!;
  }
  
  // If not cached, generate it now
  console.log(`[Casting Pipeline] Generating summary for "${characterName}" on demand`);
  const summary = await generateCharacterSummary(scriptContent, characterName);
  
  if (summary) {
    characterSummaryCache.set(cacheKey, summary);
  }
  
  return summary;
}

/**
 * Find and rank actors for a character using the selection agent
 * This runs when the user clicks "Find Actors"
 */
export async function findActorsForCharacter(
  scriptContent: string,
  characterName: string,
  filteredActors: DbActor[],
  criteria: {
    filmGenre?: string;
    roleType?: string;
    budgetTier?: string;
    gender?: string;
  }
): Promise<ActorRanking[]> {
  console.log(`[Casting Pipeline] Finding actors for "${characterName}" with ${filteredActors.length} filtered actors`);
  
  // Get character summary (from cache or generate it)
  const summary = await getCharacterSummary(scriptContent, characterName);
  
  if (!summary) {
    console.error(`[Casting Pipeline] Could not get character summary for "${characterName}"`);
    return [];
  }
  
  // Use the selection agent to rank actors
  return rankActorsForCharacter(summary, filteredActors, criteria);
}

/**
 * Clear character summary cache for a specific character or all characters
 */
export function clearCharacterSummaryCache(characterName?: string): void {
  if (characterName) {
    characterSummaryCache.delete(characterName);
    console.log(`[Casting Pipeline] Cleared summary cache for "${characterName}"`);
  } else {
    characterSummaryCache.clear();
    console.log(`[Casting Pipeline] Cleared all character summary caches`);
  }
}


================================================
FILE: server/services/ai-agents/db-filter-service.ts
================================================
/**
 * Database Filter Service for Character Casting
 * 
 * This service filters actors from the database based on search criteria
 * without using AI - just pure logic-based filtering.
 */

import * as storage from '../../storage';
import { Actor as DbActor } from '@shared/schema';

interface FilterCriteria {
  estimatedAgeRange?: string;
  gender?: string;
  roleType?: string;
  budgetTier?: string;
  limit?: number;
}

/**
 * Filter actors from the database based on search criteria
 */
export async function filterActorsFromDatabase(criteria: FilterCriteria): Promise<DbActor[]> {
  console.log('[DB Filter] Filtering actors with criteria:', JSON.stringify(criteria));
  
  try {
    // Process gender filter - only filter if specified and not "any"
    let genderFilter: string | undefined = undefined;
    if (criteria.gender && 
        !['any', 'all', 'unknown'].includes(criteria.gender.toLowerCase())) {
      genderFilter = criteria.gender;
    }
    
    // Get actors from database using storage service
    const filteredActors = await storage.getActorsForAISuggestionByCriteria({
      estimatedAgeRange: criteria.estimatedAgeRange,
      gender: genderFilter,
      limit: criteria.limit || 100
    });
    
    console.log(`[DB Filter] Found ${filteredActors.length} actors matching criteria`);
    return filteredActors;
  } catch (error) {
    console.error('[DB Filter] Error filtering actors:', error);
    return [];
  }
}


================================================
FILE: server/services/ai-agents/description-agent.ts
================================================
/**
 * Character Description Agent
 * 
 * This agent is responsible for analyzing a character and estimating
 * key information needed for casting, including role type, age, gender,
 * and budget tier. It runs when a character is selected in the UI.
 */

import { ExtractedCharacter } from './shared-types';
import { getAIClient, extractJsonFromText, sanitizeText } from './ai-client';
import { GenerationConfig } from '@google/generative-ai';

interface CharacterDetailsResponse {
  roleType: string;
  estimatedAge: string;
  gender: string;
  budgetTier: string;
  keyTraits: string[];
}

/**
 * Estimates character details for casting purposes
 * 
 * @param scriptContent The content of the script
 * @param characterName The name of the character to analyze
 * @returns Details about the character that help with casting
 */
export async function estimateCharacterDetails(
  scriptContent: string,
  characterName: string,
): Promise<CharacterDetailsResponse | null> {
  if (!scriptContent || !characterName) {
    console.log("[Description Agent] Missing script content or character name");
    return null;
  }

  const logPrefix = "[Description Agent]";
  console.log(`${logPrefix} Analyzing character "${characterName}"`);

  try {
    // Get shared AI client
    const { client, safetySettings, modelName } = getAIClient();
    
    const model = client.getGenerativeModel({
      model: modelName,
      safetySettings,
      generationConfig: {
        responseMimeType: "application/json",
        temperature: 0.2,
        maxOutputTokens: 2048,
      } as GenerationConfig,
    });

    // Prepare script content (truncate if needed)
    const maxScriptCharsForPrompt = 300000;
    const scriptContentForPrompt =
      scriptContent.length > maxScriptCharsForPrompt
        ? scriptContent.substring(0, maxScriptCharsForPrompt) +
          "\n...[TRUNCATED FOR PROMPT]..."
        : scriptContent;

    const prompt = `
    You are an expert casting director analyzing a screenplay character for an upcoming production.
    
    Your task is to analyze the character named "${characterName}" in the provided screenplay
    and determine key details needed for casting purposes.
    
    Focus specifically on:
    1. Role Type - Whether this character is a lead, supporting, or minor role
    2. Estimated Age - As a specific age or age range
    3. Gender - Based on context clues in the script
    4. Budget Tier - What budget level (low/medium/high) would be appropriate for this character
    5. Key Traits - What are 3-5 defining characteristics or traits of this character
    
    SCREENPLAY:
    ${sanitizeText(scriptContentForPrompt)}
    
    Reply with ONLY a JSON object in the following format, with no additional text or explanation:
    {
      "roleType": "lead/supporting/minor",
      "estimatedAge": "AGE_OR_AGE_RANGE (e.g., 25-30, 40s, teen, child, elderly)",
      "gender": "male/female/non-binary/unknown",
      "budgetTier": "low/medium/high",
      "keyTraits": ["trait1", "trait2", "trait3"]
    }
    `;

    const result = await model.generateContent([prompt]);
    const response = await result.response;
    const responseText = response.text().trim();

    console.log(`${logPrefix} Got response from Gemini, parsing JSON...`);

    // Extract JSON from the response text
    const parsedData = extractJsonFromText(responseText) as CharacterDetailsResponse;
    
    // Validate the response format
    if (!parsedData || !parsedData.roleType || !parsedData.estimatedAge || !parsedData.gender) {
      console.error(`${logPrefix} Invalid response format:`, parsedData);
      return null;
    }

    console.log(`${logPrefix} Successfully analyzed character "${characterName}"`);
    
    return parsedData;
  } catch (error) {
    console.error(`${logPrefix} Error analyzing character:`, error);
    return null;
  }
}


================================================
FILE: server/services/ai-agents/extraction-agent.ts
================================================
/**
 * Character Extraction Agent
 * 
 * This agent is responsible for extracting all character names from an uploaded script
 * using AI. It runs immediately after file upload completes and populates the
 * character selection dropdown.
 */

import { ExtractedCharacter } from './shared-types';
import { getAIClient, extractJsonFromText, sanitizeText } from './ai-client';
import { GenerationConfig } from '@google/generative-ai';

interface GeminiCharacterResponse {
  characters: ExtractedCharacter[];
}

/**
 * Extracts characters from a script using Gemini AI
 * 
 * @param scriptContent The content of the uploaded script
 * @returns Array of extracted characters with name, estimatedAgeRange, etc.
 */
export async function extractCharactersFromScript(
  scriptContent: string,
): Promise<ExtractedCharacter[]> {
  if (!scriptContent || scriptContent.trim().length < 50) {
    console.log(
      "[Extraction Agent] Script content is too short or empty. Skipping character extraction.",
    );
    return [];
  }

  const logPrefix = "[Extraction Agent]";
  console.log(
    `${logPrefix} Starting character extraction and age estimation from script (length: ${scriptContent.length}).`,
  );

  try {
    // Get shared AI client
    const { client, safetySettings, modelName } = getAIClient();
    
    const model = client.getGenerativeModel({
      model: modelName,
      safetySettings,
      generationConfig: {
        responseMimeType: "application/json",
        temperature: 0.1,
        maxOutputTokens: 8192,
      } as GenerationConfig,
    });

    const maxScriptCharsForPrompt = 650000;
    const scriptContentForPrompt =
      scriptContent.length > maxScriptCharsForPrompt
        ? scriptContent.substring(0, maxScriptCharsForPrompt) +
          "\n...[TRUNCATED FOR PROMPT]..."
        : scriptContent;

    const prompt = `
    You are an expert script analyst. Your task is to analyze the provided screenplay content and extract all unique speaking character names, along with an estimated age or age range for each character.

    Follow these specific steps:
    1. Extract all character names that have speaking lines. Look for names in all-caps, which is standard screenplay format for character names. 
    2. For each character, analyze dialogue and context to identify their approximate age range.
    3. When possible, determine the gender of each character from context clues in the script.
    4. Analyze the character's importance in the story and categorize as (lead, supporting, or minor role).
    5. Provide a budget tier recommendation for casting (low, medium, high) based on the character's importance.

    Important: Only extract real characters who speak or are directly mentioned, not scene direction labels or camera instructions.

    SCREENPLAY:
    ${sanitizeText(scriptContentForPrompt)}

    Reply with ONLY a JSON object in the following format, with no additional text or explanation:
    {
      "characters": [
        {
          "name": "CHARACTER_NAME_IN_ALL_CAPS",
          "estimatedAgeRange": "AGE_OR_AGE_RANGE (e.g., 25-30, 40s, teen, child, elderly)",
          "gender": "male/female/non-binary/unknown",
          "roleType": "lead/supporting/minor",
          "recommendedBudgetTier": "low/medium/high",
          "description": "Brief 1-2 sentence description of character personality/role"
        },
        ...
      ]
    }
    `;

    const result = await model.generateContent([prompt]);
    const response = await result.response;
    const responseText = response.text().trim();

    console.log(`${logPrefix} Got response from Gemini, parsing JSON...`);

    // Extract JSON from the response text
    const parsedData = extractJsonFromText(responseText) as GeminiCharacterResponse;
    
    // Validate the response format
    if (!parsedData || !parsedData.characters || !Array.isArray(parsedData.characters)) {
      console.error(`${logPrefix} Invalid response format:`, parsedData);
      return [];
    }

    const characters = parsedData.characters;
    console.log(`${logPrefix} Successfully extracted ${characters.length} characters`);
    
    return characters;
  } catch (error) {
    console.error(`${logPrefix} Error extracting characters:`, error);
    return [];
  }
}


================================================
FILE: server/services/ai-agents/genre-agent.ts
================================================
/**
 * Genre Prediction Agent
 * 
 * This agent analyzes a script and predicts its likely genre.
 * It runs after file upload and populates the genre dropdown.
 */

import { GenrePrediction } from './shared-types';
import { getAIClient, extractJsonFromText, sanitizeText } from './ai-client';
import { GenerationConfig } from '@google/generative-ai';

/**
 * Predicts the genre of a script using Gemini AI
 * 
 * @param scriptContent The content of the uploaded script
 * @returns Predicted genre information
 */
export async function predictScriptGenre(
  scriptContent: string,
): Promise<GenrePrediction | null> {
  if (!scriptContent || scriptContent.trim().length < 100) {
    console.log(
      "[Genre Agent] Script content is too short or empty. Skipping genre prediction.",
    );
    return null;
  }

  const logPrefix = "[Genre Agent]";
  console.log(
    `${logPrefix} Starting genre prediction for script (length: ${scriptContent.length}).`,
  );

  try {
    // Get shared AI client
    const { client, safetySettings, modelName } = getAIClient();
    
    const model = client.getGenerativeModel({
      model: modelName,
      safetySettings,
      generationConfig: {
        responseMimeType: "application/json",
        temperature: 0.1,
        maxOutputTokens: 2048,
      } as GenerationConfig,
    });

    // Truncate script content for the prompt if necessary
    const maxScriptCharsForPrompt = 350000;
    const scriptContentForPrompt =
      scriptContent.length > maxScriptCharsForPrompt
        ? scriptContent.substring(0, maxScriptCharsForPrompt) +
          "\n...[TRUNCATED FOR PROMPT]..."
        : scriptContent;

    const prompt = `
    You are an expert screenplay analyst specializing in genre identification. Your task is to analyze the provided screenplay and identify its most likely genre(s).

    Follow these specific steps:
    1. Analyze the provided screenplay content
    2. Identify the primary genre that best describes the script
    3. Identify any secondary genres that may also apply
    4. Assign a confidence level to your prediction (0.0-1.0)

    Consider standard film genres such as:
    - Action
    - Adventure
    - Animation
    - Comedy
    - Crime
    - Documentary
    - Drama
    - Family
    - Fantasy
    - Horror
    - Musical
    - Mystery
    - Romance
    - Science Fiction
    - Thriller
    - War
    - Western

    But don't limit yourself to these if you detect others.

    SCREENPLAY:
    ${sanitizeText(scriptContentForPrompt)}

    Reply with ONLY a JSON object in the following format, with no additional text or explanation:
    {
      "primaryGenre": "MOST_LIKELY_GENRE",
      "secondaryGenres": ["SECOND_GENRE", "THIRD_GENRE"],
      "confidence": CONFIDENCE_LEVEL_AS_DECIMAL
    }
    `;

    const result = await model.generateContent([prompt]);
    const response = await result.response;
    const responseText = response.text().trim();

    console.log(`${logPrefix} Got response from Gemini, parsing JSON...`);

    // Extract JSON from the response text
    const parsedData = extractJsonFromText(responseText) as GenrePrediction;
    
    // Validate the response format
    if (!parsedData || !parsedData.primaryGenre || !parsedData.secondaryGenres || !Array.isArray(parsedData.secondaryGenres)) {
      console.error(`${logPrefix} Invalid response format:`, parsedData);
      return null;
    }

    console.log(`${logPrefix} Successfully predicted genre: ${parsedData.primaryGenre}`);
    
    return parsedData;
  } catch (error) {
    console.error(`${logPrefix} Error predicting genre:`, error);
    return null;
  }
}


================================================
FILE: server/services/ai-agents/index.ts
================================================
/**
 * AI Agents Module
 * 
 * This file exports all the AI agents as a unified module to simplify integration
 * with the existing codebase.
 */

// Export all agents from the modular pipeline
export * from './extraction-agent';
export * from './genre-agent';
export * from './description-agent';
export * from './summary-agent';
export * from './selection-agent';
export * from './shared-types';

// Re-export the main pipeline coordinator
export * from './character-casting-pipeline';


================================================
FILE: server/services/ai-agents/selection-agent.ts
================================================
/**
 * Actor Selection Agent
 * 
 * This agent ranks actors for a specific character based on the character summary
 * and filtered actor list. It runs after the user clicks "Find Actors".
 */

import { getAIClient, extractJsonFromText, sanitizeText } from './ai-client';
import { GenerationConfig } from '@google/generative-ai';
import { Actor as DbActor } from '@shared/schema';
import { CharacterSummary } from '../../types';

export interface ActorRanking {
  actorName: string;
  matchReason: string;
  confidenceScore: number;
  controversyLevel: 'none' | 'low' | 'medium' | 'high';
}

/**
 * Ranks actors for a character based on the character summary and filtered actor list
 * 
 * @param characterSummary The summary of the character
 * @param filteredActors List of actors that passed the basic filtering criteria
 * @param maxResults Maximum number of actors to return
 * @returns Ranked list of actors with justifications
 */
export async function rankActorsForCharacter(
  characterSummary: CharacterSummary,
  filteredActors: DbActor[],
  additionalCriteria: {
    filmGenre?: string;
    roleType?: string;
    budgetTier?: string;
    gender?: string;
  },
  maxResults: number = 3
): Promise<ActorRanking[]> {
  if (!characterSummary || !filteredActors || filteredActors.length === 0) {
    console.log("[Selection Agent] Missing character summary or filtered actors");
    return [];
  }

  const logPrefix = "[Selection Agent]";
  console.log(`${logPrefix} Ranking ${filteredActors.length} actors for "${characterSummary.name}"`);

  try {
    // Get shared AI client
    const { client, safetySettings, modelName } = getAIClient();
    
    const model = client.getGenerativeModel({
      model: modelName,
      safetySettings,
      generationConfig: {
        responseMimeType: "application/json",
        temperature: 0.3,
        maxOutputTokens: 4096,
      } as GenerationConfig,
    });

    // Format actors for prompt
    const formattedActors = filteredActors.map(actor => {
      const notableRoles = actor.notableRoles?.slice(0, 3).join(", ") || "Unknown";
      const genres = Array.isArray(actor.genres) ? actor.genres.slice(0, 3).join(", ") : "Various";
      
      return `Actor Name: ${actor.name}, Gender: ${actor.gender || "Unknown"}, 
      Nationality: ${actor.nationality || "Unknown"}, 
      DOB: ${actor.dateOfBirth || "Unknown"}, 
      Popularity: ${actor.recentPopularity || "Medium"}, 
      Salary Range: ${actor.estSalaryRange || "Unknown"}, 
      Notable Roles: ${notableRoles}, 
      Typical Genres: ${genres}`;
    }).join("\n");

    const prompt = `
    You are an expert Casting Director AI tasked with selecting the ${maxResults} most suitable actors 
    for a character based on artistic fit, role interpretation, and strategic considerations.

    CHARACTER PROFILE:
    - Name: "${characterSummary.name}"
    - Description: "${characterSummary.description}"
    - Key Traits: ${characterSummary.keyTraits.join(", ")}
    - Importance Level (1-10): ${characterSummary.importanceLevel}
    ${additionalCriteria.filmGenre ? `- Film Genre: ${additionalCriteria.filmGenre}` : ''}
    ${additionalCriteria.roleType ? `- Role Type: ${additionalCriteria.roleType}` : ''}
    ${additionalCriteria.budgetTier ? `- Budget Tier: ${additionalCriteria.budgetTier}` : ''}
    ${additionalCriteria.gender ? `- Target Casting Gender: ${additionalCriteria.gender}` : ''}

    SELECT FROM THESE PRE-FILTERED ACTORS:
    ${formattedActors}

    For each actor you select, provide:
    1. A clear explanation of why they match this specific character
    2. A confidence score (0.0-1.0) indicating how well they fit
    3. A controversy level assessment (none/low/medium/high)

    Reply with ONLY a JSON object in the following format:
    {
      "rankedActors": [
        {
          "actorName": "ACTOR_NAME",
          "matchReason": "DETAILED_EXPLANATION_OF_FIT",
          "confidenceScore": CONFIDENCE_SCORE,
          "controversyLevel": "none/low/medium/high"
        },
        ...
      ]
    }
    `;

    const result = await model.generateContent([prompt]);
    const response = await result.response;
    const responseText = response.text().trim();

    console.log(`${logPrefix} Got response from Gemini, parsing JSON...`);

    // Extract JSON from the response text
    const parsedData = extractJsonFromText(responseText);
    
    // Validate the response format
    if (!parsedData || !parsedData.rankedActors || !Array.isArray(parsedData.rankedActors)) {
      console.error(`${logPrefix} Invalid response format:`, parsedData);
      return [];
    }

    // Map to our ActorRanking interface
    const rankings: ActorRanking[] = parsedData.rankedActors.map((actor: any) => ({
      actorName: actor.actorName,
      matchReason: actor.matchReason,
      confidenceScore: actor.confidenceScore || 0.5,
      controversyLevel: actor.controversyLevel || 'none'
    })).slice(0, maxResults);

    console.log(`${logPrefix} Successfully ranked ${rankings.length} actors for "${characterSummary.name}"`);
    
    return rankings;
  } catch (error) {
    console.error(`${logPrefix} Error ranking actors:`, error);
    return [];
  }
}


================================================
FILE: server/services/ai-agents/shared-types.ts
================================================
/**
 * Shared types for AI agents
 */

export interface ExtractedCharacter {
  name: string;
  estimatedAgeRange?: string;
  gender?: string;
  roleType?: string;
  recommendedBudgetTier?: string;
  description?: string;
}

export interface CharacterSummary {
  name: string;
  description: string;
  keyTraits: string[];
  importanceLevel: number; // 1-10 scale
}

export interface GenrePrediction {
  primaryGenre: string;
  secondaryGenres: string[];
  confidence: number;
}


================================================
FILE: server/services/ai-agents/summary-agent.ts
================================================
/**
 * Character Summary Agent
 * 
 * This agent generates a concise summary of a character from a script.
 * It runs in parallel with the description agent when a character is selected.
 */

import { CharacterSummary } from './shared-types';
import { getAIClient, extractJsonFromText, sanitizeText } from './ai-client';
import { GenerationConfig } from '@google/generative-ai';

/**
 * Generates a concise summary of a character from a script
 * 
 * @param scriptContent The content of the script
 * @param characterName The name of the character to summarize
 * @returns A concise summary of the character
 */
export async function generateCharacterSummary(
  scriptContent: string,
  characterName: string,
): Promise<CharacterSummary | null> {
  if (!scriptContent || !characterName) {
    console.log("[Summary Agent] Missing script content or character name");
    return null;
  }

  const logPrefix = "[Summary Agent]";
  console.log(`${logPrefix} Generating summary for "${characterName}"`);

  try {
    // Get shared AI client
    const { client, safetySettings, modelName } = getAIClient();
    
    const model = client.getGenerativeModel({
      model: modelName,
      safetySettings,
      generationConfig: {
        responseMimeType: "application/json",
        temperature: 0.2,
        maxOutputTokens: 2048,
      } as GenerationConfig,
    });

    // Prepare script content (truncate if needed)
    const maxScriptCharsForPrompt = 300000;
    const scriptContentForPrompt =
      scriptContent.length > maxScriptCharsForPrompt
        ? scriptContent.substring(0, maxScriptCharsForPrompt) +
          "\n...[TRUNCATED FOR PROMPT]..."
        : scriptContent;

    const prompt = `
    You are an expert screenplay analyst focusing on character analysis.
    
    Your task is to create a concise but insightful summary of the character named "${characterName}" 
    from the provided screenplay. This summary will be used to match the character with appropriate actors.
    
    Focus on:
    1. Overall personality and defining characteristics
    2. Character arc or development (if any)
    3. Key relationships with other characters
    4. Specific acting challenges this role might present
    5. Importance to the overall story
    
    SCREENPLAY:
    ${sanitizeText(scriptContentForPrompt)}
    
    Reply with ONLY a JSON object in the following format, with no additional text or explanation:
    {
      "name": "${characterName}",
      "description": "A 1-2 sentence concise character summary",
      "keyTraits": ["trait1", "trait2", "trait3", "trait4", "trait5"],
      "importanceLevel": IMPORTANCE_LEVEL_1_TO_10
    }
    `;

    const result = await model.generateContent([prompt]);
    const response = await result.response;
    const responseText = response.text().trim();

    console.log(`${logPrefix} Got response from Gemini, parsing JSON...`);

    // Extract JSON from the response text
    const parsedData = extractJsonFromText(responseText) as CharacterSummary;
    
    // Validate the response format
    if (!parsedData || !parsedData.name || !parsedData.description || !parsedData.keyTraits) {
      console.error(`${logPrefix} Invalid response format:`, parsedData);
      return null;
    }

    console.log(`${logPrefix} Successfully generated summary for "${characterName}"`);
    
    return parsedData;
  } catch (error) {
    console.error(`${logPrefix} Error generating character summary:`, error);
    return null;
  }
}


================================================
FILE: server/types/financials.d.ts
================================================
// server/types/financials.d.ts

// Interface for individual line items
export interface FinancialLineItem {
  account: string; // e.g., "1100"
  description: string;
  total: number | null; // Using number for actual values, null for placeholders initially
}

// Main categories mirroring "THE BEAST" template
export interface AboveTheLine {
  storyRights: FinancialLineItem;
  producer: FinancialLineItem;
  director: FinancialLineItem;
  castAndStunts: FinancialLineItem;
  fringes: FinancialLineItem;
  total: number | null;
}

export interface BelowTheLineProduction {
  productionStaff: FinancialLineItem;
  extrasStandins: FinancialLineItem;
  setDesign: FinancialLineItem;
  setConstruction: FinancialLineItem;
  setOperations: FinancialLineItem;
  specialEffects: FinancialLineItem;
  setDressing: FinancialLineItem;
  props: FinancialLineItem;
  wardrobe: FinancialLineItem;
  ledVirtual: FinancialLineItem;
  makeupHairdressing: FinancialLineItem;
  setLighting: FinancialLineItem;
  camera: FinancialLineItem;
  productionSound: FinancialLineItem;
  transportation: FinancialLineItem;
  locationExpenses: FinancialLineItem;
  pictureVehiclesAnimals: FinancialLineItem;
  productionFilmLab: FinancialLineItem;
  miscProduction: FinancialLineItem; // "MISC" in template
  healthSafety: FinancialLineItem;
  overtime: FinancialLineItem;
  studioEquipmentFacilities: FinancialLineItem;
  tests: FinancialLineItem;
  btlTravelLiving: FinancialLineItem; // "BTL T&L"
  serviceCompany: FinancialLineItem;
  fringes: FinancialLineItem;
  total: number | null;
}

export interface PostProduction {
  filmEditing: FinancialLineItem;
  music: FinancialLineItem;
  sound: FinancialLineItem;
  filmLabPost: FinancialLineItem; // "FILM&LAB"
  titles: FinancialLineItem;
  vfx: FinancialLineItem;
  fringes: FinancialLineItem;
  total: number | null;
}

export interface OtherBelowTheLine {
  publicity: FinancialLineItem;
  insurance: FinancialLineItem;
  miscExpenses: FinancialLineItem;
  legalAccounting: FinancialLineItem;
  fringes: FinancialLineItem;
  total: number | null;
}

// The main financial breakdown structure
export interface FinancialBreakdown {
  projectName: string | null;
  expectedReleaseDate: string | null; // YYYY-MM-DD
  location: string | null; // e.g., "ATHENS, GREECE"
  prepWeeks: number | null; // e.g., 12
  shootDays: string | null; // e.g., "30 DAYS (15 ACTION UNIT, 15 LED STAGE)"
  unions: string | null; // e.g., "DGA, WGA, SAG"

  aboveTheLine: AboveTheLine;
  belowTheLineProduction: BelowTheLineProduction;
  postProduction: PostProduction;
  otherBelowTheLine: OtherBelowTheLine; // Corresponds to "Total Below-The-Line Other"

  bondFee: FinancialLineItem;
  contingency: FinancialLineItem;

  // Summary Totals from the template
  summaryTotalAboveTheLine: number | null; // Matches "Total Above-The-Line"
  summaryTotalBelowTheLine: number | null; // Matches "Total Below-The-Line" (Production + Post + Other)
  summaryTotalAboveAndBelowTheLine: number | null; // Matches "Total Above and Below-The-Line"
  summaryGrandTotal: number | null; // Matches "Grand Total" (includes contingency and bond)

  // New fields for Vadis-specific analysis
  totalBudgetInput: number | null; // The user-inputted total budget
  estimatedBrandSponsorshipValue: number | null;
  estimatedLocationIncentiveValue: number | null;
  netExternalCapitalRequired: number | null;
}


================================================
FILE: server/types/pdf-parse.d.ts
================================================
declare module 'pdf-parse' {
  interface PdfData {
    /** The number of pages in the document */
    numpages: number;
    /** Total number of pages in the document */
    numrender: number;
    /** PDF info */
    info: any;
    /** PDF metadata */
    metadata: any;
    /** PDF.js version */
    version: string;
    /** The extracted text content */
    text: string;
  }

  /**
   * Parse PDF file
   * @param dataBuffer - PDF file buffer
   * @param options - Optional configurations
   * @returns A promise that resolves with parsed PDF data
   */
  function pdfParse(
    dataBuffer: Buffer,
    options?: {
      pagerender?: (pageData: any) => string;
      max?: number;
    }
  ): Promise<PdfData>;

  export default pdfParse;
}


================================================
FILE: shared/schema.ts
================================================
// shared/schema.ts
import {
  pgTable,
  text,
  serial,
  integer, // Keep integer for budget
  timestamp,
  jsonb,
  boolean,
  // numeric, // Alternative for budget if decimals are needed
} from "drizzle-orm/pg-core";
import { sql } from "drizzle-orm";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { relations } from "drizzle-orm";

// --- Users ---
// ... (User schema remains the same)
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
});

export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;


// --- Products ---
// ... (Product related enums and schema remain the same)
export const ProductCategory = {
  BEVERAGE: "BEVERAGE",
  ELECTRONICS: "ELECTRONICS",
  FOOD: "FOOD",
  AUTOMOTIVE: "AUTOMOTIVE",
  FASHION: "FASHION",
  WATCH: "WATCH",
} as const;

export const FilmRatingEnum = {
  G: "G",
  PG: "PG",
  PG_13: "PG-13",
  R: "R",
  NC_17: "NC-17",
  NR: "NR", // Not Rated
} as const;
export type FilmRatingType = keyof typeof FilmRatingEnum;

export const DemographicGenderEnum = {
  Male: "Male",
  Female: "Female",
  All: "All",
} as const;
export type DemographicGenderType = keyof typeof DemographicGenderEnum;

export const DemographicAgeEnum = {
  "18-24": "18-24",
  "25-34": "25-34",
  "35-44": "35-44",
  "45-54": "45-54",
  "55-64": "55-64",
  "65+": "65+",
  AllAges: "AllAges",
} as const;
export type DemographicAgeType = keyof typeof DemographicAgeEnum;

export const GenreEnum = {
  Action: "Action",
  Comedy: "Comedy",
  Drama: "Drama",
  Horror: "Horror",
  "Sci-Fi": "Sci-Fi",
  Romance: "Romance",
  Adventure: "Adventure",
  Thriller: "Thriller",
  Documentary: "Documentary",
  Animation: "Animation",
  Fantasy: "Fantasy",
  Any: "Any",
} as const;
export type GenreType = keyof typeof GenreEnum;

export const VfxQualityTierEnum = {
  LOW: "LOW",
  MEDIUM: "MEDIUM",
  HIGH: "HIGH",
} as const;
export type VfxQualityTierType = keyof typeof VfxQualityTierEnum;

export type ProductCategory = keyof typeof ProductCategory;

export const products = pgTable("products", {
  id: serial("id").primaryKey(),
  companyName: text("company_name").notNull(),
  name: text("name").notNull(),
  category: text("category").notNull().$type<ProductCategory>(),
  imageUrl: text("image_url").notNull(),
  filmRating: text("film_rating").$type<FilmRatingType | null>(),
  demographicGender: text(
    "demographic_gender",
  ).$type<DemographicGenderType | null>(),
  demographicAge: jsonb("demographic_age")
    .$type<DemographicAgeType[] | null>()
    .default(sql`'{}'::jsonb`),
  genre: text("genre").$type<GenreType | null>(),
  placementLimitations: text("placement_limitations"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const productsRelations = relations(products, ({ many }) => ({
  sceneVariations: many(sceneVariations),
}));

export const insertProductSchema = createInsertSchema(products, {
  companyName: (schema) =>
    schema.min(2, "Company name must be at least 2 characters"),
  name: (schema) => schema.min(2, "Product name must be at least 2 characters"),
  category: (schema) =>
    schema.refine(
      (val): val is ProductCategory =>
        Object.keys(ProductCategory).includes(val),
      "Invalid product category",
    ),
  imageUrl: (schema) => schema.url("Must be a valid URL"),
  filmRating: z.nativeEnum(FilmRatingEnum).optional().nullable(),
  demographicGender: z.nativeEnum(DemographicGenderEnum).optional().nullable(),
  demographicAge: z
    .array(z.nativeEnum(DemographicAgeEnum))
    .optional()
    .nullable(),
  genre: z.nativeEnum(GenreEnum).optional().nullable(),
  placementLimitations: z.string().optional().nullable(),
});

export type InsertProduct = z.infer<typeof insertProductSchema>;
export type Product = typeof products.$inferSelect;


// --- Scripts ---
export const scripts = pgTable("scripts", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  content: text("content").notNull(),
  // --- BEGIN MODIFICATION (Task 1.2) ---
  expectedReleaseDate: text("expected_release_date"), // Nullable
  totalBudget: integer("total_budget"), // Nullable, storing as whole dollars
  // --- END MODIFICATION (Task 1.2) ---
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const scriptsRelations = relations(scripts, ({ many }) => ({
  scenes: many(scenes),
}));

export const insertScriptSchema = createInsertSchema(scripts, {
  title: (schema) => schema.min(1, "Title cannot be empty"),
  content: (schema) => schema.min(1, "Content cannot be empty"),
  // --- BEGIN MODIFICATION (Task 1.2) ---
  expectedReleaseDate: z.string().optional().nullable(), // Validate as string (YYYY-MM-DD) or allow null
  totalBudget: z.number().int().positive().optional().nullable(), // Validate as positive integer or allow null
  // --- END MODIFICATION (Task 1.2) ---
});

export type InsertScript = z.infer<typeof insertScriptSchema>;
export type Script = typeof scripts.$inferSelect;


// --- Scenes ---
// ... (Scene schema remains the same)
export const scenes = pgTable("scenes", {
  id: serial("id").primaryKey(),
  scriptId: integer("script_id")
    .references(() => scripts.id, { onDelete: "cascade" })
    .notNull(),
  sceneNumber: integer("scene_number").notNull(),
  heading: text("heading").notNull(),
  content: text("content").notNull(),
  isBrandable: boolean("is_brandable").default(false).notNull(),
  brandableReason: text("brandable_reason"),
  suggestedCategories: jsonb("suggested_categories").$type<ProductCategory[]>(),
  isVfxScene: boolean("is_vfx_scene").default(false).notNull(),
  vfxDescription: text("vfx_description"),
  vfxKeywords: jsonb("vfx_keywords").$type<string[]>(),
  selectedVfxTier: text("selected_vfx_tier").$type<VfxQualityTierType | null>(),
  selectedVfxCost: integer("selected_vfx_cost").default(0),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const scenesRelations = relations(scenes, ({ one, many }) => ({
  script: one(scripts, {
    fields: [scenes.scriptId],
    references: [scripts.id],
  }),
  variations: many(sceneVariations),
  vfxDetails: many(vfxSceneDetails),
}));

export const insertSceneSchema = createInsertSchema(scenes);

export type InsertScene = z.infer<typeof insertSceneSchema>;
export type Scene = typeof scenes.$inferSelect;


// --- Scene Variations ---
// ... (SceneVariation schema remains the same)
export const sceneVariations = pgTable("scene_variations", {
  id: serial("id").primaryKey(),
  sceneId: integer("scene_id")
    .references(() => scenes.id, { onDelete: "cascade" })
    .notNull(),
  productId: integer("product_id")
    .references(() => products.id, { onDelete: "cascade" })
    .notNull(),
  variationNumber: integer("variation_number").notNull(),
  description: text("description").notNull(),
  imageUrl: text("image_url").notNull(),
  geminiPrompt: text("gemini_prompt").notNull(),
  isSelected: boolean("is_selected").default(false).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const sceneVariationsRelations = relations(
  sceneVariations,
  ({ one }) => ({
    scene: one(scenes, {
      fields: [sceneVariations.sceneId],
      references: [scenes.id],
    }),
    product: one(products, {
      fields: [sceneVariations.productId],
      references: [products.id],
    }),
  }),
);

export const insertSceneVariationSchema = createInsertSchema(sceneVariations, {
  geminiPrompt: (schema) => schema.min(10, "Gemini prompt seems too short."),
});

export type InsertSceneVariation = z.infer<typeof insertSceneVariationSchema>;
export type SceneVariation = typeof sceneVariations.$inferSelect & {
  productName?: string;
  productCategory?: ProductCategory;
  productImageUrl?: string | null;
};


// --- VFX Scene Details ---
export const vfxSceneDetails = pgTable("vfx_scene_details", {
  id: serial("id").primaryKey(),
  sceneId: integer("scene_id")
    .references(() => scenes.id, { onDelete: "cascade" })
    .notNull(),
  qualityTier: text("quality_tier").$type<VfxQualityTierType>().notNull(),
  conceptualImageUrl: text("conceptual_image_url"),
  conceptualVideoUrl: text("conceptual_video_url"),
  estimatedVfxCost: integer("estimated_vfx_cost"),
  costEstimationNotes: text("cost_estimation_notes"),
  vfxElementsSummaryForTier: text("vfx_elements_summary_for_tier"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => ({
  // Unique composite index on scene_id and quality_tier
  uniqueSceneQualityTier: sql`UNIQUE (${table.sceneId}, ${table.qualityTier})`,
}));

export const vfxSceneDetailsRelations = relations(vfxSceneDetails, ({ one }) => ({
  scene: one(scenes, {
    fields: [vfxSceneDetails.sceneId],
    references: [scenes.id],
  }),
}));

export const insertVfxSceneDetailSchema = createInsertSchema(vfxSceneDetails);

export type InsertVfxSceneDetail = z.infer<typeof insertVfxSceneDetailSchema>;
export type VfxSceneDetail = typeof vfxSceneDetails.$inferSelect;


// --- Actors ---
// ... (Actor schema remains the same)
export const actors = pgTable("actors", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  gender: text("gender").notNull(),
  nationality: text("nationality").notNull(),
  notableRoles: jsonb("notable_roles").$type<string[]>().notNull(),
  genres: jsonb("genres").$type<string[]>().notNull(),
  recentPopularity: text("recent_popularity").notNull(),
  typicalRoles: jsonb("typical_roles").$type<string[]>().notNull(),
  estSalaryRange: text("est_salary_range").notNull(),
  socialMediaFollowing: text("social_media_following").notNull(),
  availability: text("availability").notNull(),
  bestSuitedRolesStrategic: text("best_suited_roles_strategic").notNull(),
  imageUrl: text("image_url"),
  dateOfBirth: text("date_of_birth"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertActorSchema = createInsertSchema(actors, {
  name: (schema) => schema.min(2, "Actor name must be at least 2 characters"),
  gender: (schema) => schema.min(1, "Gender cannot be empty"),
  nationality: (schema) =>
    schema.min(2, "Nationality must be at least 2 characters"),
  dateOfBirth: (schema) => schema.optional(),
});

export type InsertActor = z.infer<typeof insertActorSchema>;
export type Actor = typeof actors.$inferSelect;


// --- Locations ---
// ... (Location schema remains the same)
export const locations = pgTable("locations", {
  id: serial("id").primaryKey(),
  country: text("country").notNull(),
  region: text("region").notNull(),
  incentiveProgram: text("incentive_program").notNull(),
  incentiveDetails: text("incentive_details").notNull(),
  minimumSpend: text("minimum_spend").notNull(),
  eligibleProductionTypes: text("eligible_production_types").notNull(),
  limitsCaps: text("limits_caps"),
  qualifyingExpenses: text("qualifying_expenses"),
  applicationProcess: text("application_process"),
  applicationDeadlines: text("application_deadlines"),
  imageUrl: text("image_url"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertLocationSchema = createInsertSchema(locations, {
  country: (schema) =>
    schema.min(2, "Country name must be at least 2 characters"),
  region: (schema) => schema.min(2, "Region must be at least 2 characters"),
  incentiveProgram: (schema) =>
    schema.min(2, "Incentive program must be at least 2 characters"),
  incentiveDetails: (schema) =>
    schema.min(2, "Incentive details must be at least 2 characters"),
});

export type InsertLocation = z.infer<typeof insertLocationSchema>;
export type Location = typeof locations.$inferSelect;


// --- Script Generation Form ---
// ... (ScriptGenerationForm schema remains the same)
export const scriptGenerationFormSchema = z.object({
  projectTitle: z.string().min(1, "Project Title is required."),
  logline: z
    .string()
    .min(10, "Logline should be at least 10 characters.")
    .max(200, "Logline should be at most 200 characters."),
  description: z
    .string()
    .min(20, "Description should be at least 20 characters.")
    .max(1000, "Description should be at most 1000 characters."),
  genre: z
    .string()
    .min(1, "Genre is required.")
    .max(50, "Genre should be at most 50 characters."),
  concept: z
    .string()
    .min(20, "Concept should be at least 20 characters.")
    .max(2000, "Concept should be at most 2000 characters."),
  targetedRating: z.enum(
    Object.keys(FilmRatingEnum) as [FilmRatingType, ...FilmRatingType[]],
    { message: "Invalid rating selected." },
  ),
  storyLocation: z
    .string()
    .min(1, "Story Location is required.")
    .max(100, "Story Location should be at most 100 characters."),
  specialRequest: z
    .string()
    .max(1000, "Special Request should be at most 1000 characters.")
    .optional(),
});
export type ScriptGenerationFormData = z.infer<
  typeof scriptGenerationFormSchema
>;


